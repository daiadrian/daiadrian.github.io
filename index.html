<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="看板娘赛高！">
<meta property="og:type" content="website">
<meta property="og:title" content="Adrian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Adrian">
<meta property="og:description" content="看板娘赛高！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Adrian">
<meta name="twitter:description" content="看板娘赛高！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Adrian</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/daiadrian" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Adrian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/Zookeeper小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/Zookeeper小结/" itemprop="url">zookeeper小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T11:18:00+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Zookeeper？"><a href="#什么是Zookeeper？" class="headerlink" title="什么是Zookeeper？"></a>什么是Zookeeper？</h2><p>​        Zookeeper是一个开源的<strong>分布式的，为分布式应用提供协调服务</strong>的Apache项目。</p>
<p>​        ZooKeeper是一个经典的<strong><font color="red">分布式数据一致性解决方案</font></strong>，致力于为分布式应用提供一个高性能、高可用，且具有<strong>严格顺序访问</strong>控制能力的分布式协调服务</p>
<p>​        分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负载均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。</p>
<h3 id="zookeeper的一些特点"><a href="#zookeeper的一些特点" class="headerlink" title="zookeeper的一些特点"></a>zookeeper的一些特点</h3><ol>
<li>顺序一致性：从同一个client客户端发来的请求，会按其发送的顺序来执行</li>
<li>原子性：一次数据处理要么全部成功，要么全部失败</li>
<li>数据一致性：每个Server保存一份相同的数据，客户端无论连接到哪个Server，数据都是一致的</li>
<li>实时性：在一定时间范围内，客户端能够读取到最新的数据</li>
</ol>
<h3 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h3><p>​        ZK会维护一个具有层次关系的树状的数据结构，每个树节点称为一个ZNode。每个ZNode默认能够存储1MB的数据，每个ZNode都可以通过路径唯一标识</p>
<p>​        一个ZNode既能在它下面创建子节点，作为路径标识的一部分，同时该节点也能存储数据；主要存放分布式应用的配置信息和状态信息等</p>
<p>​        每个ZNode节点都有各自的版本号，当节点数据发生变化是，那该节点的版本号也会累加（乐观锁的机制）</p>
<p><strong>节点类型</strong></p>
<ul>
<li>持久（Persistent）：客户端和服务器断开连接后，创建的节点不会被删除</li>
<li>短暂（Ephemeral）：客户端和服务器断开连接后，创建的节点会自动删除</li>
</ul>
<blockquote>
<p>​        创建ZNode节点的时候可以设置顺序标识，ZNode名称后会附加一个顺序号，这个顺序号是单调递增的计数器，并且是由父节点来维护的</p>
<p>​        注意：在分布式系统中，顺序号可以被用于所有事件的全局排序；客户端可以通过顺序号来推断事件的执行顺序</p>
</blockquote>
<h3 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h3><ol>
<li><p><strong>统一命名服务</strong></p>
<blockquote>
<p>在分布式环境下，对应用/服务进行统一的命名，会便于识别</p>
<p>对外只显示服务的名称，通过节点去访问对应IP的服务</p>
</blockquote>
</li>
<li><p><strong>统一配置管理</strong></p>
<blockquote>
<p>​        集群中一般要求所有节点的配置信息是一致的，例如Kafka集群。并且对配置文件修改后，能够快速更新到各个节点上</p>
<p>​        可以将配置信息写入ZNode中，各个客户端监听该配置信息的状态，一旦ZNode中的数据发生改变，可以及时通知各个客户端将最新的配置信息更新到系统中</p>
</blockquote>
</li>
<li><p><strong>统一集群管理</strong></p>
<blockquote>
<p>​        服务节点动态上下线，当ZK中注册的服务下线时，客户端能够实时的得到下线通知；这里可以通过ZK的监听器去监听节点的动态新增/删除</p>
</blockquote>
</li>
<li><p><strong>分布式锁</strong></p>
<blockquote>
</blockquote>
</li>
<li><p>软负载均衡</p>
<blockquote>
<p>ZK记录节点上的服务，可以让访问数最少的服务器去处理最新的客户端请求</p>
</blockquote>
</li>
</ol>
<h2 id="ZK安装"><a href="#ZK安装" class="headerlink" title="ZK安装"></a>ZK安装</h2><blockquote>
<p>​        注意：下面操作没有设置环境变量，如果设置的环境变量，那么可以在<strong>全局环境</strong>下直接使用zkServer.sh或者zkCli.sh</p>
<p>设置方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> vim /etc/profile</span><br><span class="line"><span class="meta">&gt;</span> export ZOOKEEPER_HOME=/opt/zookeeper</span><br><span class="line"><span class="meta">&gt;</span> export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ol>
<li><p>解压tar.gz文件到指定目录下（/opt）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制conf下的zoo_sample.cfg为新文件zoo.cfg，并且在zookeeper的主目录下创建data文件夹，并在配置文件中设置data目录和dataLog目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zookeeper/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">cd /opt/zookeeper</span><br><span class="line">mkdir data</span><br><span class="line">vim /opt/zookeeper/conf/zoo.cfg</span><br><span class="line">	dataDir=/opt/zookeeper/data</span><br><span class="line">	dataLogDir=/opt/zookeeper/dataLog</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zk</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span>关闭zk</span><br><span class="line">bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk的状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk进程是否启动</span><br><span class="line">jps</span><br><span class="line">	4020 Jps</span><br><span class="line">	4001 QuorumPeerMain</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h3><ol>
<li><p>在data目录下创建myid文件，在文件上添加ZK编号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch myid</span><br><span class="line">	1</span><br><span class="line"><span class="meta">#</span>#其他ZK的机子上需要添加不同的编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 zoo.cfg 配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta">	#</span>######################cluster##########################</span><br><span class="line">    server.1=zk1:2888:3888</span><br><span class="line">    server.2=zk2:2888:3888</span><br><span class="line">    server.3=zk3:2888:3888</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span>######################cluster##########################</span><br><span class="line">server.1=localhost:2881:3881</span><br><span class="line">server.2=localhost:2882:3882</span><br><span class="line">server.3=localhost:2883:3883</span><br></pre></td></tr></table></figure>
<p>配置文件解析：</p>
<ul>
<li>server后面的数字就是 myid 文件制定的编号</li>
<li>zk1 是你服务器的 ip 地址</li>
<li>2888 是zk集群的信息交换端口（不一定是2888，可自行指定）</li>
<li>3888 是zk集群中Leader节点挂了之后重新选择Leader节点时进行通信的端口（同样可自行选择其他端口）</li>
</ul>
</li>
</ol>
<h2 id="深入学习Zookeeper"><a href="#深入学习Zookeeper" class="headerlink" title="深入学习Zookeeper"></a>深入学习Zookeeper</h2><h3 id="ZK配置文件"><a href="#ZK配置文件" class="headerlink" title="ZK配置文件"></a>ZK配置文件</h3><ol>
<li><p>tickTime</p>
<p>通信心跳数，Zookeeper<strong>服务器与客户端</strong>心跳时间，单位毫秒</p>
<blockquote>
<p>​        Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒</p>
<p>​        它用于心跳机制，并且设置最小的session（会话）超时时间为两倍心跳时间（session的最小超时时间是2*tickTime）</p>
</blockquote>
</li>
<li><p>initLimit</p>
<p>集群中主从服务器之间的<strong>初始通信时限</strong></p>
<blockquote>
<p>​        集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限</p>
</blockquote>
</li>
<li><p>syncLimit</p>
<p>集群中主从服务器之间的<strong>同步通信时限</strong></p>
<blockquote>
<p>​        集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer</p>
</blockquote>
</li>
<li><p>dataDir</p>
<p>数据文件目录+数据持久化路径</p>
</li>
<li><p>dataLogDir</p>
<p>日志文件目录，如果不配置则使用dataDir的目录进行日志的存放</p>
</li>
<li><p>clientPort </p>
<p>监听客户端连接的端口，默认是2181</p>
</li>
</ol>
<h3 id="ZK集群"><a href="#ZK集群" class="headerlink" title="ZK集群"></a>ZK集群</h3><h4 id="选举机制中的基础概念"><a href="#选举机制中的基础概念" class="headerlink" title="选举机制中的基础概念"></a>选举机制中的基础概念</h4><ol>
<li><p>服务器ID</p>
<blockquote>
<p>即myid文件中的编号；编号越大，权重越大</p>
</blockquote>
</li>
<li><p>Zxid，数据ID</p>
<blockquote>
<p>服务器中存放的最大数据ID；值越大说明该数据越新，权重越大</p>
</blockquote>
</li>
<li><p>Epoch：逻辑时钟</p>
<blockquote>
<p>​    投票的次数（轮数），同一轮投票过程中的逻辑时钟值是相同的</p>
<p>​    每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断</p>
</blockquote>
</li>
<li><p>Server状态：选举状态</p>
<ul>
<li>LOOKING，竞选状态</li>
<li>FOLLOWING，随从状态，同步leader状态，参与投票</li>
<li>OBSERVING，观察状态,同步leader状态，不参与投票</li>
<li>LEADING，领导者状态</li>
</ul>
</li>
</ol>
<h4 id="选举简易流程"><a href="#选举简易流程" class="headerlink" title="选举简易流程"></a>选举简易流程</h4><p>​    目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ol>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于<strong>Looking（竞选状态）</strong></li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果；由于服务器2的编号比服务器1的大，所以服务器2胜出；但此时投票数没有大于半数，所以<strong>两个服务器的状态依然是LOOKING</strong></li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1和2交换信息，由于服务器3的编号最大，所以服务器3胜出，此时投票数正好<strong>大于半数</strong>，所以服务器3成为Leader，服务器1和2成为Follower，状态变成FOLLOWING</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但服务器3的状态已经是Leading，所以服务器4也是Follower</li>
<li>服务器5启动，逻辑同服务器4</li>
</ol>
<p><strong>几种情况的选举</strong></p>
<ol>
<li><p>一台宕机重启的机器加入已有环境，如果已有环境中已经存在Leader，那么该机器会变成Follwoer</p>
</li>
<li><p>一台机器加入正在投票中的环境</p>
<p>所有server都会接受优先级最高的投票，最高优先级最高的选票当选，选举结束</p>
</li>
<li><p>当集群中多数机器宕机重启</p>
<p>​    存活的服务发现不满足多数派，改变状态为LOOKING，投票轮数+1，然后重新开始投票，会按照优先级的选举投票直至结束</p>
<ul>
<li>逻辑时钟小的选举结果被忽略，重新投票</li>
<li>统一逻辑时钟后，数据 version 大的胜出</li>
<li>数据 version 相同的情况下，server id 大的胜出</li>
</ul>
</li>
</ol>
<p>以上，只要有超过半数的机器存活，最终会完成投票</p>
<h4 id="选举机制（半数机制）"><a href="#选举机制（半数机制）" class="headerlink" title="选举机制（半数机制）"></a>选举机制（半数机制）</h4><p>​        集群中<strong>半数以上</strong>机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</p>
<p>​        Zookeeper虽然在配置文件中并没有指定Master和Slave。Zookeeper工作时只有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制<strong>临时产生</strong>的</p>
<h3 id="zkClient"><a href="#zkClient" class="headerlink" title="zkClient"></a>zkClient</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk客户端</span><br><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="meta">#</span>#指定访问server</span><br><span class="line">zkCli.sh -server 192.168.1.1:2181</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##常用操作</span><br><span class="line">create /dh "shuaige"</span><br><span class="line">get /dh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#创建短暂节点</span><br><span class="line">create -e /dh/fat "fat"</span><br><span class="line"><span class="meta">#</span>#创建带顺序号的持久节点</span><br><span class="line">create -s /dh/handsome "handsome"</span><br><span class="line"><span class="meta">#</span>#修改节点的值</span><br><span class="line">set /dh/fat "littlefat" 0</span><br><span class="line"><span class="meta">#</span>#删除节点</span><br><span class="line">delete /dh/fat 0</span><br><span class="line"><span class="meta">#</span>#递归删除</span><br><span class="line">rmr /dh</span><br></pre></td></tr></table></figure>
<h4 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h4><table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>使用 ls 命令来查看当前znode中所包含的内容</td>
</tr>
<tr>
<td>ls2 path [watch]</td>
<td>查看当前节点数据并能看到更新次数等数据（详细数据）</td>
</tr>
<tr>
<td>create [选项]</td>
<td>普通创建一个zNode    -s ：含有序列    -e：临时（重启或者超时消失）</td>
</tr>
<tr>
<td>get path [watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set path  data  [version]</td>
<td>设置（修改）节点的具体值，可根据版本号对节点的值进行修改（推荐使用版本号修改，乐观锁机制）</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete path  data [version]</td>
<td>删除节点，可根据版本号对节点进行删除（推荐使用版本号删除，乐观锁机制）</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody>
</table>
<h4 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>
<ol>
<li><p>cZxid：创建节点的事务zxid</p>
<p>​        每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID</p>
<p>​        事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</p>
</li>
<li><p>ctime：znode被创建的毫秒数(从1970年开始)</p>
</li>
<li><p>mzxid：znode最后更新的事务zxid</p>
</li>
<li><p>mtime：znode最后修改的毫秒数(从1970年开始)</p>
</li>
<li><p>pZxid：znode最后更新的子节点zxid</p>
</li>
<li><p>cversion：znode子节点变化版本号，znode子节点修改次数</p>
</li>
<li><p>dataversion：znode数据变化版本号</p>
</li>
<li><p>aclVersion：znode访问控制列表的变化版本号</p>
</li>
<li><p>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</p>
</li>
<li><font color="red">dataLength：znode的数据长度</font>
</li>
<li><font color="red">numChildren：znode子节点数量</font>



</li>
</ol>
<h4 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h4><p>​        watcher是zk中的监听器机制，父节点或者子节点的增删改操作都能够触发watcher事件</p>
<p><strong>事件类型</strong></p>
<ol>
<li>父节点创建：NodeCreated</li>
<li>父节点数据修改：NodeDataChanged</li>
<li>父节点删除：NodeDeleted</li>
<li>创建了子节点：NodeChildrenChanged</li>
<li>删除子节点：NodeChildrenChanged</li>
<li>修改子节点不触发任何事件</li>
</ol>
<p><strong>watcher机制的使用场景</strong></p>
<p>​        统一的配置管理，可以监听配置信息的节点，当配置信息的节点数据发生变化的时候触发客户端更新配置的操作</p>
<h4 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h4><p>​        ACL（access control lists），可以针对节点设置读写等权限，可以保障数据的安全性；如果没有权限，则会抛出异常</p>
<p>zk的acl通过 [scheme​ : id : ​permissions] 的形式来构成权限的列表</p>
<ul>
<li>scheme：代表采用的某种权限机制</li>
<li>id：代表允许访问的用户</li>
<li>permissions：权限组合字符串（有crdwa）<ul>
<li>c：CREATE，创建子节点</li>
<li>r：READ，获取节点/子节点</li>
<li>d：DELETE，删除子节点</li>
<li>w：WRITE，设置节点数据</li>
<li>a：ADMIN，设置权限</li>
</ul>
</li>
</ul>
<blockquote>
<p>权限示例：</p>
<p>world：world:anyone:[permissions]</p>
<p>auth：auth:user:password:[permissions] 代表认证登录，需要注册的用户有操作权限即可</p>
<p>digest：digest:username:BASE64(SHA1(password)):[permissions] 表示需要对密码进行加密才可以访问</p>
<p>ip：ip:ip地址:[permissions]  可以限制指定ip才能访问该节点</p>
</blockquote>
<p><strong>ACL的命令行操作</strong></p>
<ol>
<li><p>getAcl：获取某个节点的acl权限信息</p>
</li>
<li><p>setAcl：设置某个节点的acl权限信息</p>
<blockquote>
<p>示例：（1和2是等价的）</p>
<ol>
<li>setAcl /path auth:dai:dai:cdrwa</li>
<li>setAcl /path digest:dai:password:cdrwa</li>
</ol>
<p>上面两个操作后需要进行addauth操作后才能够对 /path 进行操作</p>
<ol start="3">
<li>setAcl /path ip:192.168.1.1:cdrwa</li>
</ol>
<p>设置ip后，只有指定ip的客户端才有权限去访问该节点</p>
</blockquote>
</li>
<li><p>addauth：输入认证授权信息，注册时输入明文密码，在zk系统中，密码都是以加密的形式存在的</p>
<blockquote>
<p>参照2的示例： 执行 addauth digest:dai:dai  登录后能获取上面设置节点的操作权限  </p>
<p>​        注意：要使用 dai 用户前需要先注册 dai 用户才可以设置成功，注册用户同样是addAuth命令：addauth digest  dai:dai</p>
<p>​        注意：使用 digest 来设置权限时，查看加密后的password可以通过getAcl，比如：</p>
<p>getAcl /dh</p>
<p>​    ‘digest，’dai:password（此处的password是加密后的显示）</p>
</blockquote>
</li>
</ol>
<h2 id="Java使用ZK"><a href="#Java使用ZK" class="headerlink" title="Java使用ZK"></a>Java使用ZK</h2><h3 id="原生ZK的API"><a href="#原生ZK的API" class="headerlink" title="原生ZK的API"></a>原生ZK的API</h3><h4 id="引入POM"><a href="#引入POM" class="headerlink" title="引入POM"></a>引入POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本与ZK版本一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="连接ZK"><a href="#连接ZK" class="headerlink" title="连接ZK"></a>连接ZK</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ZKConnect.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line"><span class="comment">//	public static final String zkServerPath = "192.168.1.1:2181,192.168.1.2:2182,192.168.1.3:2183";</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 客户端和zk服务端链接是一个异步的过程</span></span><br><span class="line"><span class="comment">		 * 当连接成功后后，客户端会收的一个watch通知</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * connectString：连接服务器的ip字符串，</span></span><br><span class="line"><span class="comment">		 * 		比如: "192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181"</span></span><br><span class="line"><span class="comment">		 * 		可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群</span></span><br><span class="line"><span class="comment">		 * 		</span></span><br><span class="line"><span class="comment">		 * sessionTimeout：超时时间，心跳收不到了，那就超时</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，</span></span><br><span class="line"><span class="comment">		 * 					 此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionId：会话的id</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionPasswd：会话密码	</span></span><br><span class="line"><span class="comment">		 *          当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(zkServerPath, timeout, <span class="keyword">new</span> ZKDemo());</span><br><span class="line">		log.warn(<span class="string">"连接状态：&#123;&#125;"</span>, zk.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始会话重连</span></span><br><span class="line">        <span class="keyword">long</span> sessionId = zk.getSessionId();</span><br><span class="line">		<span class="keyword">byte</span>[] sessionPassword = zk.getSessionPasswd();</span><br><span class="line">		log.warn(<span class="string">"开始会话重连..."</span>);</span><br><span class="line">		ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(zkServerPath, </span><br><span class="line">											timeout, </span><br><span class="line">											<span class="keyword">new</span> ZKDemo(), </span><br><span class="line">											sessionId, </span><br><span class="line">											sessionPassword);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">		<span class="keyword">new</span> Thread().sleep(<span class="number">1000</span>);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		log.warn(<span class="string">"接受到watch通知：&#123;&#125;"</span>, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK的节点操作"><a href="#ZK的节点操作" class="headerlink" title="ZK的节点操作"></a>ZK的节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNode</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNode());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNode zkServer = <span class="keyword">new</span> ZKNode(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *查询节点是否存在</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：watch</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Stat stat = zkServer.getZookeeper().exists(<span class="string">"/dh-demo"</span>, <span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"查询的节点版本为dataVersion："</span> + stat.getVersion());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"该节点不存在..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		  * 同步或者异步创建节点，都不支持子节点的递归创建，异步有一个callback函数</span></span><br><span class="line"><span class="comment">		  * 参数：</span></span><br><span class="line"><span class="comment">		  * path：创建的路径</span></span><br><span class="line"><span class="comment">		  * data：存储的数据的byte[]</span></span><br><span class="line"><span class="comment">		  * acl：控制权限策略</span></span><br><span class="line"><span class="comment">		  * 			Ids.OPEN_ACL_UNSAFE --&gt; world:anyone:cdrwa</span></span><br><span class="line"><span class="comment">		  * 			CREATOR_ALL_ACL --&gt; auth:user:password:cdrwa</span></span><br><span class="line"><span class="comment">		  * createMode：节点类型, 是一个枚举</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT：持久节点</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT_SEQUENTIAL：持久顺序节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL：临时节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL_SEQUENTIAL：临时顺序节点</span></span><br><span class="line"><span class="comment">		  */</span> 	       </span><br><span class="line">        String ctx = <span class="string">"&#123;'create':'success'&#125;"</span>;</span><br><span class="line">		zookeeper.create(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.get, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> CreateCallBack(), ctx);</span><br><span class="line">             </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *获取一个节点的值</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：true或者false，注册一个watch事件</span></span><br><span class="line"><span class="comment">		 * stat：状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] resByte = zkServer.getZookeeper().getData(<span class="string">"/dh"</span>, <span class="keyword">true</span>, stat);</span><br><span class="line">		String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line">		System.out.println(<span class="string">"当前值:"</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *设置节点的数据</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * data：数据</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		stat  = zkServer.getZookeeper().setData(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		System.out.println(status.getVersion());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *删除节点(带回调的)</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        String ctx = <span class="string">"&#123;'delete':'success'&#125;"</span>;</span><br><span class="line">		zkServer.getZookeeper().delete(<span class="string">"/dh-path"</span>, stat.getVersion(), <span class="keyword">new</span> DeleteCallBack(), ctx);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对节点的监听</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getType() == EventType.NodeCreated) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点创建"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点数据改变"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDeleted) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点删除"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CallBack回调</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCallBack</span> <span class="keyword">implements</span> <span class="title">StringCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建节点: "</span> + path);</span><br><span class="line">		<span class="comment">//ctx 就是create方法传入的ctx参数</span></span><br><span class="line">		System.out.println((String)ctx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildrenCallBack</span> <span class="keyword">implements</span> <span class="title">ChildrenCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String s : children) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"ChildrenCallback:"</span> + path);</span><br><span class="line">		System.out.println((String)ctx);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNodeAcl</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNodeAcl());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createZKNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acls)</span> </span>&#123;</span><br><span class="line">		String result = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			result = zookeeper.create(path, data, acls, CreateMode.PERSISTENT);</span><br><span class="line">			System.out.println(<span class="string">"创建节点：\t"</span> + result + <span class="string">"\t成功..."</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNodeAcl zkServer = <span class="keyword">new</span> ZKNodeAcl(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * ======================  创建node start  ======================  </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// acl 任何人都可以访问</span></span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl"</span>, <span class="string">"data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 自定义用户认证访问</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * DigestAuthenticationProvider.generateDigest(String str)</span></span><br><span class="line"><span class="comment">         * 这个方法是zk客户端提供的加密方式 BASE61(SHA1(password))</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id acl1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        </span><br><span class="line">		Id acl2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.ALL, acl1));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.READ, acl2));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.DELETE | Perms.CREATE, acl2));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test"</span>, <span class="string">"testdigest"</span>.getBytes(), acls);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 注册过的用户必须通过addAuthInfo才能操作节点，参考命令行 addauth</span></span><br><span class="line">		zkServer.getZookeeper().addAuthInfo(<span class="string">"digest"</span>, <span class="string">"dai1:123456"</span>.getBytes());</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test/childtest"</span>, <span class="string">"childtest"</span>.getBytes(), Ids.CREATOR_ALL_ACL);</span><br><span class="line">		Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/test"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ip方式的acl</span></span><br><span class="line">		List&lt;ACL&gt; aclsIP = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id ipId = <span class="keyword">new</span> Id(<span class="string">"ip"</span>, <span class="string">"192.168.1.10"</span>);</span><br><span class="line">		aclsIP.add(<span class="keyword">new</span> ACL(Perms.ALL, ipId));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"data"</span>.getBytes(), aclsIP);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 验证ip是否有权限</span></span><br><span class="line">        zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"setdata"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/aclimooc/iptest6"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		System.out.println(stat.getVersion());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Apache-Curator"><a href="#Apache-Curator" class="headerlink" title="Apache Curator"></a>Apache Curator</h3><h4 id="ZK连接及节点操作"><a href="#ZK连接及节点操作" class="headerlink" title="ZK连接及节点操作"></a>ZK连接及节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy1 = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryNTimes</span></span><br><span class="line"><span class="comment">         *              n：重试的次数</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries：每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryOneTime</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetry:每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy2 = <span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryUntilElapsed</span></span><br><span class="line"><span class="comment">         *              maxElapsedTimeMs:最大重试时间</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries:每次重试间隔</span></span><br><span class="line"><span class="comment">         *              重试时间超过maxElapsedTimeMs,就不再重试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy3 = <span class="keyword">new</span> RetryUntilElapsed(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//判断链接是否成功</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建节点:</span></span><br><span class="line"><span class="comment">         *      creatingParentsIfNeeded : 开启递归的创建方式,不用一层一层的创建</span></span><br><span class="line"><span class="comment">         *      withMode  : 节点的类型</span></span><br><span class="line"><span class="comment">         *      withACL   : acl权限</span></span><br><span class="line"><span class="comment">         *      forPath   : 节点路径和数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String nodePath = <span class="string">"/dai"</span>;</span><br><span class="line">        String str = client.create()</span><br><span class="line">                            .creatingParentsIfNeeded()</span><br><span class="line">                            .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                            .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                            .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点数据:</span></span><br><span class="line"><span class="comment">         *      storingStatIn : 把服务器端获取的状态数据存储到stat对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = client.getData()</span><br><span class="line">                            .storingStatIn(stat)</span><br><span class="line">                            .forPath(nodePath);</span><br><span class="line">        System.out.println(<span class="string">"节点"</span> + nodePath + <span class="string">"的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">        System.out.println(<span class="string">"该节点的版本号为: "</span> + stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新节点数据:</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.setData()</span><br><span class="line">                .withVersion(stat.getVersion())</span><br><span class="line">                .forPath(nodePath, <span class="string">"update"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除节点:</span></span><br><span class="line"><span class="comment">         *      guaranteed : 保障措施,只要客户端会话有效; 那么Curator会在后台持续进行删除操作,直到删除节点成功</span></span><br><span class="line"><span class="comment">         *      deletingChildrenIfNeeded : 递归删除,有子节点的情况下会将所有子节点也一并删除</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        client.getData().storingStatIn(stat).forPath(nodePath);</span><br><span class="line">		client.delete()</span><br><span class="line">              .guaranteed()</span><br><span class="line">              .deletingChildrenIfNeeded()</span><br><span class="line">              .withVersion(stat.getVersion())</span><br><span class="line">              .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查询子节点</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		List&lt;String&gt; childNodes = client.getChildren().forPath(nodePath);</span><br><span class="line">		System.out.println(<span class="string">"开始打印子节点："</span>);</span><br><span class="line">		<span class="keyword">for</span> (String child : childNodes) &#123;</span><br><span class="line">			System.out.println(child);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断节点是否存在,如果不存在则为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		Stat statExist = client.checkExists().forPath(nodePath + <span class="string">"/exist"</span>);</span><br><span class="line">		System.out.println(statExist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件:</span></span><br><span class="line"><span class="comment">         *      当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.getData().usingWatcher(<span class="keyword">new</span> MyCuratorWatcher()).forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      NodeCache: 监听数据节点的变更，会触发事件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, nodePath);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  参数:</span></span><br><span class="line"><span class="comment">         *      buildInitial : 初始化的时候获取node的值并且缓存</span></span><br><span class="line"><span class="comment">         *          只有开启这个缓存后,下面的getCurrentData方法才能拿到数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为空..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">"节点数据为空"</span>);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String data = <span class="keyword">new</span> String(nodeCache.getCurrentData().getData());</span><br><span class="line">				System.out.println(<span class="string">"节点路径："</span> + nodeCache.getCurrentData().getPath() + <span class="string">"  数据："</span> + data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为子节点添加watcher事件</span></span><br><span class="line"><span class="comment">         *      PathChildrenCache: 监听数据节点的增删改，会触发事件</span></span><br><span class="line"><span class="comment">         *      cacheData: 是否设置缓存节点的数据状态</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, nodePath, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * StartMode: 初始化方式</span></span><br><span class="line"><span class="comment">         *      POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件</span></span><br><span class="line"><span class="comment">         *      NORMAL：异步初始化</span></span><br><span class="line"><span class="comment">         *      BUILD_INITIAL_CACHE：同步初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line"></span><br><span class="line">        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line">        System.out.println(<span class="string">"当前数据节点的子节点数据列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (ChildData child : childDataList) &#123;</span><br><span class="line">            String childData = <span class="keyword">new</span> String(child.getData());</span><br><span class="line">            System.out.println(childData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"子节点初始化ok..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED))&#123;</span><br><span class="line">                    String path = event.getData().getPath();</span><br><span class="line">                    <span class="keyword">if</span> (path.equals(<span class="string">"dh-add"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加子节点:"</span> + event.getData().getPath());</span><br><span class="line">                        System.out.println(<span class="string">"子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">"/super/imooc/e"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加不正确..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"删除子节点:"</span> + event.getData().getPath());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点路径:"</span> + event.getData().getPath());</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted2 = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCuratorWatcher</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"触发了watch 事件，节点路径："</span> + watchedEvent.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限-1"><a href="#ACL权限-1" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        List&lt;ACL&gt; aclList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Id 构造参数:</span></span><br><span class="line"><span class="comment">         *         scheme:认证方式</span></span><br><span class="line"><span class="comment">         *                      world：默认方式，相当于全世界都能访问</span></span><br><span class="line"><span class="comment">         *                      auth：代表已经认证通过的用户</span></span><br><span class="line"><span class="comment">         *                      digest：即用户名:密码这种方式认证</span></span><br><span class="line"><span class="comment">         *                      ip：使用Ip地址认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Id id1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        Id id2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ACL 构造参数:</span></span><br><span class="line"><span class="comment">         *          perms:五种权限:</span></span><br><span class="line"><span class="comment">         *                          CREATE: 能创建子节点</span></span><br><span class="line"><span class="comment">         *                          READ：能获取节点数据和列出其子节点</span></span><br><span class="line"><span class="comment">         *                          WRITE: 能设置节点数据</span></span><br><span class="line"><span class="comment">         *                          DELETE: 能删除子节点</span></span><br><span class="line"><span class="comment">         *                          ADMIN: 能设置权限</span></span><br><span class="line"><span class="comment">         *             Id:就是上面的Id类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.ALL, id1));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.READ, id2));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.CREATE | Perms.WRITE, id2));</span><br><span class="line">        client.setACL().withACL(aclList).forPath(<span class="string">"/dai/dh/hao"</span>);</span><br><span class="line">        client.create()</span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * withACL 第二个参数applyToParents :</span></span><br><span class="line"><span class="comment">                 *                      如果设置为true,那么会将这些acl权限加到创建的父节点上(递归创建)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .withACL(aclList, <span class="keyword">true</span>)</span><br><span class="line">                .forPath(<span class="string">"/dai/dh/hao"</span>, <span class="string">"data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/CAP理论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/CAP理论/" itemprop="url">CAP理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T23:00:10+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CAP理论</p>
<h2 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h2><p>​    CAP理论指的是在一个<strong>分布式系统</strong>中，不能同时满足一致性，可用性和分区容错性</p>
<ol>
<li><p>C（Consistency）：一致性</p>
<blockquote>
<p>在分布式系统中的所有数据备份，在同一时刻是否是同样的值</p>
</blockquote>
</li>
<li><p>A（Availabe）：可用性</p>
<blockquote>
<p>​    可用性指在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</p>
<p>​    可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。“有效的时间内”是指，对于用户的一个操作请求，<strong>系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的</strong></p>
</blockquote>
</li>
<li><p>P（Partition Tolenrance）：分区容错性</p>
<blockquote>
<p>​    以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用</p>
</blockquote>
</li>
</ol>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>​    分区容错性约束了一个分布式系统具有如下特性：<font color="red">分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</font></p>
<p><strong>网络分区</strong></p>
<p>​    网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况；但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p>
<p>​    需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区</p>
<h3 id="Consistency一致性强弱"><a href="#Consistency一致性强弱" class="headerlink" title="Consistency一致性强弱"></a>Consistency一致性强弱</h3><p>​    一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即<strong><font color="red">数据变动在系统内部各节点应该是同步的</font></strong></p>
<p>根据一致性强弱可分为：</p>
<ol>
<li><strong>强一致性</strong>（Strong Consistency）任何时刻，任何用户都能读取到最近一次成功更新的数据</li>
<li><strong>单调一致性</strong>（Monotonic Consistency）任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说<strong>可获取的数据顺序必是单调递增的</strong></li>
<li><strong>会话一致性</strong>（Session Consistency）任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在<font color="blue">本次会话中就不会再读到比这个值更旧的值</font>。<u>会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障</u></li>
<li><strong>最终一致性</strong>（Eventual Consistency）用户只能读到某次更新后的值，<font color="blue">但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障</font></li>
<li><strong>弱一致性</strong>（Weak Consistency）用户无法在确定时间内读到最新更新的值</li>
</ol>
<h3 id="CAP的抉择"><a href="#CAP的抉择" class="headerlink" title="CAP的抉择"></a>CAP的抉择</h3><table>
<thead>
<tr>
<th><strong>选    择</strong></th>
<th style="text-align:left"><strong>说    明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td style="text-align:left">放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td>
</tr>
<tr>
<td>AP</td>
<td style="text-align:left">放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td style="text-align:left">放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<h4 id="简单的CAP例子"><a href="#简单的CAP例子" class="headerlink" title="简单的CAP例子"></a>简单的CAP例子</h4><p>​    一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取    </p>
<ol>
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功</strong></p>
<blockquote>
<p>在没有出现网络故障的时候，满足CA原则</p>
<ul>
<li>C 即我的任何一个写入，更新操作成功并返回客户端完成后，分布式的所有节点在同一时间的数据完全一致</li>
<li>A 即我的读写操作都能够成功</li>
</ul>
<font color="blue">但是当出现网络故障时，我不能同时保证CA，即P条件无法满足</font>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><strong>假设DB的更新操作是只写本地机房成功就返回，通过binlog/oplog回放方式同步至侧边机房</strong></p>
<blockquote>
<p>​    这种操作保证了在出现网络故障时，双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP </p>
<p>​    但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在<strong><font color="red">短暂数据不一致</font></strong>，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务</strong></p>
<blockquote>
<p>降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是这无法满足可用性原则</p>
</blockquote>
</li>
</ol>
<h4 id="选择权衡"><a href="#选择权衡" class="headerlink" title="选择权衡"></a>选择权衡</h4><p>​    对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么<u>分布式系统中的组件必然需要被部署到不同的节点</u>，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统往往需要根据业务特点在C（一致性）和A（可用性）之间寻求平衡</p>
<p>​    对于大多数互联网应用来说，因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有舍弃强一致性（可以保证最终一致性）来保证服务的AP</p>
<p>​    但是对于需要确保强一致性的场景，如银行业务，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>​    BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<p>​    BASE理论的核心思想是：<strong><font color="red">即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</font></strong></p>
<ol>
<li><p>Basically Available（基本可用）</p>
<blockquote>
<p>基本可用是指分布式系统在出现不可预知故障的时候，<font color="blue">允许损失部分可用性</font></p>
<p>注意，这绝不等价于系统不可用。如：</p>
<ul>
<li><p>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p>
</li>
<li><p>系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p>
</li>
</ul>
</blockquote>
</li>
<li><p>Soft state（软状态）</p>
<blockquote>
<p>​    软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</strong></p>
</blockquote>
</li>
<li><p>Eventually consistent（最终一致性）</p>
<blockquote>
<p>​    最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态</p>
<p>​    因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
</blockquote>
</li>
</ol>
<h4 id="最终一致性变种"><a href="#最终一致性变种" class="headerlink" title="最终一致性变种"></a>最终一致性变种</h4><ol>
<li><p>因果一致性：</p>
<blockquote>
<p>​    因果一致性是指：如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制</p>
</blockquote>
</li>
<li><p>读己之所写：</p>
<blockquote>
<p>​    读己之所写是指：进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。</p>
<p>​    也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性</p>
</blockquote>
</li>
<li><p>会话一致性：</p>
<blockquote>
<p>​    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性</p>
<p>​    也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值</p>
</blockquote>
</li>
<li><p>单调读一致性：</p>
<blockquote>
<p>​       单调读一致性是指：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值</p>
</blockquote>
</li>
<li><p>单调写一致性：</p>
<blockquote>
<p> 单调写一致性是指：一个系统需要能够保证来自同一个进程的写操作被顺序地执行</p>
</blockquote>
</li>
</ol>
<p>​    总的来说：BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是<strong>通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。</p>
<p>​    在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/JVM垃圾收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/JVM垃圾收集/" itemprop="url">JVM垃圾收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T16:51:50+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文基于JDK7 HotSpot VM</p>
</blockquote>
<h3 id="判定对象无用的根据"><a href="#判定对象无用的根据" class="headerlink" title="判定对象无用的根据"></a>判定对象无用的根据</h3><p>​    通过可达性算法判断对象是否不再使用。即GC Roots，将GC Roots作为起始点向下搜索引用，还被GC Roots引用的对象就是可用的，而当一个对象没有到GC Roots有任何引用链的即为可回收的对象。</p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>当前各线程执行方法中的局部变量（包括形参）引用的对象</li>
<li>已被加载的类的 static 域引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>JNI （Native方法）引用的对象</li>
</ul>
<h3 id="内存的分配和回收"><a href="#内存的分配和回收" class="headerlink" title="内存的分配和回收"></a>内存的分配和回收</h3><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>​    在堆为对象分配内存空间之前，应该先知道对象在内存中存储的布局；对象在内存中的存储布局主要分为：对象头，实例数据和对齐填充。</p>
<ul>
<li>对象头：主要用于存储对象自身运行时的数据和类型指针<ul>
<li>运行时数据包括：哈希码（HashCode）、GC分代年龄、锁状态标志</li>
<li>类型指针是指向类元数据的指针</li>
</ul>
</li>
<li>实例数据：对象中的字段数据和父类继承过来的字段数据等</li>
<li>对齐填充：只是起到占位符的作用。因为HotSpotVM要求对象的起始地址必须是8字节的整数倍，当一个对象的实例数据（对象头是32bit或者64bit）不是8字节的整数倍时，就需要对齐填充来补全了</li>
</ul>
<h4 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h4><p>​        对象的内存分配主要在新生区的Eden空间上，当Eden区没有足够的连续空间时会触发一次MinorGC；但是一些需要连续大量内存空间的对象（很长的字符串或者数组）就会导致Eden区容纳不下这个对象（垃圾清理后仍然放不下），这个时候会直接在老年代中为其分配内存。</p>
<p>​    同时虚拟机也提供了-XX:PretenureSizeThreshold的参数，当对象的大小大于这个设置值的时候，会直接在老年代中进行内存分配，这样也可以避免新生代频繁的进行垃圾收集（新生代的垃圾收集是复制算法）</p>
<h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>​        了解了对象内存分配的位置，那么就需要知道内存分配的方式了。</p>
<ol>
<li>有大片连续内存空间时（常用于<strong>带压缩算法</strong>的收集器，如Serial，ParNew）</li>
</ol>
<p>​        当存在大片连续的内存可用于分配给新对象时，可以采用<strong>指针碰撞</strong>的方式（每次分配对象空间只要检测一下是否有足够的空间，如果有那么指针往前移动 N 位就分配好空间了，然后就可以初始化这个对象了）</p>
<p>​    对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot 使用了称之为<strong>Thread-Local Allocation Buffers (TLABs) 的技术</strong>，该技术能改善多线程空间分配的吞吐量。TLABs首先给予每个线程一部分内存作为缓存区，<font color="blue">每个线程都在自己的缓存区中进行指针碰撞</font>，这样就不用获取全局锁了。只有当一个线程使用完了它的 TLAB，它才需要使用同步锁定来获取一个新的缓冲区。</p>
<p>​    HotSpot 使用了多项技术来降低 TLAB 对于内存的浪费。比如，TLAB 的平均大小被限制在 Eden 区大小的 1% 之内。TLABs 和使用指针碰撞的线性分配结合，使得内存分配非常简单高效。</p>
<blockquote>
<p>可用-XX:+UseTLAB 来启用TLAB技术</p>
</blockquote>
<ol start="2">
<li>内存空间碎片较多时（如CMS收集器，使用Mark-Sweep算法）</li>
</ol>
<p>​        当已经使用的内存和空闲内存相互交错的时候，就不能直接的进行指针碰撞来分配内存了；这个时候虚拟机就会维护一个 <strong>“空闲列表”</strong> 来记录可用的内存块，在分配内存的时候会再列表中找到足够大的空间划分给对象，并且会更新列表上的记录</p>
<h4 id="内存分代思想"><a href="#内存分代思想" class="headerlink" title="内存分代思想"></a>内存分代思想</h4><p>​    虚拟机采用了分代收集的思想去管理堆内存；分代思想指的是虚拟机根据对象的存活周期来划分内存，一般将堆内存划分为年轻代（新生代）和老年代；年轻代是在垃圾收集的时候会有大量的对象死去的内存区域，而老年代中的对象普遍是存活率高的</p>
<p>​    年轻代因为每次都有大量的对象死去，所以一般会采用复制算法（下文介绍，因为此算法只需要复制少量的存活对象，成本较低）；虚拟机在对象创建的时候会给对象定义一个<font color="red">对象年龄的计数器</font>，对象在年轻代（Eden区）被创建并且经历过一次Minor GC（年轻代垃圾收集）并且存活，将会被移到Survivor区并且设置对象年龄为1，<u>该对象每熬过一次MinorGC，对象年龄就会加一</u>，当对象年龄达到一定程度就会晋升到老年代中（默认是15，可以通过-XX:MaxTenuringThreshold=15来设置）</p>
<p>​    但是如果每个对象都需要等到晋升年龄的话，Survivor区不一定能够容纳下这么多的对象。所以为了应对这种内存状况，虚拟机的解决办法是：<font color="red">如果Survivor区中<strong>相同年龄的所有对象大小的总和</strong>大于Survivor空间的一半，那么对象年龄大于或等于该值的对象就直接进入老年代，不需要达到晋升年龄</font></p>
<h3 id="什么时候触发垃圾收集"><a href="#什么时候触发垃圾收集" class="headerlink" title="什么时候触发垃圾收集"></a>什么时候触发垃圾收集</h3><ol>
<li>当年轻代被填满后（一般新对象在Eden区申请内存空间失败的时候），会进行一次年轻代垃圾收集（也叫做 Minor GC）</li>
<li>Full GC（通常也叫Major GC）会对整个堆进行垃圾收集，触发的情况：<ul>
<li>老年代或者永久代被填满的时候触发</li>
<li>当新生代对象晋升到老年代担保失败的时候触发（即年轻代垃圾收集后会有一部分晋升到老年代的对象，当老年代不能容纳这些晋升的对象时会触发）</li>
</ul>
</li>
<li>CMS垃圾收集器的触发时机；CMS垃圾收集器不会等到老年代或者永久代满了才开始进行垃圾收集（CMS只收集老年代old Gen），会有一个<strong>预设占用率（initiating occupancy）</strong><ul>
<li>老年代的使用率达到阈值（通过JVM参数：<strong>–XX:CMSInitiatingOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>永久代的使用率到达阈值（<strong>–XX:CMSInitiatingPermOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>当新生代对象晋升到老年代担保失败的时候触发</li>
</ul>
</li>
</ol>
<p>注意： <strong>只有CMS的concurrent collection是只收集old Gen的，其他的老年代垃圾收集器在满足条件后会触发Full GC，此时Full GC会收集整个GC堆，会先进行young GC（即使用年轻代的垃圾收集算法去收集年轻代的垃圾），然后使用老年代算法去收集老年代和方法区。</strong></p>
<p>​    <strong>这里还有个值得注意的地方，当要进行一次young GC时，如果发现统计数据说之前young GC的<font color="blue">平均晋升大小比目前old gen剩余的空间大</font>，则不会进行young GC，而是会采用老年代的垃圾收集算法对<font color="red">整个堆</font>进行垃圾收集（除了CMS）</strong></p>
<p>​    为什么说除了CMS呢，因为CMS垃圾收集器不能收集年轻代的垃圾。而且CMS有预设占用率会触发老年代的垃圾收集，所以CMS一般不会发生Full GC，但是当CMS发生concurrent mode failure的时候是会退化到发生Full GC，这个时候会变成使用备选的Serial Old收集器来对老年代进行垃圾收集（也有可能对整个堆进行垃圾收集哦，也就是发生上面一段话所说的情况）</p>
<h4 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h4><p>​    分配担保机制指的是：<font color="red">在MinorGC后新生代还有大量的对象存活，并且Survivor区不能存放所有的存活对象的情况下，会将无法容纳的对象直接晋升到老年代中</font></p>
<p>​    分配担保机制触发是在<u><strong>老年代中的内存还有能容纳晋升上来的对象的空间</strong></u>，而且在最坏的情况下是整个Eden区的对象都是存活的，所以在发生MinorGC之前，虚拟机都会先检查老年代的最大可用的连续内存空间是否大于新生代所有对象的总和，如果条件成立，那么可以直接进行MinorGC。</p>
<p>​    否则会根据是否设置了担保失败机制来选择下一步</p>
<ul>
<li><p>如果允许出现担保失败，则继续检查老年代中的最大可用连续内存空间<font color="blue">是否大于之前每次垃圾回收晋升到老年代对象容量的平均值大小</font>，如果大于则进行MinorGC，否则会进行Full GC来让老年代腾出更大的内存空间；比较平均值是一种动态手段，这种情况下如果出现上面最坏的情况，存活的对象远远高于平均值，是会出现担保失败的情况的（Handle Promotion Failure）；出现这种情况，会重新的进行一次Full GC去腾出更多空间。</p>
<blockquote>
<p>-XX:+HandlePromotionFailure    允许担保失败</p>
<p>-XX:-HandlePromotionFailure    不允许担保失败</p>
</blockquote>
</li>
<li><p>如果不允许出现担保失败，则直接进行Full GC腾出空间。</p>
</li>
</ul>
<p>注：推荐允许担保失败，因为这样能够避免频繁的Full GC    </p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>三种常用的垃圾收集算法的思想：</p>
<ol>
<li><p>标记清除算法</p>
<ul>
<li>首先标记出需要进行回收的对象，然后统一回收这些被标记的对象</li>
<li>这个算法回收完对象之后会产生大量的不连续的内存空间，这些内存碎片容易导致在后续分配大对象的时候无法找到足够的连续的内存空间</li>
</ul>
</li>
<li><p>标记复制算法</p>
<ul>
<li>这里以年轻代为例子说明：将内存划分为一个<strong>Eden区</strong>和两个<strong>Survivor区</strong>，每次使用Eden区和其中一个Survivor区（为了内存利用率），当回收垃圾的时候，将Eden区和Survivor区存活的对象复制到另外一块Survivor区中，然后再将Eden区和用过的Survivor区的内存空间清理掉</li>
<li>虚拟机会给对象定义一个对象年龄的计数器，当对象复制到Survivor区的时候，对象的年龄增加1，当达到一定程度的时候会晋升到老年代中</li>
<li>当复制过去的对象在Survivor区中不够大小存放的时候（内存不足），此时会触发<strong>分配担保机制</strong>，直接将这些对象晋升到老年代中</li>
</ul>
<p><img src="/2019/04/14/JVM垃圾收集/From-To1.png" alt="MinorGC Start"></p>
<p><img src="/2019/04/14/JVM垃圾收集/From-To2.png" alt="MinorGC After"></p>
</li>
<li><p>标记整理算法（标记 -&gt; 清除 -&gt; 压缩）</p>
<ul>
<li>这个算法跟标记清除算法差不多一样，只是当回收完被标记的对象后，会对内存空间进行压缩，将所有活的对象移到一边，然后会剩下一大片连续的内存空间，当产生新的对象时就很容易进行内存分配了</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>在了解垃圾收集器之前需要先认识几个概念</p>
<ul>
<li><p><strong>并行</strong>：多个垃圾回收线程同时工作，此时用户线程处于等待状态。</p>
</li>
<li><p><strong>并发</strong>：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起。</p>
</li>
<li><p><strong>Stop-the-world</strong>：在垃圾收集时，需要将应用程序完全挂起的事件称为stop-the-world。</p>
<blockquote>
<p>​    这是因为GC需要在垃圾收集前分析堆中对象的引用关系并且保存准确性所导致的结果（如果不停顿应用线程的执行，那么会导致在分析过程中还会出现引用关系变化的情况，从而会让可达性算法分析的结果变得更加复杂和不准确）。</p>
<p>​    应用stop-the-world的垃圾收集器会简单很多，应为在应用程序停顿的时候，堆内存空间是不会发生变化了，此时就能够准确的标记无用的对象。但是在web应用环境下，它挂起应用线程的时间是不能被接受的。</p>
</blockquote>
</li>
<li><p><strong>吞吐量</strong>：应用程序执行时间   / （应用程序执行时间 + 垃圾收集时间）</p>
</li>
</ul>
<h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p>​    年轻代和老年代都使用单线程的方式来进行垃圾收集（在多核CPU下也只会使用一个CPU进行垃圾收集），收集过程需要stop-the-world。</p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>​    用于年轻代的垃圾收集，主要采用了标记复制算法。</p>
<h5 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h5><p>​    用于老年代的垃圾收集，主要采用了标记整理算法（标记 -&gt; 清除 -&gt; 压缩算法）</p>
<h5 id="串行垃圾收集的优点"><a href="#串行垃圾收集的优点" class="headerlink" title="串行垃圾收集的优点"></a>串行垃圾收集的优点</h5><ul>
<li>简单高效</li>
<li>对于单个CPU的环境下，串行收集器没有线程间交互的时间开销</li>
<li>适用于运行在client模式下的程序</li>
</ul>
<p>可以使用<code>-XX:+UseSerialGC</code>来使用Serial + SerialOld的组合进行垃圾收集</p>
<h4 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h4><p>​    并行垃圾收集器利用多核的优势，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行的收集器仍然会stop-the-world，只不过使用多核的优势并行执行，降低停顿的时间；同时降低垃圾收集的时间，从而提高吞吐量。</p>
<p>​    并行垃圾收集器能够通过 <code>–XX:ParallelGCThreads=n</code>来控制垃圾收集线程的个数，<strong>合理利用CPU的资源能够有效的降低垃圾收集的停顿时间</strong>，但是上面说过了串行收集器在单CPU环境下是没有线程间交互的开销的，所以在单CPU的环境下，可能效率会比串行收集器更低。</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>​    多线程版本的Serial收集器，它能够配合CMS收集器一起工作（CMS是老年代的收集器；因为是Serial的多线程版本，所以Serial收集器也能和CMS收集器配合工作）。和Serial一样采用标记复制算法，不过是并行的复制算法，需要stop-the-world。</p>
<p>​    可以用<code>-XX:+UseConcMarkSweepGC</code>来使用CMS + ParNew组合的垃圾收集器（这里会有个情况，当CMS出现concurrent mode failure的时候会使用Serial Old收集器来手机老年代的对象）；还可以用<code>-XX:+UseParNewGC</code>来使用Serial Old + ParNew的组合进行内存回收。</p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>​    吞吐量收集器，可以这样形容这个收集器。显而易见，这是能够控制吞吐量的垃圾收集器，同样的也是采用复制算法（需要stop-the-world）。此收集器提供了两个参数来控制吞吐量（控制GC的停顿时间），分别是：<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>（<strong>MaxGCPauseMillis</strong>优先度更高）</p>
<ol>
<li><p>MaxGCPauseMillis是设置最大的垃圾收集停顿时间</p>
<ul>
<li>过分的降低停顿时间的话（设置停顿时间很短的情况下），是会降低整体的吞吐量的。因为设置了很低的停顿时间，可能会使得虚拟机对新生代的空间进行调整（调整Eden和Survivor区的比例），当Eden区的空间变小了，会导致更频繁的进行垃圾收集。垃圾收集的停顿时间确实会因为Eden区变小从而降低了，但是更频繁的垃圾收集也会导致整体吞吐量降低。</li>
</ul>
</li>
<li><p>GCTimeRatio是用来设置吞吐量的。此参数的值是：垃圾收集时间与应用程序运行时间的比值；例如</p>
<ul>
<li><p><code>-XX:GCTimeRatio=99</code> (同时也是默认值)此时相当于 垃圾收集时间:程序运行时间=1:99，则吞吐量=1/(1+99)=1% </p>
<blockquote>
<p>个人观点（勿喷）：周志明老师JVM书上的描述有点不对，书中描述GCTimeRatio设置的值是吞吐量的倒数，比如默认值99，如果是吞吐量的倒数的话，那么吞吐量就是1/99了，这样看来是不对的。所以我认为描述为吞吐量倒数应该是不正确的。应该是垃圾收集时间与应用程序运行时间的比值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当我们能够通过设置上面两个参数来控制吞吐量，但是不知道什么样的情况下是最好的（即不知道该如何设置年轻代内存大小和各个区之间的比值等）；这种情况下可以使用 <code>-XX:+UseAdaptiveSizePolicy</code> 来动态的调整虚拟机相关细节参数来达到设置好的停顿时间或者吞吐量，这中调节方式被称为GC自适应调节策略（建议使用该收集器时开启这个参数）</p>
</li>
</ol>
<p>可以使用<code>-XX:+UseParallelOldGC</code>来使用Parallel Scavenge + Parallel Old的组合回收内存</p>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>​    Parallel Old是Parallel Scavenge的老年代版本。采用的是并行标记整理算法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/高并发场景下的优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/高并发场景下的优化/" itemprop="url">高并发场景下的优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T16:58:05+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    当应用在面临高并发访问的情况下，一般的web项目很容易会出现请求处理不过来和性能瓶颈的问题，同时数据库的压力也会变得很大；尤其是单机处理的能力极其有限。那么在这种情况下就需要考虑相关的解决方案去提升应用的并发处理能力了。</p>
<h2 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h2><p>​    关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。</p>
<p>​    数据库分布式核心内容无非就是<strong>数据切分</strong>（Sharding），以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。</p>
<h3 id="数据切分（分库分表）"><a href="#数据切分（分库分表）" class="headerlink" title="数据切分（分库分表）"></a>数据切分（分库分表）</h3><p>​    数据切分指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。数据的切分同时还可以提高系统的总体可用性，因为单台设备Crash之后，只有总体数据的某部分不可用，而不是所有的数据。</p>
<p>数据切分根据其切分类型，可以分为两种方式：</p>
<ul>
<li>按照<font color="red"><strong>不同的表</strong>（或者Schema）来切分到<strong>不同的数据库</strong></font>（主机）之上，这种切可以称之为数据的垂直（纵向）切分</li>
<li>根据表中的数据的逻辑关系，将<font color="red"><strong>同一个表</strong>中的数据按照某种条件拆分到多台数据库</font>（主机）上面，这种切分称之为数据的水平（横向）切分</li>
</ul>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>​    根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库（即根据功能模块来进行数据的切分，不同功能模块的数据存放于不同的数据库主机中）</p>
<h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><p>​    对于单表的垂直切分是基于数据库中的<strong>“列”</strong>进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p>
<p>​    在字段很多的情况下（例如一个大表有100多个字段），通过<strong>“大表拆小表”</strong>，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。</p>
<p>​    另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能</p>
<h4 id="垂直切分的优缺点"><a href="#垂直切分的优缺点" class="headerlink" title="垂直切分的优缺点"></a>垂直切分的优缺点</h4><ul>
<li>优点<ol>
<li>解决业务系统层面的耦合，业务清晰</li>
<li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li>
</ol>
</li>
<li>缺点<ol>
<li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li>
<li>分布式事务处理复杂</li>
<li>依然存在单表数据量过大的问题（需要水平切分）</li>
</ol>
</li>
</ul>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>​    水平切分是根据表内数据内在的逻辑关系，按照某种规则<font color="blue"><em>（如根据某个数字类型字段基于特定数目取模，某个时间类型字段的范围，或者是某个字符类型字段的hash值，或者用户表的地区等等）</em></font>将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</p>
<p>​    当一个应用难以再细粒度的垂直切分，或<strong>切分后数据量行数巨大，存在单库读写、存储性能瓶颈</strong>，这时候就需要进行水平切分了。</p>
<h4 id="水平切分优缺点"><a href="#水平切分优缺点" class="headerlink" title="水平切分优缺点"></a>水平切分优缺点</h4><ul>
<li>优点<ol>
<li>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li>
<li>应用端改造较小，不需要拆分业务模块</li>
</ol>
</li>
<li>缺点<ol>
<li>跨分片的事务一致性难以保证</li>
<li>跨库的join关联查询性能较差</li>
<li>数据多次扩展难度和维护量极大</li>
</ol>
</li>
</ul>
<h4 id="经典的水平切分规则"><a href="#经典的水平切分规则" class="headerlink" title="经典的水平切分规则"></a>经典的水平切分规则</h4><ul>
<li><p>根据数值范围：按照时间区间或ID区间来切分</p>
<blockquote>
<p>这样的优点在于：</p>
<ul>
<li>单表大小可控</li>
<li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</li>
<li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，很少被查询</li>
</ul>
</blockquote>
</li>
<li><p>根据数值取模：一般采用hash取模mod的切分方式</p>
<blockquote>
<p>优点：</p>
<ul>
<li>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</li>
</ul>
<p>缺点：</p>
<ul>
<li>后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）</li>
<li>容易面临跨分片查询的复杂问题（如果查询时无法定位表，那么需要同时对多个数据库表进行查询再合并数据，会拖累数据库）</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="分库分表带来的问题及其解决办法"><a href="#分库分表带来的问题及其解决办法" class="headerlink" title="分库分表带来的问题及其解决办法"></a>分库分表带来的问题及其解决办法</h3><p>​    分库分表能有效的环节单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题：</p>
<ol>
<li><p>事务一致性问题</p>
<ul>
<li>分布式事务：当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务。分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁</li>
<li>最终一致性：对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的<strong>实时一致性</strong>，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等</li>
</ul>
</li>
<li><p>跨节点关联查询 join 问题</p>
<blockquote>
<p>切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询</p>
<p>对于该问题的解决方案：</p>
<ul>
<li>全局表，将所有模块依赖的一些表在每个数据库中都保存一份</li>
<li>增加冗余字段，利用空间换时间，为了性能而避免join查询。例如：订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询User表了</li>
<li>通过应用程序分多次查询，再将得到的数据组装合并</li>
</ul>
</blockquote>
</li>
<li><p>跨节点分页、排序、函数问题</p>
<blockquote>
<p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。</p>
<p>分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户</p>
</blockquote>
</li>
<li><p>全局主键避重问题</p>
<blockquote>
<p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的<strong>ID无法保证全局唯一</strong>。因此需要单独设计全局主键，以避免跨库主键重复问题。（可用UUID或者分布式的全局ID生成器(如推特的Snowflake)）</p>
</blockquote>
</li>
<li><p>数据迁移、扩容问题</p>
<blockquote>
<p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。此外还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W）</p>
<p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦</p>
</blockquote>
</li>
</ol>
<h3 id="什么时候需要分库分表"><a href="#什么时候需要分库分表" class="headerlink" title="什么时候需要分库分表"></a>什么时候需要分库分表</h3><ul>
<li>能不切分尽量不要切分</li>
<li>数据量过大，正常运维影响业务访问</li>
<li>随着业务发展，需要对某些字段垂直拆分</li>
<li>数据量快速增长</li>
<li>安全性和可用性：在业务层面上垂直切分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。利用水平切分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高</li>
</ul>
<h3 id="垂直切分和水平切分的联合使用"><a href="#垂直切分和水平切分的联合使用" class="headerlink" title="垂直切分和水平切分的联合使用"></a>垂直切分和水平切分的联合使用</h3><p>​    一个应用系统的负载都是在慢慢的增长的，当系统开始遇到性能瓶颈的时候。大多数情况下会先选择对数据库进行垂直切分，因为这样的成本最先，最符合这个时期所追求的最大投入产出比。    </p>
<p>​    但是随着业务的不断扩张，系统负载的持续增长，在系统稳定一段时期之后，经过了垂直拆分之后的数据库集群可能会再一次不堪重负，遇到了性能瓶颈。如果再选择对系统数据库进行垂直切分的话，会随着时间又再次面临同样的问题。这个时候就需要通过水平切分的优势来解决这个问题了，而且完全可以在垂直切分后的基础上进行水平切分。</p>
<h2 id="数据库扩容"><a href="#数据库扩容" class="headerlink" title="数据库扩容"></a>数据库扩容</h2><p>​    随着时间的推进和业务的发展，系统的数据量会不停的增长，无论是数据库的容量，还是单库单表的数据量也总会到达天花板，此时该如何扩展我们的数据库性能？</p>
<ul>
<li><p>水平扩容</p>
<blockquote>
<ol>
<li><font color="red">增加服务器数量</font>，就能线性扩充系统性能</li>
<li>但是增加过多的服务器会增加网络、数据库IO开销、管理多个服务器的难度</li>
</ol>
</blockquote>
</li>
<li><p>垂直扩容：提升单机处理能力</p>
<blockquote>
<ol>
<li>增强单机硬件性能（升级CPU,SSD固态硬盘等）</li>
<li>提升单机架构性能（使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间）</li>
<li>但是这样会增大单个服务中其他软件设施的依赖与管理、服务内部复杂度</li>
</ol>
</blockquote>
</li>
</ul>
<p>​        对数据库的扩容不管是垂直还是水平扩容都会有优缺点，这就需要根据实际的业务需求来选择了更加合适的解决方案了：</p>
<ul>
<li><font color="blue">读操作扩展</font>：假如网站是<strong>读操作</strong>比较多，比如博客网站。通过对数据库进行垂直扩容并且结合redis、CDN等构建一个健壮的缓存系统是个不错的选择。如果系统超负荷运行，将更多的数据放在缓存中来缓解系统的读压力。采用水平扩容没有太大的意义，因为性能的瓶颈不在写操作，所以不需要实时去完成，用更多的服务器来分担压力性价比太低。</li>
<li><font color="blue">写操作扩展</font>：假如写操作比较多，比如大型网站的交易系统，可考虑水平扩展的数据存储方式，比如Cassandra、Hbase等。和大多数的关系型数据库不同，这种数据存储会随着数据量的增长从而增加更多的节点。也可以考虑垂直扩容提升单个数据库的性能，但会发现资金与硬盘的IO能力是有限的，所以需要增加更多数据库来分担写的压力</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>​    <strong>使用缓存可以减少数据库压力(I/O压力)与提高访问性能</strong></p>
<p>​    缓存通常适合<font color="red">读多写少</font>的业务场景，实时性要求越低越适合缓存（即数据在缓存中更新的次数越少越适合）</p>
<ol>
<li><p>缓存特征</p>
<ul>
<li><p>命中率：命中数 /（命中数 + 没有命中数），命中率越高产生收益也就越高，性能也就越好，相应的也就越短，吞吐量也就越高，抗并发的能力也就越强</p>
</li>
<li><p>最大元素（空间）：缓存中存放的最大元素的数量，当缓存的数量超过了缓存空间，则会触发缓存清空策略</p>
</li>
<li><p>清空策略：</p>
<blockquote>
<p>一旦缓存中元素数量最大元素或者缓存数据所占空间超过其最大支持空间，那么将会触发缓存清空策略，根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存</p>
</blockquote>
<ul>
<li>FIFO先进先出策略，先进入的优先清除</li>
<li>LFU（Least Frequently Used，根据数据的历史访问频率来淘汰数据，对比命中数；其核心思想是<strong>“如果数据过去被访问多次，那么将来被访问的频率也更高”</strong>）</li>
<li>LRU（Least recently used，最近最少使用策略；其核心思想是<strong>“如果数据最近被访问过，那么将来被访问的几率也更高”</strong>）</li>
<li>过期时间（根据元素设置的过期时间来清除缓存）</li>
<li>随机清除</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存分类</p>
<ul>
<li>本地缓存：Java中的本地缓存是存在当前应用进程内部的，没有过多的网络开销。在集群节点之间不需要互相通知的情况下使用较为合适</li>
<li>分布式缓存：应用分离的缓存服务，其自身就是一个独立的应用，与本地应用是隔离的，多个应用之间共享缓存</li>
</ul>
</li>
<li><p>高并发场景下缓存常见问题</p>
<ul>
<li><p>缓存一致性</p>
<blockquote>
<p>当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存</p>
</blockquote>
</li>
<li><p>缓存并发</p>
<blockquote>
<p>在高并发场景下，多个请求并发的去从数据库获取数据，会对后端数据库造成极大的冲击，甚至导致 “雪崩”现象。当某个缓存key在被更新时，同时也可能被大量请求在获取，这也会导致缓存一致性的问题。</p>
<p>那如何解决类似问题呢？在缓存更新或者过期的情况下，先尝试获取到锁（分布式锁），当更新或者从数据库获取完成后再释放锁，其他的请求只需要牺牲一定的等待时间，即可直接从缓存中继续获取数据</p>
</blockquote>
</li>
<li><p>缓存穿透</p>
<blockquote>
<p>在高并发场景下，如果某一个key被高并发访问，没有被命中，出于对容错性考虑，会尝试去从后端数据库中获取，从而导致了大量请求达到数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的去执行了很多不必要的查询操作，从而导致数据库的压力增大。</p>
<p>那如何解决类似问题呢？</p>
<ul>
<li>缓存空对象；对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非null），如果是缓存单个对象，可以通过字段标识来区分。这样避免请求穿透到后端数据库。同时，也需要保证缓存数据的时效性。这种方式实现起来成本较低，比较适合命中不高，但<strong>可能被频繁更新的数据</strong></li>
<li>单独过滤处理；对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂，比较适合命中不高，但是<strong>更新不频繁的数据</strong></li>
</ul>
</blockquote>
</li>
<li><p>缓存雪崩</p>
<blockquote>
<p>缓存雪崩就是指由于缓存没有命中的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。“缓存并发”，“缓存穿透”等问题，都可能会导致缓存雪崩现象发生，这些问题可能会被恶意攻击者所利用。</p>
<p>还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效</p>
<p>从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难</p>
</blockquote>
</li>
</ul>
</li>
<li><p>缓存介质</p>
<ul>
<li><strong>内存</strong>：将缓存存储于内存中是最快的选择，无需额外的I/O开销，但是内存的缺点是存储的数据没有持久化，一旦应用异常或者宕机，数据很难或者无法复原</li>
<li><strong>硬盘</strong>：很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的</li>
</ul>
</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>​    消息队列已经逐渐成为<strong>系统内部通信的核心手段和异步RPC</strong>的主要手段。</p>
<p>​    它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能</p>
<ol>
<li><p>消息队列的特性</p>
<ul>
<li>业务无关：只做消息的分发</li>
<li>FIFO：先进入队列的先到达</li>
<li>容灾：节点的动态增删和消息的持久化</li>
<li>性能：吞吐量提升，系统内部通信效率提高</li>
</ul>
</li>
<li><p>使用消息队列的好处</p>
<ul>
<li><p><strong>异步解耦</strong></p>
<blockquote>
<p>使用消息队列，可以异步处理请求，从而缓解系统的压力</p>
<p>例如：短信发送时只要保证放到消息队列中就可以接着做后面的事情。一个事务只关心本质的流程，需要依赖其他事情但是不那么重要的时候，有通知即可，无需等待结果</p>
</blockquote>
</li>
<li><p><strong>保证最终一致性</strong></p>
<blockquote>
<p>最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的</p>
</blockquote>
</li>
<li><p><strong>错峰与流控</strong></p>
<blockquote>
<p>上下游对于事情的处理是不同的，比如WEB前端每秒承受上千万的请求都是可以的但是数据库的处理却非常有限；迫于成本的压力我们不能要求数据库的机器数量与前端资源一样；这样的问题同样存在于系统与系统之间,比如短信系统的速度卡在网关上边它与前端的并发量不是一个数量级的，用户玩几秒种收到短信也是可以的；针对于这样的场景如果没有消息队列也能实现但是系统的复杂度非常的高</p>
</blockquote>
</li>
<li><p><strong>广播</strong> </p>
<blockquote>
<p>如果没有消息队列每一个新的业务方介入都需要联调一次接口，使用消息队列只需要关心消息是否送达到消息队列，新接入的接口订阅相关的消息自己做处理就可以了</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="应用拆分"><a href="#应用拆分" class="headerlink" title="应用拆分"></a>应用拆分</h2><ol>
<li><p>拆分的原则</p>
<ul>
<li>业务优先：每个系统都会有多个模块，每个模块又有多个业务功能；按照业务边界进行切割，再对模块进行拆分</li>
<li>循序渐进：边拆分边测试，保证系统的正常运行</li>
<li>兼顾技术：重构、分层（不能为了分布式而分布式，拆分过程不仅是业务梳理也是代码重构的过程，根据技术进行分层来分配工作）</li>
<li>可靠测试：测试完毕后，才可进行下一步，每一步都要有足够的测试才可进行下一步，避免小错误引起蝴蝶效应</li>
</ul>
</li>
<li><p>应用拆分时设计和选择</p>
<ul>
<li><p>应用之间通信：RPC 、消息队列、API（基于RESTFul风格的接口原则）</p>
<blockquote>
<p>消息队列通常用于传输数据包小但是数据量大，对实时性要求低的场景。而采用RPC要求实时性高</p>
</blockquote>
</li>
<li><p>应用之间数据库设计：每个应用都有独立的数据库</p>
<blockquote>
<p>通常情况下，每个应用都有自己独立的数据库，如果共同使用的信息，可以考虑放在common中使用</p>
</blockquote>
</li>
<li><p>避免事务操作跨应用；分布式事务是一个很消耗资源的问题，应用之间服务分开开发，能够保持相互独立</p>
</li>
</ul>
</li>
</ol>
<h2 id="应用限流"><a href="#应用限流" class="headerlink" title="应用限流"></a>应用限流</h2><p>​    每个API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。即接口也需要安装上保险丝，以防止非预期的请求对系统压力过大而引起的系统瘫痪。首先先了解一下一些衡量服务器指标的概念：</p>
<ul>
<li>QPS：对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准（每秒查询率）<ul>
<li>QPS = 并发量 / 平均响应时间</li>
<li>通常QPS用来表达和衡量当前系统的负载</li>
<li>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力</li>
</ul>
</li>
<li>响应时间（RT）：响应时间是指系统对请求作出响应的时间<ul>
<li>它完整地记录了整个计算机系统处理请求的时间</li>
<li>响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度</li>
</ul>
</li>
<li>吞吐量（TPS）：系统在单位时间内处理请求的数量<ul>
<li>对于没有并发的系统而言，吞吐量就是响应时间的倒数</li>
<li>通常用吞吐量作为并发系统的性能指标</li>
<li>对于一个有并发的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致</li>
</ul>
</li>
<li>并发量：系统可以同时承载的正常使用系统功能的用户的数量<ul>
<li>对于网站系统一般会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数</li>
</ul>
</li>
</ul>
<p>​    限流就是通过对并发访问/请求进行限速或一个时间窗口内的请求进行限速，从而达到保护系统的目的。一般系统可以通过压测来<strong>预估能处理的峰值</strong>，一旦达到设定的峰值阀值，则可以：</p>
<ul>
<li>拒绝服务（定向错误页或告知资源没有了）</li>
<li>排队或等待（例如：秒杀、评论、下单）</li>
<li>降级（返回默认数据）</li>
</ul>
<p>限流常用算法：</p>
<ol>
<li><p>计数器法</p>
<blockquote>
<p>​    该算法主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流</p>
<p>​    这个方法有一个致命问题：临界问题——当遇到恶意请求，比如设定的阈值是1分钟内100次请求，在59秒时，瞬间请求100次，并且在60秒时请求100次，那么这个用户在1秒内请求了200次，用户可以在重置节点（就是重置计数器的值）时突发请求，而瞬间超过我们设置的速率限制，用户可能通过算法漏洞击垮我们的应用</p>
</blockquote>
</li>
<li><p>滑动窗口算法</p>
<blockquote>
<p>​    滑动窗口算法类似将上面计数器法的1s时间拆分成若干个小窗口（此例拆分成4个窗口），每个窗口对应250ms；假设用户利用上一秒最后一刻和下一秒第一刻发起瞬间的高并发请求；此时会统计前一秒中的最后750ms和下一秒的前250ms，这样能够判断出用户的访问依旧超过了1s的访问数量，因此依然会阻拦用户的访问</p>
</blockquote>
</li>
<li><p>漏桶算法</p>
<blockquote>
<p>​    水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水（请求）流入速度过大会直接溢出（访问频率超过接口响应速率），然后就拒绝请求（丢弃溢出的数据包）；可以看出<strong>漏桶算法能强行限制数据的传输速率</strong>。</p>
<p>​    因为漏桶的漏出速率是固定的，所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使流突发（burst）到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率</p>
</blockquote>
<p><img src="/2019/03/02/高并发场景下的优化/./高并发场景下的优化/LeakyBucket.jpg" alt="漏桶算法示意图"></p>
</li>
<li><p>令牌桶算法</p>
<blockquote>
<p>​    随着时间流逝，系统会按恒定1/QPS时间间隔（单位是ms）往桶里加入Token（想象和漏洞漏水相反，有个水龙头在不断的加水）；如果桶已经满了就不再加了，新请求来临时会拿走一个Token，如果没有Token可拿了就阻塞（可以加入等待队列）或者拒绝服务。</p>
<p>​    <strong>令牌桶的好处是可以方便的改变速度</strong>：一旦需要提高速率（应对突发传输），则按需提高放入桶中的令牌的速率.。一般会定时（比如100毫秒）往桶中增加一定数量的令牌,，有些变种算法则实时的计算应该增加的令牌的数量</p>
</blockquote>
</li>
</ol>
<h2 id="服务降级与服务熔断"><a href="#服务降级与服务熔断" class="headerlink" title="服务降级与服务熔断"></a>服务降级与服务熔断</h2><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>​    服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。同时保证大部分请求，客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个<strong>默认</strong>的返回</p>
<h4 id="降级分类"><a href="#降级分类" class="headerlink" title="降级分类"></a>降级分类</h4><ol>
<li>降级按照是否自动化可分为：</li>
</ol>
<ul>
<li><font color="green"><strong>自动降级</strong></font>

<ul>
<li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li>
<li>失败次数降级：主要是一些不稳定的API，当<strong>失败调用次数</strong>达到一定阀值自动降级，同样要使用异步机制探测回复情况</li>
<li><font color="red">故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、RPC服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</font></li>
<li><font color="red">限流降级</font>：当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行<strong>限制访问量，当达到限流阀值，后续请求会被降级</strong>；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）</li>
</ul>
</li>
<li><p>人工降级</p>
<blockquote>
<p>在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：服务器挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；此时就可以使用开关来完成降级</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>降级按照功能可分为：</p>
<ul>
<li><p>读服务降级：对于读服务降级一般采用的策略有：暂时切换读（降级到读缓存、降级到走静态化）、暂时屏蔽读（屏蔽读入口、屏蔽某个读服务）</p>
<blockquote>
<p>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景</p>
</blockquote>
</li>
<li><p>写服务降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache</p>
</li>
</ul>
</li>
<li><p>降级按照处于的系统层次可分为：</p>
<ul>
<li>多级降级：缓存是离用户最近越高效；而降级是<strong>离用户越近</strong>越能对系统保护的好。因为业务的复杂性导致越到后端QPS/TPS越低</li>
</ul>
</li>
</ol>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>​    服务熔断一般是指软件系统中，由于某些原因使得服务出现了<strong>过载现象</strong>，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护</p>
<h3 id="服务熔断和服务降级比较"><a href="#服务熔断和服务降级比较" class="headerlink" title="服务熔断和服务降级比较"></a>服务熔断和服务降级比较</h3><ul>
<li>相似点：<ol>
<li>目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段</li>
<li>最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用</li>
<li>粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）</li>
<li>自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段</li>
</ol>
</li>
<li>不同点：<ol>
<li>触发原因不太一样，<strong>服务熔断一般是某个服务（下游服务）故障引起</strong>，而<strong>服务降级一般是从整体负荷考虑</strong></li>
<li>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li>
<li>实现方式不太一样</li>
</ol>
</li>
</ul>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>​    Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包（<code>request collapsing</code>，即自动批处理），以及监控和配置等功能</p>
<h4 id="Hystrix能做什么"><a href="#Hystrix能做什么" class="headerlink" title="Hystrix能做什么"></a>Hystrix能做什么</h4><ul>
<li>在通过第三方客户端访问依赖服务出现高延迟或者失败时，为系统提供保护和控制</li>
<li>在分布式系统中防止级联失败</li>
<li>快速失败（Fail fast）同时能快速恢复</li>
<li>提供失败回退（Fallback）和优雅的服务降级机制</li>
<li>提供近实时的监控、报警和运维控制手段</li>
</ul>
<h4 id="Hystrix设计原则"><a href="#Hystrix设计原则" class="headerlink" title="Hystrix设计原则"></a>Hystrix设计原则</h4><ul>
<li>防止单个依赖耗尽容器（例如 Tomcat）内所有用户线程</li>
<li>降低系统负载，对无法及时处理的请求快速失败（Fail fast）而不是排队</li>
<li>提供失败回退（Fallback），以在必要时让失效对用户透明化</li>
<li>使用隔离机制（例如熔断器模式等）降低依赖服务对整个系统的影响</li>
<li>针对系统服务的度量、监控和报警，提供优化以满足近实时性的要求</li>
<li>在绝大部分需要动态调整配置并快速部署到所有应用方面，提供优化以满足快速恢复的要求</li>
<li>能保护应用不受依赖服务的整个执行过程中失败的影响，而不仅仅是网络请求</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/19/JVM内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/19/JVM内存模型/" itemprop="url">JVM内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-19T23:16:10+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程共享内存区域"><a href="#线程共享内存区域" class="headerlink" title="线程共享内存区域"></a>线程共享内存区域</h1><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>​    此内存区域在虚拟机启动的时候创建，几乎所有对象的实例和数组都在堆中分配内存空间。    </p>
<p>​    Java堆是垃圾回收主要的管理区域，而且现在的垃圾收集器基本都采用分代收集算法（这是针对不同分代的特点采用适当的收集算法，提高垃圾收集的效率），所以一般为了在内存方面出发，堆可以分为老年代和新生代。</p>
<blockquote>
<p>新生代中，也可以细分为Eden空间，To Survivor空间和From Survivor空间等。(垃圾收集和对象内存分配在垃圾收集再详细分析)</p>
<ul>
<li>这里分为这样的空间是因为采用了标记复制的垃圾收集算法，但是基本的标记复制算法是采用1:1的方式划分空间，这样的话会浪费掉很多内存空间的使用，所以分成了两个Survivor区和一个Eden区（默认1:1:8）</li>
<li>当Eden区被占满或者Eden区没有办法为新对象分配足够的内存空间时，会触发垃圾回收；垃圾收集后存活的对象会被<strong>复制</strong>到From区，当From区满的时候会将存活的对象<strong>复制</strong>到To区域（此时包括来自Eden区存活的对象），然后这两个区域会交换角色。注意：<font color="blue">Survivor区总是有一个是空的</font>，Survivor-From 区的对象分两类，一类是年轻的对象（分代年龄小），也是复制到 Survivor-To 区，还有一类是老东西，晋升到老年代中。（参考下面两张图片，来源：《<a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="noopener">Memory Management in the Java HotSpot Virtual Machine</a>》）</li>
<li>上面说的会将存活对象复制到To区域说得不全面，因为有可能To区域的内存会被占满，然后还有其他存活的对象就没有办法放入到To区中，那么这里就涉及<strong>分配担保机制</strong>了，也就是Survivor区域的空间不够用的时候，这些存活对象会直接通过这个机制进入到老年代中</li>
<li>虚拟机会给每个对象定义一个对象年龄的计数器，当年轻代的对象经过MinorGC开始复制到Survivor区的时候，对象的年龄会增加1，当对象年龄达到一定程度或者触发分配担保机制的时候会晋升到老年代当中</li>
</ul>
</blockquote>
<p><img src="/2019/01/19/JVM内存模型/./JVM内存模型/From-To1.png" alt="年轻代垃圾收集前"></p>
<p><img src="/2019/01/19/JVM内存模型/./JVM内存模型/From-To2.png" alt="年轻代垃圾收集后"></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>​    方法区主要用于存储被虚拟机加载的类信息（Class相关信息：类名，访问修饰符，字段描述，方法描述等），常量，静态变量，即时编译器编译后的代码等数据。</p>
<p>​    方法区通常被我们称作：永久代。但是这只是HotSpot VM对方法区的实现而已；在其他的VM（JRockit等）并没有永久代。</p>
<p>​    注意的是，在JDK1.8中，永久代已经被移除（JDK1.7中，永久代中的运行时常量池被移到堆中），此时HotSpot VM对方法区的实现变成了元空间<code>Metaspace</code> ，元空间和永久代的本质是类似的，<font color="red">不同的地方是元空间并不在虚拟机中，而是使用本地内存（Native Memory）</font>。</p>
<blockquote>
<p>在方法区中，对于很多动态生成类的情况容易出现OutOfMemoryError的异常。</p>
<p>常见的场景就是JSP页面较多的情况（JSP第一次运行需要进行编译）、CGLib增强和动态语言（<em>Groovy</em>）</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​    运行时常量池是属于方法区的一部分（JDK7后被移到堆中）。其用于存储<strong>编译期</strong>生成的字面量和符号引用。</p>
<blockquote>
<p>程序运行期间可以通过<code>String.intern()</code> 将变量放入运行时常量池中</p>
</blockquote>
<h1 id="线程私有的内存区域"><a href="#线程私有的内存区域" class="headerlink" title="线程私有的内存区域"></a>线程私有的内存区域</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是当前线程执行的代码的<strong>行号指示器</strong></p>
<ul>
<li>当执行Native方法的时候，该计数器值是空的(<code>undefined</code>)</li>
<li>该内存区域是<font color="red">唯一一个</font>没有规定<code>OutOfMemoryError</code> 情况的区域</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>​    Java虚拟机栈的生命周期与当前线程相同；虚拟机栈是Java方法执行时的内存模型，在方法执行时会创建栈帧存放局部变量表、操作数栈、动态链接和方法出口等信息。</p>
<p>​    在虚拟机栈中，我们平常主要关注的是局部变量表：</p>
<ol>
<li><p>局部变量表的内存空间在编译期间完成分配</p>
</li>
<li><p>局部变量表包括基本数据类型、指向字节码指令的地址和对象的引用（即<code>reference</code>）</p>
<ul>
<li><p>对象的引用主要有句柄和直接指针的两种方式：</p>
<ul>
<li><p>句柄：使用句柄的方式时，JVM会在Java堆中开辟一部分内存作为句柄池，虚拟机栈中的<code>reference</code>中储存的就是句柄的内存地址，句柄则包含了该对象的实例数据和类型数据的内存地址。</p>
<blockquote>
<p>类型数据：该类型数据是在方法区中的Class类信息和静态变量等数据</p>
</blockquote>
</li>
<li><p>直接指针：顾名思义就是虚拟机栈中的<code>reference</code>中储存的是该对象的实例数据和类型数据的内存地址。</p>
</li>
</ul>
</li>
<li><p>两种方式各有各的优劣势：</p>
<ul>
<li>句柄：其优势之处就是稳定，当垃圾收集器回收内存中的对象时，该对象要么存活在年轻代要么晋升到老年代，这个时候该对象的内存地址就会发生改变，此时虚拟机栈中<code>reference</code> 的指针就不需要发生改变，只需要改变句柄中对象的内存地址即可。</li>
<li>直接指针：直接指针访问对象的速度会比句柄快，因为它少了一次指针定位的开销。在大量的对象访问的时候，直接指针的效率是相当的客观。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>线程请求的栈深度大于虚拟机所允许的最大深度，会抛出<code>StackOverflowError</code>异常</p>
<blockquote>
<p>这里的意思是：Java方法的从执行到结束就相当于将一个栈帧在虚拟机栈中的入栈和出栈的过程；当一个死循环的递归方法调用时，就会抛出StackOverflowError；因为死循环的递归，会不断的往虚拟机栈中压入栈帧，当达到最大深度时，则抛出该异常。</p>
</blockquote>
<p>虚拟机在动态扩展时，无法为栈分配足够的内存空间时会抛出<code>OutOfMemoryError</code>异常</p>
<blockquote>
<p>这里有容易会和上面那个混淆，唯一需要分清的是当栈空间不够分配的时候：这种情况下是因为内存不足还是栈的深度不够的问题就能分清楚这两种情况了。</p>
</blockquote>
</blockquote>
<hr>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>​    本地方法栈跟Java虚拟机栈的作用基本上是相同的，不同之处是Java虚拟机栈服务的是Java方法，而本地方法栈服务的对象是Native方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/秒杀总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/秒杀总结/" itemprop="url">商品秒杀系统技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T11:00:20+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/商品秒杀/" itemprop="url" rel="index">
                    <span itemprop="name">商品秒杀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这篇总结基于M课网的秒杀API的课程基础上来写的</p>
<p>这个课程我个人觉得有很多值得学习的地方，包括接口实现的思路，编码规范等等。</p>
</blockquote>
<h1 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h1><p>​    在登录这块，注册实现比较简单；主要是对password经过两层的盐值加密，前端加密然后后端也对其进行一次加密后再存放到数据库中。</p>
<h2 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h2><p>​    这里主要对登录的验证沿用了拦截器来实现，主要的实现流程如下：</p>
<ol>
<li><p>用户登录验证通过后（用户名和密码验证通过），生成随机码，对随机码进行加密操作</p>
</li>
<li><p>将加密后的随机码作为key，value存放user的json串存放到redis中（当然，可以不必要存放所有的字段，存放一些后续操作所需要的字段即可，这边我直接将user存放到redis中），并对其设置过期时间</p>
</li>
<li><p>放入redis后将生成的加密随机码放入cookie中，下次用户请求过来会带上cookie过来进行身份验证</p>
</li>
<li><p>我这边身份验证放到的拦截器中，就是简单的根据cookie的value来获取redis中的缓存，能够获取到user的即为验证通过</p>
<blockquote>
<p>这里有个小注意：</p>
<blockquote>
<p>Spring Boot 2.0后用配置类继承WebMvcConfigurerAdapter时，会提示这个类已经过时了</p>
<blockquote>
<p>此时可以通过实现WebMvcConfigurer接口解决该问题</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<hr>
<h2 id="JSR-303数据效验"><a href="#JSR-303数据效验" class="headerlink" title="JSR-303数据效验"></a>JSR-303数据效验</h2><p>（详细介绍：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/）" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/）</a></p>
<ul>
<li>使用JSR-303可以实现自定义的数据校验，这里我使用这个规范来对手机号码参数进行校验（推荐前后端一起校验）</li>
<li>实现流程参考：<a href="https://blog.csdn.net/Adrian_Dai/article/details/83304599" target="_blank" rel="noopener">https://blog.csdn.net/Adrian_Dai/article/details/83304599</a></li>
</ul>
<h2 id="自定义参数解析器"><a href="#自定义参数解析器" class="headerlink" title="自定义参数解析器"></a>自定义参数解析器</h2><p>获取User对象可以实现了自定义参数解析器来为方法上的User参数进行解析，从cookie中获取到随机码，然后从redis中获取到User对象装填到方法的参数上。</p>
<ul>
<li><p>Springmvc的自定义参数解析器是当接口参数中有某个类的时候触发，此时可以从该参数解析器中返回我们所需要的内容</p>
</li>
<li><p>这里以User参数为例，自定义参数解析器实现<code>HandlerMethodArgumentResolver</code>接口，该接口下有两个方法</p>
<ul>
<li>supportsParameter：当进入方法的参数解析时会调用这个方法，当这个方法返回true 的时候会执行resolveArgument方法对参数进行解析</li>
</ul>
</li>
<li><p>注意，要记得将其加入到<code>List<handlermethodargumentresolver></handlermethodargumentresolver></code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	UserArgumentResolver userArgumentResolver;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">		argumentResolvers.add(userArgumentResolver);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="商品和订单模块"><a href="#商品和订单模块" class="headerlink" title="商品和订单模块"></a>商品和订单模块</h1><p>​    这里主要提及一下页面缓存、url缓存和对象缓存，如字面意思。来看下面的这段代码(<strong>注意阅读注释</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * thymeleaf的页面渲染</span></span><br><span class="line"><span class="comment"> * 注意点：因为在thymeleaf.spring5的API中把大部分的功能移到了IWebContext下面,用来区分边界。</span></span><br><span class="line"><span class="comment"> * 		  剔除了ApplicationContext 过多的依赖，现在thymeleaf渲染不再过多依赖spring容器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在spring4中的使用:</span></span><br><span class="line"><span class="comment"> * SpringWebContext ctx = new SpringWebContext(request,response,</span></span><br><span class="line"><span class="comment"> * 					request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );</span></span><br><span class="line"><span class="comment"> * String html = thymeleafViewResolver.getTemplateEngine().process("goods_list", ctx);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RequestMapping中produces属性设置返回数据的类型以及编码;必须与<span class="doctag">@ResponseBody</span>注解使用</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value=<span class="string">"/to_list"</span>, produces=<span class="string">"text/html"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">    	model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    	<span class="comment">//取缓存</span></span><br><span class="line">    	String html = redisService.get(GoodsKey.getGoodsList, <span class="string">""</span>, String.class);</span><br><span class="line">    	<span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">    		<span class="keyword">return</span> html;</span><br><span class="line">    	&#125;</span><br><span class="line">    	List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">    	model.addAttribute(<span class="string">"goodsList"</span>, goodsList);</span><br><span class="line"><span class="comment">// model 就是将参数存入 ，其中的所有参数 都是为了将页面渲染出来 放入其中，在返回一个静态的html源码</span></span><br><span class="line">    	IWebContext webContext = <span class="keyword">new</span> WebContext(request,response,</span><br><span class="line">    			request.getServletContext(),request.getLocale(), model.asMap());</span><br><span class="line">    	<span class="comment">//手动渲染</span></span><br><span class="line">    	String html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_list"</span>, webContext);</span><br><span class="line">    	<span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">            <span class="comment">//页面缓存</span></span><br><span class="line">    		redisService.set(GoodsKey.getGoodsList, <span class="string">""</span>, html);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/to_detail/&#123;goodsId&#125;"</span>,produces=<span class="string">"text/html"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">detail</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">    		@PathVariable(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    	model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//取缓存</span></span><br><span class="line">    	String html = redisService.get(GoodsKey.getGoodsDetail, <span class="string">""</span>+goodsId, String.class);</span><br><span class="line">    	<span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">    		<span class="keyword">return</span> html;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//手动渲染</span></span><br><span class="line">    	GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    	model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">long</span> startAt = goods.getStartDate().getTime();</span><br><span class="line">    	<span class="keyword">long</span> endAt = goods.getEndDate().getTime();</span><br><span class="line">    	<span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(now &lt; startAt ) &#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">    		miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">    		remainSeconds = (<span class="keyword">int</span>)((startAt - now )/<span class="number">1000</span>);</span><br><span class="line">    	&#125;<span class="keyword">else</span>  <span class="keyword">if</span>(now &gt; endAt)&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">    		miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">    		remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span> &#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">    		miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">    		remainSeconds = <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	model.addAttribute(<span class="string">"miaoshaStatus"</span>, miaoshaStatus);</span><br><span class="line">    	model.addAttribute(<span class="string">"remainSeconds"</span>, remainSeconds);</span><br><span class="line">    	</span><br><span class="line">    	IWebContext webContext = <span class="keyword">new</span> WebContext(request,response,</span><br><span class="line">    			request.getServletContext(),request.getLocale(), model.asMap());</span><br><span class="line">    	html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_detail"</span>, webContext);</span><br><span class="line">    	<span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">            <span class="comment">//url缓存</span></span><br><span class="line">    		redisService.set(GoodsKey.getGoodsDetail, <span class="string">""</span>+goodsId, html);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//对象缓存即：将对象化成json存放到reids中；在更新对象缓存的时候要注意先更新db数据库的再更新缓存中的数据来保持一致性</span></span><br></pre></td></tr></table></figure>
<p>​    这里对于页面缓存的实现，可以使用thymeleaf来实现；也可以使用对象缓存，然后用ajax获取数据并且利用vue或者angular来渲染页面，就不用将整个html页面存放到redis中去了。</p>
<hr>
<h1 id="秒杀模块"><a href="#秒杀模块" class="headerlink" title="秒杀模块"></a>秒杀模块</h1><p>优化商品的秒杀API的主要内容：</p>
<p>(秒杀订单中商品ID和用户的ID做UNIQUE 约束)</p>
<ol>
<li><p>隐藏秒杀地址</p>
<ul>
<li>当你可以对商品进行秒杀的时候，先去根据用户获取秒杀的url（如秒杀url：<code><strong>/{path}/do_seckill</strong></code>），然后将这个path根据用户放入到redis中</li>
<li>获取到路径返回后再去请求刚才获取到的url进行商品的秒杀，此时会对商品的url上的path进行验证，是相同的path才能进行秒杀操作</li>
<li>这里需要对获取path的接口进行防刷（限流）操作</li>
</ul>
</li>
<li><p>接口防刷</p>
<ul>
<li><p>使用<strong>自定义注解</strong>加<strong>拦截器</strong>的方式实现接口的防刷</p>
</li>
<li><p>自定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">seconds</span><span class="params">()</span></span>;<span class="comment">//n秒内可以请求maxCount次这个接口</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">()</span></span>;<span class="comment">//最大次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用拦截器拦截秒杀API的请求（利用HandlerMethod <code>hm.getMethodAnnotation(AccessLimit.class)</code> 来获取自定义的AccessLimit注解）</p>
</li>
<li><p>当满足在n秒内请求数量在maxCount以内的即可放行当前的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">			HandlerMethod hm = (HandlerMethod)handler;</span><br><span class="line">            <span class="comment">//方法上无该注解则直接放行</span></span><br><span class="line">			AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);</span><br><span class="line">			<span class="keyword">if</span>(accessLimit == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> seconds = accessLimit.seconds();</span><br><span class="line">			<span class="keyword">int</span> maxCount = accessLimit.maxCount();</span><br><span class="line">			String key = request.getRequestURI();</span><br><span class="line">            <span class="comment">//获取现在的次数</span></span><br><span class="line">			String count = jedisUtils.get(key, RedisDBEnum.ACCESS_BD.getDb());</span><br><span class="line">	    	<span class="keyword">if</span>(count == <span class="keyword">null</span>) &#123;</span><br><span class="line">				jedisUtils.setex(<span class="string">"access"</span> + key, String.valueOf(<span class="number">1</span>), seconds, RedisDBEnum.ACCESS_BD.getDb());</span><br><span class="line">	    	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(Integer.valueOf(count) &lt; maxCount) &#123;</span><br><span class="line">				jedisUtils.incr(<span class="string">"access"</span> + key, RedisDBEnum.ACCESS_BD.getDb());</span><br><span class="line">	    	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	    		render(response, CodeMsg.ACCESS_LIMIT_REACHED);</span><br><span class="line">	    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>图形验证码方式防刷</p>
<ul>
<li><p>在用户进入秒杀商品页面（跳转该页面时，服务端生成与用户对应的验证码，并且将该验证码与用户对应的方式放入到redis中存放，设置过期时间）的时候增加验证码输入框</p>
</li>
<li><p>注意需要为验证码增加一个刷新验证码的接口，用户刷新验证码的时候生成一个新的验证码并且删除旧的验证码，再将新的验证码放入到redis中同时设置过期时间</p>
<ul>
<li>记得一定要对刷新验证码的接口进行<strong>防刷的操作</strong>（因为刷新验证码接口需要对redis进行数据操作，对redis 操作是有网络开销的，不做防刷操作的话，被别人恶意请求的话是会对服务器产生负担的）</li>
</ul>
</li>
<li><p>验证码的类型：可以生成算术题目的验证码，也可以是简单的字母+数字组合的验证码；可自行选择，只有验证码验证通过后再进行商品的秒杀</p>
</li>
<li><p>下面引用一个别人写好的例子（使用swing生成一个算术类型的验证码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Results&lt;String&gt; <span class="title">getSeckillVerifyCod</span><span class="params">(HttpServletResponse response,User user,@RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		BufferedImage image  = orderService.createVerifyCode(user, goodsId);</span><br><span class="line">    		OutputStream out = response.getOutputStream();</span><br><span class="line">    		ImageIO.write(image, <span class="string">"JPEG"</span>, out);</span><br><span class="line">    		out.flush();</span><br><span class="line">    		out.close();</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    		<span class="keyword">return</span> Results.faild(CodeMsg.SECKILL_FAIL);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedImage <span class="title">createVerifyCode</span><span class="params">(User user, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(user == <span class="keyword">null</span> || goodsId &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> width = <span class="number">80</span>;</span><br><span class="line">		<span class="keyword">int</span> height = <span class="number">32</span>;</span><br><span class="line">		<span class="comment">//create the image</span></span><br><span class="line">		BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">		Graphics g = image.getGraphics();</span><br><span class="line">		<span class="comment">// set the background color</span></span><br><span class="line">		g.setColor(<span class="keyword">new</span> Color(<span class="number">0xDCDCDC</span>));</span><br><span class="line">		g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">		<span class="comment">// draw the border</span></span><br><span class="line">		g.setColor(Color.black);</span><br><span class="line">		g.drawRect(<span class="number">0</span>, <span class="number">0</span>, width - <span class="number">1</span>, height - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// create a random instance to generate the codes</span></span><br><span class="line">		Random rdm = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="comment">// make some confusion</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = rdm.nextInt(width);</span><br><span class="line">			<span class="keyword">int</span> y = rdm.nextInt(height);</span><br><span class="line">			g.drawOval(x, y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// generate a random code</span></span><br><span class="line">		String verifyCode = generateVerifyCode(rdm);</span><br><span class="line">		g.setColor(<span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>));</span><br><span class="line">		g.setFont(<span class="keyword">new</span> Font(<span class="string">"Candara"</span>, Font.BOLD, <span class="number">24</span>));</span><br><span class="line">		g.drawString(verifyCode, <span class="number">8</span>, <span class="number">24</span>);</span><br><span class="line">		g.dispose();</span><br><span class="line">		<span class="comment">//把验证码存到redis中，设置过期时间</span></span><br><span class="line">		<span class="keyword">int</span> rnd = calc(verifyCode);</span><br><span class="line">		redisService.set(<span class="string">"seckill_vc_"</span> + user.getId()+<span class="string">"_"</span>+goodsId, rnd,<span class="number">60</span> ,RedisDBEnum.ACCESS_BD.getDb());</span><br><span class="line">		<span class="comment">//输出图片	</span></span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ScriptEngineManager manager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">			ScriptEngine engine = manager.getEngineByName(<span class="string">"JavaScript"</span>);</span><br><span class="line">			<span class="keyword">return</span> (Integer)engine.eval(exp);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] ops = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateVerifyCode</span><span class="params">(Random rdm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> num2 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> num3 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">char</span> op1 = ops[rdm.nextInt(<span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">char</span> op2 = ops[rdm.nextInt(<span class="number">3</span>)];</span><br><span class="line">    String exp = <span class="string">""</span>+ num1 + op1 + num2 + op2 + num3;</span><br><span class="line">    <span class="keyword">return</span> exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>MQ实现异步商品秒杀</p>
<blockquote>
<p>为什么要异步下单请往下看。。</p>
</blockquote>
<ul>
<li>首先需要将秒杀商品的sku放入到redis中</li>
<li>当到了秒杀的时间段开始秒杀的时候</li>
<li>先判断redis中的sku是否还有（大于0），没有则直接返回秒杀失败；还有sku的时候，对redis中sku 的值进行减一操作</li>
<li>此时需要查看是否该用户已经秒杀过该商品了（视业务而定，在这里一个用户只能秒杀一次）<ul>
<li>如果已经秒杀过该商品的用户，直接返回（可以对sku进行恢复）</li>
</ul>
</li>
<li>如果不是秒杀过该商品的用户，那么将用户和商品信息放入到消息队列中（可以使用Direct Exchange模式）</li>
<li>加入消息队列后即可返回给用户（排队或其他消息），然后轮询订单的接口查看订单是否已经准备好<ul>
<li>下单的系统监听该消息队列，获取到消息时先判断用户是否已经秒杀过。如果没有则进行减库存、下订单的操作</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="为什么要异步下单？"><a href="#为什么要异步下单？" class="headerlink" title="为什么要异步下单？"></a>为什么要异步下单？</h2><p>（个人理解，大神们有更好的理解可以发表一下，非常感谢！）</p>
<ul>
<li><p>在电商平台中，需要考虑到技术方面的各个环节，在这个项目中实现的商品秒杀并不是基于服务化的环境去搭建的系统，在这里只是给出了一些实现的思路而已。</p>
</li>
<li><p>下单操作就需要业务，网络和并发量等方面的问题了，一般服务分得细的话，订单的操作应该交由特定的服务去处理，这里就可以交由消息队列去实现异步的下单操作。</p>
</li>
<li><p>秒杀的API可以先返回排队或者请稍等的文案，然后又前台去轮询订单是否已经生成。这样做还能降低系统的复杂度，并且如果是同步的操作那么在很短时间处理很大量的并发请求的话难度是很高的，异步方式去处理的话能够保障（注意：不是保证！）系统的可用性了。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/Adrian_Github_io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/Adrian_Github_io/" itemprop="url">welcome baby!</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-08T11:00:20+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Netty内部都是通过线程在处理各种数据</span></span><br><span class="line"><span class="comment">         * EventLoopGroup就是用来管理调度他们的，注册Channel，管理他们的生命周期。</span></span><br><span class="line"><span class="comment">         * NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，</span></span><br><span class="line"><span class="comment">         * Netty提供了许多不同的EventLoopGroup的实现用来处理不同传输协议。</span></span><br><span class="line"><span class="comment">         * 有2个NioEventLoopGroup会被使用。</span></span><br><span class="line"><span class="comment">         * 第一个经常被叫做‘boss’，用来接收进来的连接。</span></span><br><span class="line"><span class="comment">         * 第二个经常被叫做‘worker’，用来处理已经被接收的连接，</span></span><br><span class="line"><span class="comment">         * 一旦‘boss’接收到连接，就会把连接信息注册到‘worker’上。</span></span><br><span class="line"><span class="comment">         * 如何知道多少个线程已经被使用，如何映射到已经创建的Channels上都需要依赖于EventLoopGroup的实现，</span></span><br><span class="line"><span class="comment">         * 并且可以通过构造函数来配置他们的关系。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//因为bossGroup仅接收客户端连接，不做复杂的逻辑处理，为了尽可能减少资源的占用，取值越小越好</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 与 bossGroup 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建Channel 的 EventLoop。</span></span><br><span class="line"><span class="comment">         * 一旦连接被接受，workerGroup 就会给它的 Channel 分配一个 EventLoop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * ServerBootstrap 是一个启动NIO服务的辅助启动类</span></span><br><span class="line"><span class="comment">             * 你可以在这个服务中直接使用Channel</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * ServerSocketChannel以NIO的selector为基础进行实现的</span></span><br><span class="line"><span class="comment">                     * 指定使用NioServerSocketChannel产生一个Channel用来接收连接</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>) <span class="comment">// 连接数</span></span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      * option()是提供给NioServerSocketChannel用来接收进来的连接。</span></span><br><span class="line"><span class="comment">                      * childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>) <span class="comment">// 不延迟，消息立即发送</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 是否启用心跳保活机制。在双方TCP套接字建立连接后（即都进入ESTABLISHED状态）</span></span><br><span class="line"><span class="comment">                     * 并且在两个小时左右上层没有任何数据传输的情况下，这套机制才会被激活</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 长连接</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                     <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      * 这里的事件处理类经常会被用来处理一个最近的已经接收的Channel。</span></span><br><span class="line"><span class="comment">                      * ChannelInitializer是一个特殊的处理类，</span></span><br><span class="line"><span class="comment">                      * 他的目的是帮助使用者配置一个新的Channel。</span></span><br><span class="line"><span class="comment">                      * 也许你想通过增加一些处理类比如NettyServerHandler来配置一个新的Channel</span></span><br><span class="line"><span class="comment">                      * 或者其对应的ChannelPipeline来实现你的网络程序。</span></span><br><span class="line"><span class="comment">                      * 当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，</span></span><br><span class="line"><span class="comment">                      * 然后提取这些匿名类到最顶层的类上。</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 添加NettyServerHandler，用来处理Server端接收和处理消息的逻辑</span></span><br><span class="line">                            <span class="comment">// ChannelPipeline用于存放管理ChannelHandel</span></span><br><span class="line">                            <span class="comment">// ChannelHandler用于处理请求响应的业务逻辑相关代码</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 绑定端口并启动去接收进来的连接</span></span><br><span class="line"><span class="comment">             * 对 sync()方法的调用将导致当前 Thread 阻塞，一直到绑定操作完成为止</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ChannelFuture sync = serverBootstrap.bind(<span class="number">8081</span>).sync();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这里会一直等待，直到socket被关闭或者被唤醒</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sync()会同步等待连接操作结果</span></span><br><span class="line"><span class="comment">             * 用户线程将在此wait()，直到连接操作完成之后，线程被notify(),用户代码继续执行</span></span><br><span class="line"><span class="comment">             * closeFuture()当Channel关闭时返回一个ChannelFuture,用于链路检测</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果你只指定了一个EventLoopGroup，</span></span><br><span class="line"><span class="comment">         * 那他就会即作为一个‘boss’线程，</span></span><br><span class="line"><span class="comment">         * 也会作为一个‘workder’线程，</span></span><br><span class="line"><span class="comment">         * 尽管客户端不需要使用到‘boss’线程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 不像在使用ServerBootstrap时需要用childOption()方法，</span></span><br><span class="line"><span class="comment">                     * 因为客户端的SocketChannel没有父channel的概念。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>) <span class="comment">// 不延迟，消息立即发送</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture sync = bootstrap.connect(InetAddress.getLocalHost(),<span class="number">8081</span>).sync();</span><br><span class="line">            <span class="keyword">if</span> (sync.isSuccess()) &#123;</span><br><span class="line">                System.err.println(<span class="string">"连接服务器成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sync.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/rifumei.jpg" alt="Adrian Dai">
            
              <p class="site-author-name" itemprop="name">Adrian Dai</p>
              <p class="site-description motion-element" itemprop="description">看板娘赛高！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/daiadrian" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:daiadrian@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/Adrian_Dai" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adrian Dai</span>

  
</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"vOffset":-100,"hOffset":0},"mobile":{"show":true,"motion":true},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
