<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="看板娘赛高！">
<meta property="og:type" content="website">
<meta property="og:title" content="Adrian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Adrian">
<meta property="og:description" content="看板娘赛高！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Adrian">
<meta name="twitter:description" content="看板娘赛高！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Adrian</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/daiadrian" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Adrian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/偏向锁、轻量级锁和重量级锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/03/偏向锁、轻量级锁和重量级锁/" itemprop="url">偏向锁、轻量级锁和重量级锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T16:14:39+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2019/10/03/偏向锁、轻量级锁和重量级锁/./偏向锁、轻量级锁和重量级锁/JVM的MarkWord存储结构.png" alt="JVM的MarkWord存储结构"></p>
<p><strong>注</strong>：最后两位为锁标记位，倒数第三位是偏向标记，如果是1表示是偏向锁；合并单元格的位数就是 该字段的位数，例如hash code共25（23+2）位。</p>
<blockquote>
<p><strong>另外，对于偏向锁，如果Thread ID = 0，表示未加锁</strong></p>
</blockquote>
<h2 id="Synchronized锁升级-偏向锁-→-轻量级锁-→-重量级锁"><a href="#Synchronized锁升级-偏向锁-→-轻量级锁-→-重量级锁" class="headerlink" title="Synchronized锁升级:偏向锁 → 轻量级锁 → 重量级锁"></a>Synchronized锁升级:偏向锁 → 轻量级锁 → 重量级锁</h2><p>​        <code>Synchronized</code> 会从<strong><font color="blue">无锁</font></strong>升级为<strong><font color="blue">偏向锁</font></strong>，再升级为<strong><font color="blue">轻量级锁</font></strong>，最后升级为<strong><font color="blue">重量级锁</font></strong>，这里的轻量级锁就是一种<strong><font color="blue">自旋锁</font></strong></p>
<p>​        锁只能按照上述的顺序进行升级操作，锁只要升级之后，就不能降级</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>​        初次执行到 <code>Synchronized</code> 代码块的时候，锁对象变成<strong><font color="red">偏向锁</font></strong>（通过CAS修改对象头里的锁标志位），字面意思是 ”偏向于第一个获得它的线程“ 的锁</p>
<p>​        偏向锁是 JDK 默认启动的选项，可以通过 <code>-XX:-UseBiasedLocking</code>  来关闭偏向锁。另外偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令 <code>-XX:BiasedLockingStartupDelay=0</code> 来关闭延迟</p>
<p>​        执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高</p>
<p>​        <strong>引入偏向锁的目的是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁在无竞争的情况下会把整个同步都消除掉</strong></p>
<h4 id="偏向锁的加锁"><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h4><p>​        如果 JVM 支持偏向锁，那么在分配对象时，分配一个<strong>可偏向而未偏向的对象</strong>（Mark Word的最后3位 为101，并且<code>Thread ID</code>字段的值为0）</p>
<p>​        然后，当一个线程访问同步块并获取锁时，将通过 <code>CAS(Compare And Swap)</code> 来尝试将对象头中的 <code>Thread ID</code>字段设置为自己的线程号，如果设置成功，则获得锁，那么以后线程再次进入和退出 同步块时，就不需要使用 <code>CAS</code> 来获取锁，只是简单的测试一个对象头中的Mark Word字段中是否存储着指向当前线程的偏向锁</p>
<p>​        如果使用 <code>CAS</code> 设置失败时，说明存在锁的竞争，那么将执行偏向锁的撤销操作 （<code>revoke bias</code>），将偏向锁升级为轻量级锁</p>
<h4 id="偏向锁升级轻量级锁"><a href="#偏向锁升级轻量级锁" class="headerlink" title="偏向锁升级轻量级锁"></a>偏向锁升级轻量级锁</h4><p>​        当线程1访问代码块并获取锁对象时，会在 Java对象头和栈帧中记录偏向的锁的 <code>Thread ID</code>，因为<font color="red">偏向锁不会主动释放锁</font>，因此以后线程1再次获取锁的时候，需要比较当前线程的 <code>Thread ID</code> 和Java对象头中的 <code>Thread ID</code>是否一致，如果一致（还是线程1获取锁对象），则无需使用 <code>CAS</code> 来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而<u><font color="blue">偏向锁不会主动释放因此还是存储的线程1的 <code>Thread ID</code></font></u>）</p>
<p>那么需要查看 Java对象头中记录的线程1是否存活：</p>
<ul>
<li>如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁</li>
<li>如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程</li>
</ul>
<blockquote>
<p>简单来说：线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活</p>
<ul>
<li><strong>如果线程A仍然存活，</strong>将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋（自旋超过一定的次数后，会膨胀成重量级锁）</li>
<li>但是<strong>如果判断结果是线程A不存在了</strong>，则线程B持有此偏向锁，锁不升级</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BiasedLocking::<span class="function">Condition <span class="title">revoke_bias</span><span class="params">(oop obj, <span class="keyword">bool</span> allow_rebias,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">bool</span> is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  <span class="comment">// 检查是否可偏向</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 可偏向但是未偏向的情况</span></span><br><span class="line">    <span class="comment">// 可能的使用场景为：因计算hash code而撤销偏向</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对象现在偏向的线程是否还存在</span></span><br><span class="line">  <span class="comment">// 即对象头中Mark Word中Thread ID字段指向的线程是否存在</span></span><br><span class="line">  <span class="keyword">bool</span> thread_is_alive = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    <span class="comment">// 请求的线程拥有偏向锁</span></span><br><span class="line">    thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 请求的线程不拥有偏向锁，递归查询</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::first();</span><br><span class="line">        cur_thread != <span class="literal">NULL</span>; cur_thread = cur_thread-&gt;next()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      <span class="comment">//退回可偏向但未偏向的状态 </span></span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//偏向撤销，变为无锁状态  </span></span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拥有偏向锁的线程仍然存活</span></span><br><span class="line">  <span class="comment">// 检查该线程是否拥有锁：</span></span><br><span class="line">  <span class="comment">//    如果拥有锁，那么需要升级为轻量级锁，然后将displaced mark word复制到线程栈中；</span></span><br><span class="line">  <span class="comment">//    如果不再拥有锁，如果允许重偏向，那么将mark word中的Thread ID 重新置0；</span></span><br><span class="line">  <span class="comment">//                 如果不允许重偏向，那么将mark work设置为无锁状态，即最后两位为01</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// cached_monitor_info 是该线程拥有的锁对象的信息，按照从加锁顺序的逆序排列</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info =</span><br><span class="line">                get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;owner() == obj) &#123;</span><br><span class="line">      <span class="comment">// Assume recursive case and fix up highest lock later</span></span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) <span class="literal">NULL</span>);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 线程拥有锁</span></span><br><span class="line">    <span class="comment">// Fix up highest lock to contain displaced header and point</span></span><br><span class="line">    <span class="comment">// object at it</span></span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">    <span class="comment">// Reset object header to point to displaced mark.</span></span><br><span class="line">    <span class="comment">// Must release storing the lock address for platforms without TSO</span></span><br><span class="line">    <span class="comment">// ordering (e.g. ppc).</span></span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 线程不再拥有锁</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对上面的伪代码实现</span></span><br><span class="line"><span class="comment">// 撤销流程的伪代码，在全局检查点执行该操作</span></span><br><span class="line"><span class="keyword">if</span> mark word 存储的不是可偏向状态:</span><br><span class="line">    <span class="keyword">return</span>;     <span class="comment">// 如果不是偏向锁，那么没有撤销偏向的必要</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> Thread ID 指向的线程不存活:</span><br><span class="line">        <span class="keyword">if</span> 允许重偏向:</span><br><span class="line">            退回可偏向但未偏向的状态   <span class="comment">// Thread ID为0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            偏向撤销，变为无锁状态</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> Thread ID 指向的线程，仍然拥有锁:</span><br><span class="line">            升级为轻量级锁，将mark word复制到线程栈中，然后stack pointer指向最老的相关锁记录</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> 允许重偏向:</span><br><span class="line">                退回可偏向但未偏向的状态   <span class="comment">// Thread ID为0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                偏向撤销，变为无锁状态</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<p>​        撤销偏向的操作需要在全局检查点执行。我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否允许重偏向（<code>rebiasing</code>），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁升级为轻量级锁，线程B自旋请求获得锁</p>
<p><img src="/2019/10/03/偏向锁、轻量级锁和重量级锁/./偏向锁、轻量级锁和重量级锁/偏向锁撤销流程.png" alt="偏向锁撤销流程"></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>​        轻量级锁不是使用操作系统互斥量来实现锁， 而是通过 <code>CAS</code> 操作来实现锁。当线程获得轻量级锁后，可以再次进入锁，即锁是可重入（<code>Reentrance Lock</code>）的</p>
<p>​        <strong>在轻量级锁的加锁阶段，如果线程发现对象头中Mark Word已经存在指向自己栈帧的指针，即线程已经获得轻量级锁，那么只需要将0存储在自己的栈帧中（此过程称为递归加锁）；在解锁的时候，如果发现锁记录的内容为0， 那么只需要移除栈帧中的锁记录即可，而不需要更新Mark Word</strong></p>
<p>​        在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong><font color="red">自旋</font></strong>（即不停地循环判断锁是否能够被成功获取）</p>
<h4 id="忙等"><a href="#忙等" class="headerlink" title="忙等"></a>忙等</h4><p>​        长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong><font color="red">忙等（busy-waiting）</font></strong></p>
<p>​        如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么 <code>Synchronized</code> 就用轻量级锁，允许短时间的忙等现象。<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销</strong></p>
<h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><ol>
<li>线程在执行同步块之前，<code>JVM</code> 会先在当前的线程的栈帧中创建所记录的空间，用于存储对象头中的 Mark Word的拷贝</li>
<li>然后线程尝试使用 <code>CAS</code> 将对象头中的Mark Word替换为指向锁记录（<code>Lock Record</code>）的指针</li>
<li>如果成功，当前线程获得轻量级锁</li>
<li>如果失败，虚拟机先检查当前对象头的Mark Word 是否指向当前线程的栈帧<ul>
<li>如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块执行操作</li>
<li>否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的<font color="red">自旋次数达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁</font></li>
</ul>
</li>
</ol>
<p><img src="/2019/10/03/偏向锁、轻量级锁和重量级锁/./偏向锁、轻量级锁和重量级锁/轻量级锁升级重量级锁.png" alt="轻量级锁升级重量级锁"></p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>​        （有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）</p>
<p>​        如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong><font color="red">重量级锁</font></strong>（依然是 <code>CAS</code> 修改锁标志位，但不修改持有锁的线程ID）</p>
<p>​        当后续线程尝试获取锁时，<font color="red">发现被占用的锁是重量级锁，直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁</font></p>
<blockquote>
<p>在 <code>JDK1.6</code> 之前，<code>Synchronized</code> 直接加重量级锁，很明显现在得到了很好的优化</p>
</blockquote>
<h3 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h3><p>​        如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>​        锁消除指的是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>​        如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗</p>
<p>​        如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<blockquote>
<p>​        比如说有多个append方法，对每一个方法都加锁，此时会进行锁粗化，将第一个append直到最后一个append包起来，这样就只会进行一次的加锁操作而不是多次</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        一个锁只能按照 <font color="green"><strong>偏向锁、轻量级锁、重量级锁</strong></font> 的顺序逐渐升级（也叫<strong>锁膨胀</strong>），不允许降级</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，与执行非同步方法仅存在纳秒级的差距</td>
<td>如果线程间存在竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的情况</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会堵塞，提高了程序的响应速度</td>
<td>始终得不到锁的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常块，只有两个线程竞争锁</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程堵塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度比较慢，竞争锁的线程大于2个</td>
</tr>
</tbody>
</table>
<h2 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h2><p>​        Java并没有提供任何直接中断某线程的方法，只提供了<strong>中断机制</strong></p>
<blockquote>
<p>何谓“中断机制”？</p>
<p>​        线程A向线程B发出 “请你停止运行” 的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断</p>
<p>​        也就是说，Java的<strong>中断不能直接终止线程</strong>，而是需要被中断的线程自己决定怎么处理</p>
</blockquote>
<p>​        如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是<strong>可中断锁</strong>。在Java中，synchronized就是<strong>不可中断锁</strong>，而Lock的实现类都是<strong>可中断锁</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/ThreadPoolExecutor/" itemprop="url">ThreadPoolExecutor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T12:00:30+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法参数解析"><a href="#构造方法参数解析" class="headerlink" title="构造方法参数解析"></a>构造方法参数解析</h3><ol>
<li><p><strong><font color="green">corePoolSize</font></strong>：核心线程数</p>
</li>
<li><p><strong><font color="green">maximumPoolSize</font></strong>：最大线程数，线程池允许创建的最大线程数</p>
</li>
<li><p><strong><font color="green">workQueue</font></strong>：任务队列，<code>BlockingQueue</code> 接口的某个实现（常使用 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>）</p>
</li>
<li><p><strong><font color="green">keepAliveTime</font></strong>：空闲线程的<strong>保活时间</strong>，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了</p>
<blockquote>
<p><font color="red"><strong>注意：</strong></font>这个值并不会对所有线程起作用；</p>
<ol>
<li>如果<strong>线程池中的线程数</strong>少于等于核心线程数 <code>corePoolSize</code><strong>，那么这些线程不会因为空闲太长时间而被关闭，</strong></li>
<li><strong>可以通过调用 <code>allowCoreThreadTimeOut(true)</code></strong> 使核心线程数内的线程也可以被回收</li>
</ol>
</blockquote>
</li>
<li><p><strong><font color="green">TimeUnit</font></strong>：参数的时间单位；<code>TimeYnit</code> 是枚举类</p>
</li>
<li><p><strong><font color="green">threadFactory</font></strong>：<strong>用于生成线程</strong>，一般我们可以用默认的就可以了</p>
<blockquote>
<p>通常，我们可以通过它将我们的线程的名字设置得比较可读一些</p>
<p>如 <code>Message-Thread-1</code>， <code>Message-Thread-2</code> 类似这样</p>
</blockquote>
</li>
<li><p><strong><font color="green">handler</font></strong>：当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定</p>
<blockquote>
<p> <code>rejectedExecutionHandler</code> 用于处理当线程池不能执行此任务时的情况</p>
<p>主要的策略有：（默认策略是 抛出异常）</p>
<ol>
<li><strong>抛出 RejectedExecutionException 异常</strong></li>
<li><strong>忽略任务</strong></li>
<li><strong>使用提交任务的线程来执行此任务</strong></li>
<li><strong>将队列中等待最久的任务删除，然后提交此任务</strong></li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="任务策略"><a href="#任务策略" class="headerlink" title="任务策略"></a>任务策略</h3><p>​        任务策略执行的时期是<font color="red"><strong>线程池的线程达到 <code>maximumPoolSize</code> 的时候，此时新提交的任务就会按照指定策略进行操作</strong></font></p>
<ul>
<li><strong>CallerRunsPolicy</strong>：只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</li>
</ul>
<ul>
<li><strong>AbortPolicy</strong>：不管怎样，直接抛出 <code>RejectedExecutionException</code> 异常（默认）</li>
</ul>
<ul>
<li><strong>DiscardPolicy</strong>：不做任何处理，直接忽略掉这个任务</li>
</ul>
<ul>
<li><strong>DiscardOldestPolicy</strong>：如果线程池没有被关闭的话，把<font color="blue">队列队头的任务（也就是等待了最长时间的）直接扔掉</font>，然后提交这个任务到等待队列中</li>
</ul>
<h3 id="线程池中的线程创建时机"><a href="#线程池中的线程创建时机" class="headerlink" title="线程池中的线程创建时机"></a>线程池中的线程创建时机</h3><ol>
<li>如果当前线程数少于 <code>corePoolSize</code>，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务</li>
<li>如果当前线程数已经达到 <code>corePoolSize</code>，那么将<strong>提交的任务添加到队列中</strong>，<strong>等待线程池中的线程去队列中取任务</strong></li>
<li><strong>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 <code>maximumPoolSize</code>，如果此时线程数超过了 <code>maximumPoolSize</code>，那么执行拒绝策略</strong></li>
</ol>
<p><font color="red"><strong>注意：</strong></font>如果将队列设置为<strong>无界队列</strong>，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了</p>
<h3 id="线程池的状态和状态间的转换"><a href="#线程池的状态和状态间的转换" class="headerlink" title="线程池的状态和状态间的转换"></a>线程池的状态和状态间的转换</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li><p><strong><font color="blue">RUNNING（-1）</font></strong>：这是正常的状态：接受新的任务，处理等待队列中的任务</p>
</li>
<li><p><strong><font color="blue">SHUTDOWN（0）：</font></strong>不接受新的任务提交，但是会继续处理等待队列中的任务</p>
</li>
<li><p><strong><font color="blue">STOP（1）：</font></strong>不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</p>
</li>
<li><p><strong><font color="blue">TIDYING（2）：</font></strong>所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</p>
</li>
<li><p><strong><font color="blue">TERMINATED（3）：</font></strong>terminated() 方法结束后，线程池的状态就会变成这个</p>
</li>
</ul>
<blockquote>
<p><strong>线程池状态</strong>等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断</p>
</blockquote>
<h4 id="状态间的切换"><a href="#状态间的切换" class="headerlink" title="状态间的切换"></a>状态间的切换</h4><ul>
<li><p><strong><font color="green">RUNNING -&gt; SHUTDOWN：</font></strong>当调用了 <strong>shutdown()</strong> 后，会发生这个状态转换，这也是最重要的</p>
</li>
<li><p><strong><font color="green">(RUNNING or SHUTDOWN) -&gt; STOP：</font></strong>当调用 <strong>shutdownNow()</strong> 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</p>
</li>
<li><p><strong><font color="green">SHUTDOWN -&gt; TIDYING：</font></strong>当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</p>
</li>
<li><p><strong><font color="green">STOP -&gt; TIDYING：</font></strong>当任务队列清空后，发生这个转换</p>
</li>
<li><p><strong><font color="green">TIDYING -&gt; TERMINATED：</font></strong>这个前面说了，当 terminated() 方法结束后</p>
</li>
</ul>
<h3 id="ThreadPoolExecutor总结"><a href="#ThreadPoolExecutor总结" class="headerlink" title="ThreadPoolExecutor总结"></a>ThreadPoolExecutor总结</h3><ol>
<li><p><code>corePoolSize</code> 到 <code>maximumPoolSize</code> 之间的线程<strong>会被回收</strong>，<code>corePoolSize</code>  的线程也可以通过设置而得到回收（<code>allowCoreThreadTimeOut(true)</code>）</p>
</li>
<li><p><strong><code>workQueue</code> 用于存放任务，</strong>添加任务的时候，如果当前线程数超过了 <code>corePoolSize</code>，那么往该队列中插入任务，<strong>线程池中的线程会负责到队列中拉取任务</strong></p>
</li>
<li><p>如果某个任务执行<strong>出现异常</strong>，那么<strong><font color="red">执行任务的线程会被关闭</font></strong>，而不是继续接收其他任务。然后会<strong>启动一个新的线程来代替它</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/List总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/List总结/" itemprop="url">List总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T23:03:52+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>ArrayList底层实现是数组，而且允许元素为null值</li>
<li><font color="red"><strong>增加和删除的操作效率低，因为有扩容和数组复制的开销存在</strong></font>（如果是根据下标去删除元素的会比较快）</li>
<li><font color="green"><strong>查询和修改的效率较高，可以直接通过下标去访问元素，时间复杂度为O(1)</strong></font></li>
<li>ArrayList 插入元素需要复制的元素，所以 <font color="blue"><strong>ArrayList 插入元素的位置越靠后效率越高</strong></font></li>
<li>多线程操作同一个ArrayList是不安全的</li>
</ul>
<blockquote>
<p>PS：如果事先知道要存储的元素个数，那么最好使用带<code>int</code>参数的构造函数，因为这样能够减少数组扩容的开销</p>
</blockquote>
<h3 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h3><p>​    ArrayList是使用数组实现的列表，具有顺序性。ArrayList内部使用了<code>transient Object[] elementData;</code> 来存储列表中的元素（即数组的缓存区）；ArrayList的容量就是该缓存区的数组长度</p>
<ol>
<li><p><code>private static final int DEFAULT_CAPACITY = 10</code> <strong>默认容量</strong>，只有在add的时候判断elementData是空数组的时候，就会初始化这个默认容量的数组赋值给elementData</p>
</li>
<li><p><code>modCount</code> 这个属性是用来记录List列表的表结构发生变化的次数（要对list的结构发生变化的操作，都会使得modCount的值进行加一；结构性操作指对列表长度进行修改的，即add/remove操作）；这个属性比较重要</p>
</li>
</ol>
<blockquote>
<p>modCount其实是<strong>fail-fast 机制</strong>的实现，即当某一个线程A通过<code>Iterator</code>去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出<code>ConcurrentModificationException</code>异常，产生fail-fast事件</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>无参构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="comment">//无参的构造函数得到的是一个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>带int参数的构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数大于0返回<code>int</code>大小的数组</li>
<li>参数为0返回空的数组</li>
<li>参数小于0则抛出异常<code>IllegalArgumentException</code></li>
</ul>
<ol start="3">
<li>构造一个包含指定元素的列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// c.toArray might (incorrectly) not return Object[]</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    构造指定元素的列表，当指定的元素为空时返回的是一个空的数组；如果元素不为空，那么直接得到一个指定元素的数组</p>
<p>​    这里有个官方的注释，这里的作用是：如果得到的element数组类型不是Obejct类型的数组，那么就要将其转换成Object类型的数组，至于这样做的原因是：</p>
<blockquote>
<p>如果没有这个Object类型转换的情况会是怎么样的，我们模拟一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"yes"</span>, <span class="string">"no"</span>));</span><br><span class="line">&gt; list.set(<span class="number">0</span>, <span class="keyword">new</span> Object());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<font color="red"><strong>注意：此处模拟指没有类型转换的情况</strong></font>

<p>执行上面的代码，会调用指定元素的构造方法（推荐debug看）</p>
<ol>
<li><p>当执行<code>elementData = c.toArray();</code> 之后，elementData会是 String[] 类型的数组，而不是 Object[] 类型的</p>
</li>
<li><p>那么执行完该构造方法之后，上面代码就会等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    Object[] list = <span class="keyword">new</span> String[]&#123;<span class="string">"yes"</span>,<span class="string">"no"</span>&#125;;</span><br><span class="line">&gt;    list[<span class="number">0</span>]=<span class="keyword">new</span> Object();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>然后当你再执行<code>list.set(0, new Object());</code> 的时候，就会抛出<code>ArrayStoreException</code> 异常了</li>
</ol>
<p>根本原因是<code>toArray()</code>方法中调用的是<code>copyOf</code> 方法，该方法实际使用的是泛型，虽然返回的是 Object[] 类型的数组，但是<strong>实际的类型</strong>已经声明成 String[] 了</p>
</blockquote>
<h3 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><h4 id="System-arraycopy、Arrays-copyOf"><a href="#System-arraycopy、Arrays-copyOf" class="headerlink" title="System.arraycopy、Arrays.copyOf"></a>System.arraycopy、Arrays.copyOf</h4><p>了解这两个方法对看下面几个方法很有帮助</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src      源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos   源数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest     目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos  指定目标数据中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length   要复制的数组元素的数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 	要复制的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 要返回的副本的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newType 	要返回的副本的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行顺序1.</span></span><br><span class="line"><span class="comment">//size默认值是0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.其实是执行3和4的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这个方法是计算list的容量的:</span></span><br><span class="line"><span class="comment">  *    上面add方法调用的时候会传入(size+1)到这个计算的方法中</span></span><br><span class="line"><span class="comment">  *    如果当前的数组是空数组,那么就比较(size+1)与默认的容量(默认是10),取较大的值返回.</span></span><br><span class="line"><span class="comment">  *    如果不是空数组,那么直接返回(size+1)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//默认容量DEFAULT_CAPACITY是10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 因为是add操作,对列表结构有改动,需要modCount++</span></span><br><span class="line"><span class="comment">  * 如果传入的(size+1)值大于当前数组的长度的时候,才对此数组进行扩容的操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.如果是超过当前数组长度才需要进行数组扩容的操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果新数组大小还是小于传入的容量的话,那就直接取传入的容量作为新数组的长度</span></span><br><span class="line"><span class="comment"> * 如果新数组的长度要比最大定义的数组长的话</span></span><br><span class="line"><span class="comment"> *      (最大的数组长度是Integer.MAX_VALUE-8)</span></span><br><span class="line"><span class="comment"> *      那么就直接使用Integer.MAX_VALUE作为数组的长度.</span></span><br><span class="line"><span class="comment"> * 然后就将数组的元素拷贝到一个新的数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//右移1位，此处得到新容量是旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>addAll(Collection&lt;? extends E&gt; c)</code> 方法和普通add方法类似，主要使用了<code>System.arraycopy</code>方法来拷贝指定元素</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入到index的下标的位置,然后返回旧的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><ol>
<li>根据传入下标来移除列表中的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	<span class="comment">//删除操作修改了列表结构</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">	<span class="comment">//需要进行移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//移动数组的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//更新列表的元素个数,清除最后一个元素,让GC回收</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据传入的对象来删除元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//移除null值元素</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//for循环遍历列表,根据对象的equals方法来移除对应元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法是移除列表中的元素,根据下标志移除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>移除包含指定元素的列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果参数为null,那么抛出异常</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意此处的complement是false</span></span><br><span class="line">        <span class="comment">//所以就是将elementData中不存在c中的元素留下</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//这里的判断的原因是因为 contains 方法可能会抛出异常</span></span><br><span class="line">        <span class="comment">//如果抛出异常的情况下,就需要对 elementData 进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里很简单,清除元素,修改 modCount 的值,然后返回true</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的迭代器"><a href="#ArrayList的迭代器" class="headerlink" title="ArrayList的迭代器"></a>ArrayList的迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList使用的迭代器是其内部类<code>Itr</code></p>
<blockquote>
<p>其内部类还有<code>ListItr</code>也是迭代器，只是这个迭代器可以在任意方向遍历列表，即可以向前/向后遍历。可以通过<code>public ListIterator&lt;E&gt; listIterator()</code>方法得到该迭代器</p>
</blockquote>
<p>此处专注于迭代器<code>Itr</code>，先来查看该类的属性</p>
<ul>
<li><code>int cursor</code>  ：要返回的下一个元素的索引</li>
<li><code>int lastRet = -1</code>：返回的最后一个元素的索引，如果没有返回-1</li>
<li><code>int expectedModCount = modCount</code>：结构修改次数</li>
</ul>
<ol>
<li>遍历元素的方法</li>
</ol>
<p>在遍历元素前列表都会比较结构修改次数，如果结构修改次数不对应，那么会抛出<code>ConcurrentModificationException</code>异常；所以在多线程对同个列表进行迭代和增删操作的时候，很大可能会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否还有下一个可遍历的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">//这里都是判断下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">//游标+1</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在获取元素之前，需要先判断列表结构是否被修改过</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>移除元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个地方就是为什么需要先执行 next 方法后才能调用 remove 方法的原因</span></span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="comment">//在移除元素之前，需要先判断列表结构是否被修改过</span></span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用arrayList的remove方法</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="comment">//重置一下游标,因为 next 操作里面将游标+1了</span></span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新结构修改次数，上面调用remove方法导致modCount增加了</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的遍历方式及问题"><a href="#ArrayList的遍历方式及问题" class="headerlink" title="ArrayList的遍历方式及问题"></a>ArrayList的遍历方式及问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * List的遍历方式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cycleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.asList(ints) 将数组转成List</span></span><br><span class="line">    List&lt;Integer&gt; lists = Arrays.asList(ints);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.for循环遍历</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * foreach循环(增强for循环)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.size();i++) &#123;</span><br><span class="line">        System.out.println(lists.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : lists) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 2.迭代器遍历</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = lists.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 3.JDK8的stream流方式</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    lists.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>for循环遍历元素的时候，如果需要在for循环中删除元素，此时需要注意：</p>
<ul>
<li>使用foreach（即增强for循环）的话会有下标越界问题</li>
<li>for循环如果长度length是每次判断都重新获取的话是没有问题的</li>
<li>for循环如果是事先定义好长度length的话会发生下标越界问题</li>
</ul>
<h3 id="ArrayList元素去重"><a href="#ArrayList元素去重" class="headerlink" title="ArrayList元素去重"></a>ArrayList元素去重</h3><h4 id="遍历列表去重"><a href="#遍历列表去重" class="headerlink" title="遍历列表去重"></a>遍历列表去重</h4><p>实现思路：</p>
<ol>
<li>定义（new）一个新的List集合</li>
<li>遍历原集合中的每一个元素，然后判断新集合中是否包含了该元素<ul>
<li>包含就不添加到新集合</li>
<li>不包含则加到新集合中</li>
</ul>
</li>
<li>然后返回新的集合得到去重后的List</li>
</ol>
<h4 id="自定义对象去重"><a href="#自定义对象去重" class="headerlink" title="自定义对象去重"></a>自定义对象去重</h4><p>实现思路：跟遍历去重方式思路基本上一致，只是对于对象的遍历判断，是需要重写equals和hasCode方法来比较对象是否重复</p>
<h4 id="JDK8的流方式去重"><a href="#JDK8的流方式去重" class="headerlink" title="JDK8的流方式去重"></a>JDK8的流方式去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<font color="red"><strong>注意：</strong></font> 如果列表中是对象的话，一定要重写对象的<code>equals()</code> 和<code>hasCode()</code> 方法来定义对象是否重复的规则<br><br><br><br>### SubList方法的坑<br><br>SubList方法能够返回指定下标区间的父List的<strong>视图</strong>、<strong>视图</strong>、<strong>视图</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不包含toIndex下标的元素，即左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line">SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><font color="red">要注意的地方就是</font></strong>：调用这个方法并不是返回一个全新的列表，而是返回一个视图。所以在操作这个方法得到的视图会影响原列表的内容。简单来说就是subList后得到的列表跟原列表是同一个对象<br><br><br><br>## LinkedList<br><br>### 小结<br><br>- LinkedList底层的实现是链表（双向链表），可以允许元素为null值，<strong>LinkedList是有序集合</strong><br>- <font color="green"><strong>增加和删除的时候只需要修改节点上的指针即可，效率比较高</strong></font><br>- <font color="red"><strong>查找和修改的时候就只能从链表的头出发一直往下遍历找到该目标元素的节点才能进行操作，效率很低</strong></font><br>- <font color="blue">LinkedList内部查询的时候使用的<strong><code>size &gt;&gt; 1</code> </strong>的方式（即折半法查找）来查找index，从而提高查询的效率</font><br>- LinkedList 集合插入元素的位置影响 LinkedList 集合插入的效率，<font color="red">插入位置越靠前或者越靠后，效率越高；位置越中间效率低</font>



<h3 id="大致结构-1"><a href="#大致结构-1" class="headerlink" title="大致结构"></a>大致结构</h3><ol>
<li><code>transient Node&lt;E&gt; first</code> 存放头结点</li>
<li><code>transient Node&lt;E&gt; last</code> 存放尾节点</li>
<li>modCount：<strong>fail-fast机制</strong></li>
<li>Node节点；LinkedList内部使用了Node类的存放元素的，新增元素的时候，会将元素包装成Node节点来进行操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;        <span class="comment">//元素</span></span><br><span class="line">    Node&lt;E&gt; next;  <span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;  <span class="comment">//前置节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>无参构造（真无参。。）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指定元素列表的构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用addAll方法，这个下面详说</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增删改查方法-1"><a href="#增删改查方法-1" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><p>LinkedList的增加方法的核心是<code>linkBefore(E e, Node&lt;E&gt; succ)</code>、<code>linkFirst(E e)</code>、<code>linkLast(E e)</code>和<code>node(int index)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素到链表末尾</span></span><br><span class="line"><span class="comment">//将元素包装成Node节点,然后就是链表的操作了</span></span><br><span class="line"><span class="comment">//	如果尾节点是空的,那么将该节点作为头和尾节点</span></span><br><span class="line"><span class="comment">//	如果尾节点非空,那么将该节点作为尾节点,并且加入到链表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素到链表头</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表操作,将 e 插入到 succ 前面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// succ 不能为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//即succ是头节点的情况</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用折半法得到index所在的位置(左/右区间)</span></span><br><span class="line"><span class="comment"> * 然后采用for循环遍历的方式得到index位置上的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">//注意：这里是从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>add(E e)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入链表的末尾</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>add(int index, E element)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">//添加到链表最后,即调用上面的add(E e)方法</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//插入node(index)节点之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查下标是否越界和index是否小于0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>addAll</code>方法，带参构造函数中也调用此方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//得到指定插入的元素</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//获取插入位置的前驱和后继节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//for循环插入指定元素,并且设置好上面的前驱和后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Get-1"><a href="#Get-1" class="headerlink" title="Get"></a>Get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回头节点元素内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回尾节点元素内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取指定下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//折半for循环查找指定下标的元素</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查下标是否越界和index是否小于0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h4><p>LinkedList的删除方法的核心是<code>unlink(Node&lt;E&gt; x)</code>、<code>unlinkFirst(Node&lt;E&gt; f)</code>和<code>unlinkLast(Node&lt;E&gt; l)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求参数 x 不能为null</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到需要删除节点的内容、前驱节点和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该节点是头结点的情况</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该节点是尾节点的情况</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要求f是头节点并且不为null</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//链表元素只有一个的情况</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要求l是尾节点并且不为null</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//链表元素只有一个的情况</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>remove()</code>移除第一个节点，即当前头节点</li>
<li><code>remove(int index)</code>移除下标是index的节点，先检查下标是否越界，再利用<code>node(int index)</code>方法得到节点，最后用<code>unlink(Node&lt;E&gt; x)</code>移除</li>
<li><code>removeFirst()</code>和<code>removeLast()</code>方法。根据名称可知作用，如果头结点/尾节点为null的情况，即链表为空的情况会抛出<code>NoSuchElementException</code>，然后各自调用<code>unlinkFirst</code>和<code>unlinkLast</code>删除节点</li>
<li><code>remove(Object o)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定元素的节点，利用for循环便利链表，找到第一个配对的元素删除</span></span><br><span class="line"><span class="comment">//注意：如果链表有多个相同的元素，该方法只会删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界或者index是否小于0</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//找到index下标的元素,更新该item内容后返回旧值</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pop、poll、peek、push、offer"><a href="#pop、poll、peek、push、offer" class="headerlink" title="pop、poll、peek、push、offer"></a>pop、poll、peek、push、offer</h4><ol>
<li><strong>peek获取头结点</strong>；<font color="red">如果链表为空则返回null</font></li>
<li><strong>pop弹出头结点</strong>，头结点会被删除。如果链表为空，那么抛出<code>NoSuchElementException</code></li>
<li><strong>poll弹出头结点</strong>，头结点会被删除。如果链表为空则返回null</li>
<li><strong>push插入元素作为头结点</strong></li>
<li><strong>offer插入节点到链表末尾，相当于入队操作</strong></li>
</ol>
<p><strong>peek和pop方法的区别是：</strong>peek方法和pop方法都是返回头节点的元素，但是<strong><font color="red">peek方法不会删除头结点只返回null，而pop方法会删除头节点（相当于出栈）</font></strong></p>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><h3 id="底层实现和线程安全问题"><a href="#底层实现和线程安全问题" class="headerlink" title="底层实现和线程安全问题"></a>底层实现和线程安全问题</h3><ul>
<li>ArrayList<ul>
<li>底层数据结构是数组。线程不安全</li>
</ul>
</li>
<li>LinkedList<ul>
<li>底层数据结构是链表。线程不安全</li>
</ul>
</li>
<li>Vector<ul>
<li>底层数据结构是数组。线程安全（方法都加上了<code>synchronized</code>同步锁）</li>
</ul>
</li>
</ul>
<h3 id="增删改查方面"><a href="#增删改查方面" class="headerlink" title="增删改查方面"></a>增删改查方面</h3><p><strong>总体来说：</strong></p>
<ul>
<li>ArrayList 查询和修改要比 LinkedList 快</li>
<li>LinkedList 增加和删除要比 ArrayList 快</li>
</ul>
<font color="red"><strong>注意：上面是总体而已，某些情况下不成立</strong></font>

<ol>
<li>如果<strong>删除元素是删除末尾元素</strong>的情况下，ArrayList 要比 LinkedList 快，因为 LinkedList 需要操作前后指针</li>
<li>如果<strong>删除的是中间的位置的元素</strong>，还是 ArrayList 快，因为 LinkedList 的折半查找法分别是从 头/尾 往中间找元素的，所以索引越靠近中间，LinkedList 的性能就越差</li>
<li>如果<strong>增加的元素一直都是在列表的最后增加</strong>， 那么 ArrayList 会比 LinkedList 快；此时的扩容操作占整体时间是很少的，而 LinkedList 还需要新建对象并且操作链表的前驱和后继节点</li>
</ol>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>​    <code>CopyOnWriteArrayList</code>是JUC包提供的线程安全的ArrayList，底层通过<strong>复制数组</strong>的方式来实现；<code>CopyOnWriteArrayList</code>在迭代器遍历的使用不会抛出<code>ConcurrentModificationException</code>异常（即没有快速失败机制），并且迭代器遍历的时候就不用额外加锁</p>
<p>​    copy-on-write是指写时复制；如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取<strong>相同的指针指向相同的资源</strong>，直到某个调用者<strong>试图修改</strong>资源的内容时，系统才会<strong>真正复制一份专用副本</strong>（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变</p>
<blockquote>
<p> <strong>优点</strong>是如果调用者<strong>没有修改该资源，就不会有副本</strong>（private copy）被建立，因此多个调用者只是读取操作时可以<strong>共享同一份资源</strong></p>
</blockquote>
<h3 id="大致结构-2"><a href="#大致结构-2" class="headerlink" title="大致结构"></a>大致结构</h3><ol>
<li><code>final transient ReentrantLock lock = new ReentrantLock()</code> 该列表通过 ReentrantLock 来实现加锁操作</li>
<li><code>private transient volatile Object[] array</code> CowArrayList用来存储数据的数组</li>
</ol>
<h3 id="对数组的修改操作"><a href="#对数组的修改操作" class="headerlink" title="对数组的修改操作"></a>对数组的修改操作</h3><h4 id="add-2"><a href="#add-2" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制一个新的数组，新增操作在新数组上完成</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//将新数组设置到 array 上</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CowArrayList通过复制一个新数组，并且<strong>增加操作在新数组上完成</strong>，最后将array指向到新数组中；跟ArrayList的区别就是：</p>
<ul>
<li>CowArrayList有加锁操作</li>
<li>CowArrayList新增的操作在复制好的新数组上完成，而ArrayList是在原数组上完成</li>
</ul>
<p>CowArrayList的<code>set()</code>、<code>remove()</code>操作都类似<code>add()</code>操作，都是在新数组上完成操作后将array指向新数组</p>
<h3 id="剖析迭代器"><a href="#剖析迭代器" class="headerlink" title="剖析迭代器"></a>剖析迭代器</h3><p>​    因为<code>CopyOnWriteArrayList</code>在迭代器遍历的使用不会抛出<code>ConcurrentModificationException</code>异常，并且迭代器遍历的时候就不用额外加锁；这个原因就在于<code>CopyOnWriteArrayList</code>在使用迭代器的时候，保存了一份原数组的副本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//原数组的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">//游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList调用 iterator() 执行的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList的迭代器不支持一下方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见：</p>
<p>​    在调用迭代器的方法时，迭代器会保存一份原数组的副本，即<code>snapshot</code>。该迭代器的所有操作都是对原数组进行操作，因此也就没有线程间的读写问题了，也就不需要快速失败机制和加锁操作了，所以<font color="red">CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong></font></p>
<h3 id="CopyOnWriteArrayList小结"><a href="#CopyOnWriteArrayList小结" class="headerlink" title="CopyOnWriteArrayList小结"></a>CopyOnWriteArrayList小结</h3><ul>
<li>如果 CopyOnWriteArrayList 需要经常增删改列表的数据，经常要执行<code>add()、set()、remove()</code>的话，那是比较耗费内存的（因为都需要复制一个新数组进行增删改）</li>
<li><strong>数据一致性</strong>：<font color="red">CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong></font></li>
<li>相对于ArrayList和Vector来说，遍历数组时不会受其他线程对数组操作而造成影响（读的是原数组的副本）</li>
</ul>
<blockquote>
<p>Set 对应的是 CopyOnWriteArraySet</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/跨域请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/跨域请求/" itemprop="url">跨域请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T21:33:24+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>​    <strong>跨域请求</strong>就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为如果协议 + 域名 + 端口号均相同，那么就是同域，否则则是跨域的</p>
<p>​    跨域请求是由于浏览器的<font color="red"><strong>同源策略</strong></font>导致的，浏览器的同源策略是不能没有的（同源策略是浏览器最核心最基础的安全策略）</p>
<ol>
<li><strong>同源策略禁止 Ajax 直接发起跨域HTTP请求（其实可以发送请求，结果被浏览器拦截，不展示），同时 Ajax 请求不能携带与本网站不同源的 Cookie</strong>；如果没有同源策略别的域名就可以拿到你浏览器上其他的Cookie信息，这样会导致很多重要的信息泄露，例如不法的网站可能会利用你的cookie去登录一些网站，盗用你的信息等。</li>
<li>DOM 层面的同源策略限制了来自不同源的<code>Document</code>对象或 JS 脚本，对当前<code>document</code>对象的读取或设置某些属性；没有同源策略，一些脚本就能获取到你的用户密码输入框的内容信息</li>
</ol>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>​    JSONP 是一种非官方的跨域数据交互协议；JSONP 本质上是利用 <script><img><iframe> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输</p>
<p>​    <strong>JSONP 的理念就是</strong>：与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段<code>Javascript</code>，在这段  <code>Javascript</code> 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 <code>Javascript</code> 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了</p>
<p>​    JSONP<strong><font color=red>只支持 get请求，只支持 get请求，只支持 get请求</font></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果使用了springmvc 3.2以上的版本 和5.0以下的版本可以配置一个jsonp 的 Advice 就可以了</span></span><br><span class="line"><span class="comment">  *   spring会自动做相应的处理</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  注意：springboot2.0以上舍弃了AbstractJsonpResponseBodyAdvice</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonPAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonPAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样如果请求中带 callback 参数，Spring 就知道这个是 jsonp 的请求了</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"callback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * JsonP 只支持get方法</span></span><br><span class="line"><span class="comment">  * 需要配置dataType为 jsonp</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJsonP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"get"</span>,</span><br><span class="line">        url:<span class="string">"http://localhost:8088/getJsonP/value.do"</span>,</span><br><span class="line">        dataType:<span class="string">"jsonp"</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(data.userName);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(<span class="string">"错误了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>​    跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制</p>
<h4 id="CORS新增的HTTP头信息"><a href="#CORS新增的HTTP头信息" class="headerlink" title="CORS新增的HTTP头信息"></a>CORS新增的HTTP头信息</h4><ol>
<li><p>Access-Control-Allow-Origin  <origin> | *</p>
<blockquote>
<p>​    响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源</p>
<p>​    origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Methods  <method>[…, <method>] | *</p>
<blockquote>
<p>该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Headers  <field-name>[…, <field-name>] | *</p>
<blockquote>
<p>该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Credentials  true | false</p>
<blockquote>
<p>表示是否允许发送Cookie</p>
<p>​    <strong>注意：</strong>如果需要在 Ajax 中设置和获取 Cookie，那么<code>Access-Control-Allow-Origin</code>首部字段不能设置为<code>*</code> ，必须设置为具体的 origin 源站</p>
</blockquote>
</li>
</ol>
<h4 id="Configuration配置方式"><a href="#Configuration配置方式" class="headerlink" title="Configuration配置方式"></a>Configuration配置方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果使用了springmvc4.2以上的版本，直接使用mvc相关配置即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * springboot 2.0 以上的版本中 WebMvcConfigurerAdapter 已经过时了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  可以实现 WebMvcConfigurer 来达到相同的目的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//addMapping是指定支持跨域的路径     </span></span><br><span class="line">      	registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">              <span class="comment">//如果前端不带cookie过来或者不限制域访问的话，那么设置 .allowedOrigins("*") 即可</span></span><br><span class="line">              <span class="comment">//.allowedOrigins("*")</span></span><br><span class="line">              .allowedOrigins(<span class="string">"http://localhost:8001"</span>, <span class="string">"http://localhost:8002"</span>)</span><br><span class="line">              .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</span><br><span class="line">              .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * crossDomain: true，这里代表使用跨域请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  xhrFields: &#123;withCredentials: true&#125;</span></span><br><span class="line"><span class="comment"> *      这样配置就可以把 cookie 带过去了,不然我们连 session 都没法维护</span></span><br><span class="line"><span class="comment"> *      当然,如果你没有这个需求,也就不需要配置这个了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    注意：如果配置了true 需要带cookie信息过去的话,后端的Access-Control-Allow-Origin不能配置成 *</span></span><br><span class="line"><span class="comment"> *           需要配置为具体的 origin 源站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"POST"</span>,</span><br><span class="line">        url:<span class="string">"http://localhost:8088/getCors/value.do"</span>,</span><br><span class="line">        dataType:<span class="string">"json"</span>,</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        xhrFields: &#123;</span><br><span class="line">            withCredentials: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(data.userName);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(<span class="string">"错误了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CrossOrigin注解方式"><a href="#CrossOrigin注解方式" class="headerlink" title="CrossOrigin注解方式"></a>CrossOrigin注解方式</h4><p>​    <strong>除了Configuration的配置方式外，springMVC4.2之后的版本都支持注解的方式</strong>，可以使用<code>@CrossOrigin</code> 注解来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CrossOrigin &#123;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Origin 是 '*'</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] DEFAULT_ORIGINS = <span class="keyword">new</span> String[]&#123;<span class="string">"*"</span>&#125;;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Headers 是 ‘*’</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] DEFAULT_ALLOWED_HEADERS = <span class="keyword">new</span> String[]&#123;<span class="string">"*"</span>&#125;;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Credentials 是false;即不允许发送cookie</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">boolean</span> DEFAULT_ALLOW_CREDENTIALS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//默认在1800秒内，不需要发出第二次预检请求</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">long</span> DEFAULT_MAX_AGE = <span class="number">1800L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"origins"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] origins() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] allowedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] exposedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] methods() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">allowCredentials</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">maxAge</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CrossOrigin 注解可以作用在整个Controller上或者作用在方法上</span></span><br><span class="line"><span class="comment"> *      作用在类上是：表示支持拦截整个controller的接口</span></span><br><span class="line"><span class="comment"> *      作用在方法上是：表示支持拦截指定的接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      配置中value和origins等价,均为配置Access-Control-Allow-Origin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CrossOrigin</span>(origins = &#123;<span class="string">"http://localhost:8001"</span>, <span class="string">"http://localhost:8002"</span>&#125;,</span><br><span class="line">            methods = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE&#125;,</span><br><span class="line">            allowCredentials = <span class="string">"true"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getCors"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/value.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsUser <span class="title">getCors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsUser(<span class="string">"我是Cors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpServletResponse方式"><a href="#HttpServletResponse方式" class="headerlink" title="HttpServletResponse方式"></a>HttpServletResponse方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getCors"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/value.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsUser <span class="title">getCors</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsUser(<span class="string">"我是Cors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JsonP和CORS的比较"><a href="#JsonP和CORS的比较" class="headerlink" title="JsonP和CORS的比较"></a>JsonP和CORS的比较</h3><ol>
<li><code>JSONP</code> 只能实现 GET 请求，而 <code>CORS</code> 支持所有类型的 HTTP 请求</li>
<li>使用 CORS 可以使用普通的 XMLHttpRequest 发起请求和获取数据，比 JSONP 有更好的错误处理</li>
<li>CORS 的兼容性比不上 JSONP，一些比较老的浏览器只支持 JSONP</li>
</ol>
</script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/分布式锁及其实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/分布式锁及其实现/" itemprop="url">分布式锁及其实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T19:53:58+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了</p>
<p>​    在分布式场景下，CAP理论已经证明了任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项；所以为了保证在分布式环境下的数据最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</p>
<h3 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h3><ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行 </li>
<li>高可用、高性能的获取锁与释放锁</li>
<li>具备可重入特性</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ol>
<h2 id="分布式锁的三种实现方案"><a href="#分布式锁的三种实现方案" class="headerlink" title="分布式锁的三种实现方案"></a>分布式锁的三种实现方案</h2><h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><p>​    数据库实现分布式锁主要是依赖<strong>唯一索引</strong></p>
<p>（唯一索引：<u>不允许具有索引值相同的行，从而禁止重复的索引或键值</u>。数据库会在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句时进行检查）</p>
<p>​    <font color="green"><strong>实现的思路：</strong></font>在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，因为做了唯一索引，所以即使多个请求同时提交到数据库，都只会保证只有一个操作能够成功，插入成功则获取到该方法的锁，执行完成后删除对应的行数据释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`distributed_lock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'方法名(需要锁住的方法名)'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,  </span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`index_method_name`</span> (<span class="string">`method_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<h4 id="数据库实现分布式锁的增强"><a href="#数据库实现分布式锁的增强" class="headerlink" title="数据库实现分布式锁的增强"></a>数据库实现分布式锁的增强</h4><ol>
<li><font color="blue">该分布式锁依赖数据库的可用性</font>，如果数据库是单点且挂掉，那么分布式锁功能失效<ul>
<li><strong>解决方案：</strong><ul>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">同一个线程在释放锁之前，行数据一直存在，无法再次插入数据；这种情况下该分布式锁不具备可重入性</font><ul>
<li><strong>解决方案</strong>：在表中新增一列用于记录当前获取到锁的机器和线程信息，在该线程再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁</li>
</ul>
</li>
<li><font color="blue">没有锁失效的机制可能会出现在获取锁之后，数据库宕机，对应的行数据没有被删除，等到数据库服务器恢复后，表中的数据仍然存在，从而无法再获取到锁；或者释放锁失败</font><ul>
<li><strong>解决方案</strong>：<ul>
<li>在表中新增一列，用于记录失效时间，并且需要有<strong>定时任务</strong>清除这些失效的数据；此时也需要根据业务需求考虑定时任务的执行时间，不能过长或者过短</li>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">阻塞锁特性</font>，在代码逻辑中增加失败重试机制（while循环），根据业务需求多次去获取锁直到成功或者达到失败次数后返回等等</li>
</ol>
<h4 id="数据库实现分布式锁的问题"><a href="#数据库实现分布式锁的问题" class="headerlink" title="数据库实现分布式锁的问题"></a>数据库实现分布式锁的问题</h4><p>​    虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。</p>
<p>​    但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁</p>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><font color="green"><strong>实现思路</strong></font>：<br><br>- setnx：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0<br><br>1. 获取锁的时候，使用setnx加锁，锁的value值可以是一个随机生成的UUID，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁<br>2. 获取锁的时候设置一个获取锁的超时时间，若超过这个时间则放弃获取锁<br>3. 释放锁的时候，通过随机生成的UUID去匹对锁的键值对是否对应，若是则执行delete释放锁<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 存放redis中的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeOut 分布式锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">lockWithTimeOut</span><span class="params">(String lockName, <span class="keyword">int</span> acquireTimeOut, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先setnx key是否成功;</span></span><br><span class="line"><span class="comment">         *      成功则设置随机值(UUID),然后设置过期时间,返回随机值给释放锁用</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      失败则计算获取锁的超时时间,时间未到则自旋获取锁直到成功或者达到超时时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String identifier = UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        timeout = System.currentTimeMillis() + timeout;</span><br><span class="line">        String reIdentifier = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//带超时时间的循环获取锁实现锁阻塞特性</span></span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() &lt; timeout)&#123;</span><br><span class="line">                Long setnx = jedis.setnx(lockName, identifier);</span><br><span class="line">                <span class="keyword">if</span> (setnx != <span class="keyword">null</span> &amp;&amp; setnx == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//设置过期时间</span></span><br><span class="line">                    jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    reIdentifier = identifier;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//这一步很重要   </span></span><br><span class="line">                 <span class="comment">//如果key已经存在,查看过期时间,如果该key无过期时间则重新设置过期时间,以免发生死锁</span></span><br><span class="line">                    Long ttl = jedis.ttl(lockName);</span><br><span class="line">                    <span class="keyword">if</span> (ttl == -<span class="number">1</span>)&#123;</span><br><span class="line">                        jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程中断"</span>);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 锁的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifier 锁的标识(用来验证锁中的val是否一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockName, String identifier)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            jedis.watch(lockName);</span><br><span class="line">            String result = jedis.get(lockName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; identifier.equals(result))&#123;</span><br><span class="line">                Transaction multi = jedis.multi();</span><br><span class="line">                multi.del(lockName);</span><br><span class="line">                List&lt;Object&gt; exec = multi.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec != <span class="keyword">null</span> &amp;&amp; exec.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### Redis分布式锁的增强<br><br>1. <font color="blue"><strong>锁失效时间</strong></font><br>   - 锁失效的时间需要根据实际业务需求来设置一个合适的值<br>   - <strong><font color="red">如果设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题</font></strong><br>   - <strong>如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间</strong><br>2. <font color="blue">可利用while循环去获取锁，可以设置重试间隔时间和最大重试时间来实现锁阻塞特性</font><br>3. <font color="blue">不可重入</font><br>   - <strong>解决方案</strong>：<br>     - 线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者；释放锁的时候将这些信息删除<br>4. <font color="blue">单点故障</font><br>   - <strong>解决方案：</strong><br>     - Redis集群，Redis主从<br><br><br><br>#### Redis实现分布式锁存在的问题<br><br>​    这类最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：<br><br>1. 在Redis的master节点上拿到了锁<br>2. 但是这个加锁的key还没有同步到slave节点<br>3. master故障，发生故障转移，slave节点升级为master节点<br>4. 导致锁丢失<br><br><br><br>### Zookeeper实现分布式锁<br><br><font color="green"><strong>实现思路：</strong></font>

<p>​    每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的<strong>瞬时有序节点</strong>（EPHEMERAL_SEQUENTIAL）</p>
<p>​    使用Zookeeper可以实现的分布式锁是阻塞的，客户端可以通过在ZK中创建瞬时有序节点，并且在节点上绑定监听器，一旦节点发生变化，ZK会通知客户端，客户端可以检查自己创建的节点是不是<strong><font color="red">当前所有节点中序号最小的</font></strong>，如果是那么自己就获取到锁，反之则继续等待</p>
<p>​     当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题，因为<strong>瞬时节点在会话断开后就会自动删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zookeeper 实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK对象</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分布式锁的根节点</span></span><br><span class="line">    <span class="keyword">private</span> String rootLockNode;</span><br><span class="line">    <span class="comment">// 竞争资源，用来生成子节点名称</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="comment">// 当前锁</span></span><br><span class="line">    <span class="keyword">private</span> String currentLock;</span><br><span class="line">    <span class="comment">// 等待的锁（前一个锁）</span></span><br><span class="line">    <span class="keyword">private</span> String waitLock;</span><br><span class="line">    <span class="comment">// 计数器（用来在加锁失败时阻塞加锁线程）</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造器中创建ZK链接，创建锁的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkAddress     ZK的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rootLockNode  根节点名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName      子节点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperLock</span><span class="params">(String zkAddress, String rootLockNode, String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootLockNode = rootLockNode;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建连接，zkAddress格式为：IP:PORT</span></span><br><span class="line"><span class="comment">             * watcher监听器为自身</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(zkAddress, <span class="keyword">this</span>.sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测锁的根节点是否存在，不存在则创建</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Stat stat = zk.exists(rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == stat) &#123;</span><br><span class="line">                zk.create(rootLockNode, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法，先尝试加锁，不能加锁则等待上一个锁的释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】加锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> waitOtherLock(<span class="keyword">this</span>.waitLock, <span class="keyword">this</span>.sessionTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分隔符</span></span><br><span class="line">        String split = <span class="string">"_lock_"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lockName.contains(<span class="string">"_lock_"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"lockName can't contains '_lock_' "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建锁节点（临时有序节点）并且得到节点名称</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * path: 根节点/子锁名称+分隔符</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.currentLock = zk.create(<span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + <span class="keyword">this</span>.lockName + split, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>],</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"】创建锁节点（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功，开始竞争..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(<span class="keyword">this</span>.rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有正在竞争lockName的锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; lockNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String nodeName : nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodeName.split(split)[<span class="number">0</span>].equals(<span class="keyword">this</span>.lockName)) &#123;</span><br><span class="line">                    lockNodes.add(nodeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(lockNodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取最小节点与当前锁节点比对加锁</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *      比对最小节点的名称是否跟刚才创建的临时节点名称一致</span></span><br><span class="line"><span class="comment">             *      一致则证明当前加锁成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockPath = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + lockNodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.currentLock.equals(currentLockPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁失败，设置前一节点为等待锁节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockNode = <span class="keyword">this</span>.currentLock.substring(<span class="keyword">this</span>.currentLock.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> preNodeIndex = Collections.binarySearch(lockNodes, currentLockNode) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.waitLock = lockNodes.get(preNodeIndex);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁，带超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitLock          当前节点的前一个锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionTimeout    等待获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitOtherLock</span><span class="params">(String waitLock, <span class="keyword">int</span> sessionTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> islock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 监听等待锁节点</span></span><br><span class="line">            String waitLockNode = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + waitLock;</span><br><span class="line">            Stat stat = zk.exists(waitLockNode, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"】锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败，等待锁（"</span> + waitLockNode + <span class="string">"）释放..."</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 设置计数器，使用计数器阻塞线程,带超时时间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                islock = <span class="keyword">this</span>.countDownLatch.await(sessionTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (islock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁成功，锁（"</span> + waitLockNode + <span class="string">"）已经释放"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                islock = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat stat = zk.exists(<span class="keyword">this</span>.currentLock, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】释放锁 "</span> + <span class="keyword">this</span>.currentLock);</span><br><span class="line">                zk.delete(<span class="keyword">this</span>.currentLock, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.currentLock = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点监听器回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听节点删除的事件</span></span><br><span class="line"><span class="comment">         *      计数器减一，恢复线程操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.countDownLatch &amp;&amp; watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Curator的分布式锁"><a href="#Curator的分布式锁" class="headerlink" title="Curator的分布式锁"></a>Curator的分布式锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator 实现的分布式锁:</span></span><br><span class="line"><span class="comment"> *          InterProcessMutex:          分布式可重入排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessSemaphoreMutex: 分布式排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessReadWriteLock:  分布式读写锁</span></span><br><span class="line"><span class="comment"> *          InterProcessMultiLock:      将多个锁作为单个实体管理的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置重试策略，创建zk客户端</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = </span><br><span class="line">            CuratorFrameworkFactory.newClient(<span class="string">"127.0.0.1:2181"</span>, retryPolicy);</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建分布式可重入排他锁，监听客户端为client，锁的根节点为/locks</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InterProcessMutex mutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/locks"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁操作</span></span><br><span class="line"><span class="comment">             *     public boolean acquire(long time, TimeUnit unit)</span></span><br><span class="line"><span class="comment">             *          第一个参数是超时时间</span></span><br><span class="line"><span class="comment">             *          第二个参数是时间的单位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.acquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 释放锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK实现分布式锁的问题"><a href="#ZK实现分布式锁的问题" class="headerlink" title="ZK实现分布式锁的问题"></a>ZK实现分布式锁的问题</h4><p>​    <strong>使用Zookeeper也有可能带来并发问题：</strong>由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了，就可能产生并发问题。</p>
<p>​    这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，<font color="red">Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点（所以选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡）</font></p>
<h3 id="三者的比较"><a href="#三者的比较" class="headerlink" title="三者的比较"></a>三者的比较</h3><ol>
<li><strong>从性能角度（从高到低）</strong><ul>
<li>缓存 &gt; Zookeeper &gt;= 数据库</li>
</ul>
</li>
<li><strong>从可靠性角度（从高到低）</strong><ul>
<li>Zookeeper &gt; 缓存 &gt; 数据库</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/Linux操作系统的五种IO模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/Linux操作系统的五种IO模型/" itemprop="url">Linux操作系统的五种IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T21:23:09+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux操作系统的五种IO模型</p>
<h3 id="Linux系统的IO"><a href="#Linux系统的IO" class="headerlink" title="Linux系统的IO"></a>Linux系统的IO</h3><p>​    Java中常说的IO是指文件的输入和输出；而在操作系统中的一次IO可以简化成把数据从硬件（硬盘）中读取到用户空间中；详细分为<font color="blue">两个阶段</font></p>
<ul>
<li>将数据从磁盘文件先加载到内核内存空间（缓存区），等待数据准备完成，此过程时间较长。（准备数据的阶段）</li>
<li>然后将数据从内核缓冲区复制到用户空间的进程内存中，此过程时间较短（拷贝数据阶段）</li>
</ul>
<p>在了解五种模型前先知道一些名词</p>
<ul>
<li><p>同步/异步：关注点是消息的通信机制</p>
<ul>
<li>同步：调用者等到被调用者返回消息，才能继续往下执行</li>
<li>异步：被调用者通过状态、通知或者回调机制主动通知调用者当前被调用者的状态</li>
</ul>
</li>
<li><p>阻塞/非阻塞：关注点是调用者在等待结果返回之前所处的状态</p>
<ul>
<li>阻塞：指在IO操作彻底完成后才返回到用户空间，在获得调用结果之前被挂起</li>
<li>非阻塞：指在发起IO操作后立即返回给用户一个状态值，无须等到IO操作彻底完成才返回；在调用结果返回之前，用户进程不会被挂起</li>
</ul>
</li>
<li><p>文件描述符FD</p>
<blockquote>
<p>​    文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数</p>
<p>​    实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符</p>
<p>​    在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</p>
</blockquote>
</li>
</ul>
<h3 id="同步阻塞IO模型"><a href="#同步阻塞IO模型" class="headerlink" title="同步阻塞IO模型"></a>同步阻塞IO模型</h3><p>​    同步阻塞UI模型是最简单的IO模型，用户线程在内核进行IO操作的时候被阻塞；用户线程通过系统调用<code>recvfrom</code> 发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，再将接受的数据拷贝到用户空间，这才能完成一次读操作。</p>
<p>​    但是用户在进行读操作的时候，由于内核还不能立刻准备好数据包，应用进程就会阻塞住，直到内核准备好数据包，<code>recvfrom</code> 完成数据报复制工作，应用进程才能结束阻塞状态；这就导致用户在发起IO请求时，不能再进行其他任何操作，这<strong><font color="red">对CPU的资源利用率是很低的</font></strong></p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/同步阻塞IO模型.jpg" alt="同步阻塞IO模型"></p>
<h3 id="同步非阻塞IO模型"><a href="#同步非阻塞IO模型" class="headerlink" title="同步非阻塞IO模型"></a>同步非阻塞IO模型</h3><p>​    用户线程在发起IO请求后立即返回，但是此时并没有读取到任何数据，用户线程需要不断的通过 <code>recvfrom</code> 调用去和内核交互，直到内核准备好数据（即轮询机制）。如果没有准备好，内核会返回<code>error</code>，应用进程在得到<code>error</code>后，过一段时间再发送<code>recvfrom</code>请求。在两次发送请求的时间段，进程可以先做别的事情</p>
<p>​    整个IO请求的过程，虽然用户线程立即返回了，但是为了得到数据还是需要通过轮询机制去请求是否准备好数据；重复的请求会<strong><font color="red">消耗大量的CPU资源</font></strong>，一般很少会直接使用这个模型</p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/同步非阻塞IO模型.jpg" alt="同步非阻塞IO模型"></p>
<h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>​    用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序返回不会阻塞；当有IO操作准备就绪时，由内核通知触发一个SIGIO信号处理程序执行，然后将用户进程再通过<code>recvfrom</code>将数据从内核空间拷贝到用户空间（数据拷贝是同步的）</p>
<p>​    这种模型的优势在于等到数据包到达期间进程不会被阻塞，用户主程序可以继续执行，只要等待来自信号处理函数的通知即可（此模式实现复杂，不常用）</p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/信号驱动IO模型.jpg" alt="信号驱动IO模型"></p>
<h3 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h3><p>​    多个进程的IO可以注册到同一个<code>select</code>上，当用户进程调用该<code>select</code>，<code>select</code>会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，<strong>进程调用<code>select</code>后会阻塞</strong>；当任意一个IO所需的数据准备好之后，<code>select</code>调用就会返回，然后用户进程在通过<code>recvfrom</code>来进行数据拷贝</p>
<p>​    虽然<code>select</code>可以同时监控多个IO操作，但是<strong>每个IO请求过程还是会阻塞（阻塞在select函数）</strong>的；进程在发出<code>select</code>后，要等到<code>select</code>监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝</p>
<p>​    所以<strong>如果处理的连接数不是很高的话</strong>，使用<strong>IO多路复用不一定</strong>比使用<strong>多线程 + 阻塞 IO</strong>的性能更好，可能延迟还更大。<font color="red">IO多路复用的优势并不是对于单个连接能处理得更快，而是在于能<strong>处理更多的连接</strong></font></p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/IO多路复用模型.jpg" alt="IO多路复用模型"></p>
<h4 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h4><p><code>select</code>，<code>poll</code>，<code>epoll</code> 都是多路复用IO的函数；其三者的区别在于：</p>
<ol>
<li><font color="green"><strong>select</strong></font><ul>
<li>select函数会无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</li>
<li>其缺点在于单个进程<strong>能够监视的文件描述符的数量存在最大限制</strong>，在Linux上32位机默认是1024个，64位机默认是2048。也可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低</li>
</ul>
</li>
<li><font color="green"><strong>poll</strong></font><ul>
<li>poll本质上和select没有区别， <strong><font color="blue">但是它没有最大连接数的限制</font></strong>，原因是它是基于链表来存储的（select是数组存储）</li>
</ul>
</li>
<li><font color="green"><strong>epoll</strong></font><ul>
<li>epoll是通过事件通知的方式（事件关联上fd），只要有可写的IO就会通过回调的方式告知用户进程</li>
<li>epoll的最大连接数也是没有限制的，其基于哈希表来存储</li>
</ul>
</li>
</ol>
<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>​    用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，<strong>直接把数据拷贝到用户空间</strong>，然后再通知进程本次IO已经完成</p>
<p>​    相比于IO多路复用，异步IO并不常用，更多的服务程序会使用IO多路复用模型 + 多线程任务处理的架构来满足业务需求</p>
<p><strong>异步IO与信号驱动最主要的区别是</strong></p>
<ol>
<li>信号驱动IO是由内核通知用户进程何时进行IO操作，而异步IO是内核把数据拷贝到用户空间后才通知用户进程IO操作何时完成</li>
<li>信号驱动还需要用户进程阻塞在从内核空间缓冲区拷贝数据到用户空间，而异步IO是内核直接把所有数据准备好并且拷贝到用户空间后才通知用户进程可以进行后续的操作；<font color="red"><strong>即数据准备阶段两者都是非阻塞的，而数据拷贝阶段，信号驱动是阻塞的而异步IO是非阻塞的</strong></font></li>
</ol>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/异步IO模型.jpg" alt="异步IO模型"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/正向代理和反向代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/正向代理和反向代理/" itemprop="url">正向代理和反向代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T21:23:20+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正向代理和反向代理</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​    正向代理是一个<font color="red">位于客户端和原始服务器</font>（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p>​    <strong>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互</strong>；客户端必须要进行一些特别的设置才能使用正向代理</p>
<p>​    举个栗子：一个国内用户访问不了Google，但是他能访问到一个代理服务器，这个代理服务器能够访问Google，于是该用户需要先连上代理服务器，然后告诉代理服务器需要访问哪个网站的内容，代理服务器去将网站内容取回来，然后返回给用户。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉访问的网站</p>
<h4 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h4><ol>
<li><p><strong>突破访问限制</strong> </p>
<p>​    通过代理服务器，可以突破自身IP访问限制，访问国外网站等</p>
</li>
<li><p><strong>提高访问速度</strong></p>
<p>​    通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度</p>
</li>
<li><p><strong>隐藏客户端真实IP</strong></p>
<p>​    上网者也可以通过这种方法隐藏自己的IP，免受攻击</p>
</li>
</ol>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​    反向代理（Reverse Proxy）是指以代理服务器来接受Internet上的连接请求，然后<font color="red">将请求转发给<strong>内部网络</strong>上的服务器</font>，并将从服务器上得到的结果返回给Internet上请求连接的客户端，<u>此时代理服务器对外就表现为一个服务器</u></p>
<p>​    <strong>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互</strong>；通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理</p>
<h4 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h4><ol>
<li><p><strong>隐藏服务器真实IP</strong></p>
<p>​    使用反向代理，可以对客户端隐藏服务器的IP地址</p>
</li>
<li><p><strong>负载均衡</strong></p>
<p>​    反向代理服务器可以做负载均衡</p>
<p>​    根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</p>
</li>
<li><p><strong>提高访问速度</strong></p>
<p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容<strong><font color="blue">提供缓存服务</font></strong>，提高访问速度</p>
</li>
<li><p><strong>提供安全保障</strong></p>
<p>​    反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</p>
<p>​    还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</p>
</li>
</ol>
<h3 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h3><ol>
<li><p><strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源</p>
<p><strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等</p>
</li>
</ol>
<ol start="2">
<li><p><strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件</p>
<p><strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器</p>
</li>
</ol>
<ol start="3">
<li><p><strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端</p>
<p><strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器</p>
</li>
</ol>
<ol start="4">
<li><p><strong>正向代理主要是用来解决访问限制问题</strong></p>
<p><strong>反向代理则是提供负载均衡、安全防护等作用</strong></p>
</li>
</ol>
<p>图片来源：<a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">https://www.zhihu.com/question/24723688</a></p>
<p><img src="/2019/05/06/正向代理和反向代理/代理.png" alt="代理"></p>
<h3 id="Java获取用户的IP地址"><a href="#Java获取用户的IP地址" class="headerlink" title="Java获取用户的IP地址"></a>Java获取用户的IP地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的真实ip地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRealIpAdrress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ipAdrress = <span class="string">""</span>;</span><br><span class="line">        String forwardFor = request.getHeader(<span class="string">"X-Forwarded-For"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!T.isBlank(forwardFor) &amp;&amp; !<span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            <span class="comment">//多次反向代理后会有多个ip值，第一个ip才是真实ip</span></span><br><span class="line">            <span class="keyword">int</span> index = forwardFor.indexOf(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">                ipAdrress = forwardFor.substring(<span class="number">0</span>,index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ipAdrress = forwardFor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"Proxy-Client-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"WL-Proxy-Client-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"X-Real-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"HTTP_CLIENT_IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"HTTP_X_FORWARDED_FOR"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipAdrress;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="getRemoteAddr"><a href="#getRemoteAddr" class="headerlink" title="getRemoteAddr"></a>getRemoteAddr</h4><p>​    <code>request.getRemoteAddr()</code>获取客户端的ip地址</p>
<p>​    但是如果使用了反向代理软件，例如Nginx，用request.getRemoteAddr()方法获取的IP地址都会是反向代理服务器的ip，而并不是客户端的真实IP。<br>​    经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了<strong>X-Forwarded-For</strong>信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址</p>
<h4 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-<strong>For</strong></h4><p>​    X-Forwarded-For是用来识别通过<font color="red"><strong>HTTP代理或负载均衡</strong></font>方式连接到Web服务器的客户端<font color="blue">最原始的IP地址</font>的HTTP请求头字段</p>
<p>​    如果有配置X-Forwarded-For设置的话，每次经过proxy转发都会有记录，格式就是：</p>
<p>（client1, proxy1, proxy2） 以逗号隔开各个地址（client指客户端IP，proxy指反向代理服务器的IP）</p>
<p>即设置了X-Forwarded-For，取逗号分隔的第一项即为客户端的IP</p>
<p>在代理转发及反向代理中经常使用X-Forwarded-For 字段</p>
<ol>
<li><p>代理转发（正向代理）</p>
<blockquote>
<p>​    在代理转发的场景中，你可以通过内部代理链以及记录在网关设备上的IP地址追踪到网络中客户端的IP地址</p>
<p>​    处于安全考虑，网关设备在把请求发送到外网（因特网）前，应该<font color="red"><strong>去除 X-Forwarded-For 字段里的所有信息</strong></font></p>
<p>​    这种情况下所有的信息都是在你的内部网络内生成，因此X-Forwarded-For字段中的信息应该是可靠的</p>
</blockquote>
</li>
<li><p>反向代理</p>
<blockquote>
<p>​    在反向代理的情况下，你可以追踪到互联网上连接到你的服务器的客户端的IP地址，即使你的网络服务器和互联网在路由上是不可达的</p>
<p>​    这种情况下你不应该信任所有X-Forwarded-For信息，其中有部分可能是伪造的。因此需要建立一个信任白名单来确保X-Forwarded-For中哪些IP地址对你是可信的</p>
<p>​    最后一次代理服务器的地址并没有记录在代理链中，因此只记录 X-Forwarded-For 字段是不够的。完整起见，Web服务器应该记录请求来源的IP地址以及X-Forwarded-For 字段信息</p>
</blockquote>
</li>
</ol>
<h5 id="X-Forwarded-For-和-X-Real-IP-区别"><a href="#X-Forwarded-For-和-X-Real-IP-区别" class="headerlink" title="X-Forwarded-For 和 X-Real-IP**    区别"></a>X-Forwarded-For<strong> 和 </strong>X-Real-IP**    区别</h5><p>​    X-Real-IP如果经过多级代理的情况下，其记录的IP不一定是真实的客户端IP；如果有多级代理，x-forwarded-for效果是大于x-real-ip的，可以记录完整的代理链路</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/Zookeeper小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/Zookeeper小结/" itemprop="url">zookeeper小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T11:18:00+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Zookeeper？"><a href="#什么是Zookeeper？" class="headerlink" title="什么是Zookeeper？"></a>什么是Zookeeper？</h2><p>​        Zookeeper是一个开源的<strong>分布式的，为分布式应用提供协调服务</strong>的Apache项目。</p>
<p>​        ZooKeeper是一个经典的<strong><font color="red">分布式数据一致性解决方案</font></strong>，致力于为分布式应用提供一个高性能、高可用，且具有<strong>严格顺序访问</strong>控制能力的分布式协调服务</p>
<p>​        分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负载均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。</p>
<h3 id="zookeeper的一些特点"><a href="#zookeeper的一些特点" class="headerlink" title="zookeeper的一些特点"></a>zookeeper的一些特点</h3><ol>
<li>顺序一致性：从同一个client客户端发来的请求，会按其发送的顺序来执行</li>
<li>原子性：一次数据处理要么全部成功，要么全部失败</li>
<li>数据一致性：每个Server保存一份相同的数据，客户端无论连接到哪个Server，数据都是一致的</li>
<li>实时性：在一定时间范围内，客户端能够读取到最新的数据</li>
</ol>
<h3 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h3><p>​        ZK会维护一个具有层次关系的树状的数据结构，每个树节点称为一个ZNode。每个ZNode默认能够存储1MB的数据，每个ZNode都可以通过路径唯一标识</p>
<p>​        一个ZNode既能在它下面创建子节点，作为路径标识的一部分，同时该节点也能存储数据；主要存放分布式应用的配置信息和状态信息等</p>
<p>​        每个ZNode节点都有各自的版本号，当节点数据发生变化是，那该节点的版本号也会累加（乐观锁的机制）</p>
<p><strong>节点类型</strong></p>
<ul>
<li>持久（Persistent）：客户端和服务器断开连接后，创建的节点不会被删除</li>
<li>短暂（Ephemeral）：客户端和服务器断开连接后，创建的节点会自动删除</li>
</ul>
<blockquote>
<p>​        创建ZNode节点的时候可以设置顺序标识，ZNode名称后会附加一个顺序号，这个顺序号是单调递增的计数器，并且是由父节点来维护的</p>
<p>​        注意：在分布式系统中，顺序号可以被用于所有事件的全局排序；客户端可以通过顺序号来推断事件的执行顺序</p>
</blockquote>
<h3 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h3><ol>
<li><p><strong>统一命名服务</strong></p>
<blockquote>
<p>在分布式环境下，对应用/服务进行统一的命名，会便于识别</p>
<p>对外只显示服务的名称，通过节点去访问对应IP的服务</p>
</blockquote>
</li>
<li><p><strong>统一配置管理</strong></p>
<blockquote>
<p>​        集群中一般要求所有节点的配置信息是一致的，例如Kafka集群。并且对配置文件修改后，能够快速更新到各个节点上</p>
<p>​        可以将配置信息写入ZNode中，各个客户端监听该配置信息的状态，一旦ZNode中的数据发生改变，可以及时通知各个客户端将最新的配置信息更新到系统中</p>
</blockquote>
</li>
<li><p><strong>统一集群管理</strong></p>
<blockquote>
<p>​        服务节点动态上下线，当ZK中注册的服务下线时，客户端能够实时的得到下线通知；这里可以通过ZK的监听器去监听节点的动态新增/删除</p>
</blockquote>
</li>
<li><p><strong>分布式锁</strong></p>
<blockquote>
</blockquote>
</li>
<li><p>软负载均衡</p>
<blockquote>
<p>ZK记录节点上的服务，可以让访问数最少的服务器去处理最新的客户端请求</p>
</blockquote>
</li>
</ol>
<h2 id="ZK安装"><a href="#ZK安装" class="headerlink" title="ZK安装"></a>ZK安装</h2><blockquote>
<p>​        注意：下面操作没有设置环境变量，如果设置的环境变量，那么可以在<strong>全局环境</strong>下直接使用zkServer.sh或者zkCli.sh</p>
<p>设置方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> vim /etc/profile</span><br><span class="line"><span class="meta">&gt;</span> export ZOOKEEPER_HOME=/opt/zookeeper</span><br><span class="line"><span class="meta">&gt;</span> export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ol>
<li><p>解压tar.gz文件到指定目录下（/opt）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制conf下的zoo_sample.cfg为新文件zoo.cfg，并且在zookeeper的主目录下创建data文件夹，并在配置文件中设置data目录和dataLog目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zookeeper/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">cd /opt/zookeeper</span><br><span class="line">mkdir data</span><br><span class="line">vim /opt/zookeeper/conf/zoo.cfg</span><br><span class="line">	dataDir=/opt/zookeeper/data</span><br><span class="line">	dataLogDir=/opt/zookeeper/dataLog</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zk</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span>关闭zk</span><br><span class="line">bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk的状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk进程是否启动</span><br><span class="line">jps</span><br><span class="line">	4020 Jps</span><br><span class="line">	4001 QuorumPeerMain</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h3><ol>
<li><p>在data目录下创建myid文件，在文件上添加ZK编号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch myid</span><br><span class="line">	1</span><br><span class="line"><span class="meta">#</span>#其他ZK的机子上需要添加不同的编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 zoo.cfg 配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta">	#</span>######################cluster##########################</span><br><span class="line">    server.1=zk1:2888:3888</span><br><span class="line">    server.2=zk2:2888:3888</span><br><span class="line">    server.3=zk3:2888:3888</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span>######################cluster##########################</span><br><span class="line">server.1=localhost:2881:3881</span><br><span class="line">server.2=localhost:2882:3882</span><br><span class="line">server.3=localhost:2883:3883</span><br></pre></td></tr></table></figure>
<p>配置文件解析：</p>
<ul>
<li>server后面的数字就是 myid 文件制定的编号</li>
<li>zk1 是你服务器的 ip 地址</li>
<li>2888 是zk集群的信息交换端口（不一定是2888，可自行指定）</li>
<li>3888 是zk集群中Leader节点挂了之后重新选择Leader节点时进行通信的端口（同样可自行选择其他端口）</li>
</ul>
</li>
</ol>
<h2 id="深入学习Zookeeper"><a href="#深入学习Zookeeper" class="headerlink" title="深入学习Zookeeper"></a>深入学习Zookeeper</h2><h3 id="ZK配置文件"><a href="#ZK配置文件" class="headerlink" title="ZK配置文件"></a>ZK配置文件</h3><ol>
<li><p>tickTime</p>
<p>通信心跳数，Zookeeper<strong>服务器与客户端</strong>心跳时间，单位毫秒</p>
<blockquote>
<p>​        Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒</p>
<p>​        它用于心跳机制，并且设置最小的session（会话）超时时间为两倍心跳时间（session的最小超时时间是2*tickTime）</p>
</blockquote>
</li>
<li><p>initLimit</p>
<p>集群中主从服务器之间的<strong>初始通信时限</strong></p>
<blockquote>
<p>​        集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限</p>
</blockquote>
</li>
<li><p>syncLimit</p>
<p>集群中主从服务器之间的<strong>同步通信时限</strong></p>
<blockquote>
<p>​        集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer</p>
</blockquote>
</li>
<li><p>dataDir</p>
<p>数据文件目录+数据持久化路径</p>
</li>
<li><p>dataLogDir</p>
<p>日志文件目录，如果不配置则使用dataDir的目录进行日志的存放</p>
</li>
<li><p>clientPort </p>
<p>监听客户端连接的端口，默认是2181</p>
</li>
</ol>
<h3 id="ZK集群"><a href="#ZK集群" class="headerlink" title="ZK集群"></a>ZK集群</h3><h4 id="选举机制中的基础概念"><a href="#选举机制中的基础概念" class="headerlink" title="选举机制中的基础概念"></a>选举机制中的基础概念</h4><ol>
<li><p>服务器ID</p>
<blockquote>
<p>即myid文件中的编号；编号越大，权重越大</p>
</blockquote>
</li>
<li><p>Zxid，数据ID</p>
<blockquote>
<p>服务器中存放的最大数据ID；值越大说明该数据越新，权重越大</p>
</blockquote>
</li>
<li><p>Epoch：逻辑时钟</p>
<blockquote>
<p>​    投票的次数（轮数），同一轮投票过程中的逻辑时钟值是相同的</p>
<p>​    每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断</p>
</blockquote>
</li>
<li><p>Server状态：选举状态</p>
<ul>
<li>LOOKING，竞选状态</li>
<li>FOLLOWING，随从状态，同步leader状态，参与投票</li>
<li>OBSERVING，观察状态,同步leader状态，不参与投票</li>
<li>LEADING，领导者状态</li>
</ul>
</li>
</ol>
<h4 id="选举简易流程"><a href="#选举简易流程" class="headerlink" title="选举简易流程"></a>选举简易流程</h4><p>​    目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ol>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于<strong>Looking（竞选状态）</strong></li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果；由于服务器2的编号比服务器1的大，所以服务器2胜出；但此时投票数没有大于半数，所以<strong>两个服务器的状态依然是LOOKING</strong></li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1和2交换信息，由于服务器3的编号最大，所以服务器3胜出，此时投票数正好<strong>大于半数</strong>，所以服务器3成为Leader，服务器1和2成为Follower，状态变成FOLLOWING</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但服务器3的状态已经是Leading，所以服务器4也是Follower</li>
<li>服务器5启动，逻辑同服务器4</li>
</ol>
<p><strong>几种情况的选举</strong></p>
<ol>
<li><p>一台宕机重启的机器加入已有环境，如果已有环境中已经存在Leader，那么该机器会变成Follwoer</p>
</li>
<li><p>一台机器加入正在投票中的环境</p>
<p>所有server都会接受优先级最高的投票，最高优先级最高的选票当选，选举结束</p>
</li>
<li><p>当集群中多数机器宕机重启</p>
<p>​    存活的服务发现不满足多数派，改变状态为LOOKING，投票轮数+1，然后重新开始投票，会按照优先级的选举投票直至结束</p>
<ul>
<li>逻辑时钟小的选举结果被忽略，重新投票</li>
<li>统一逻辑时钟后，数据 version 大的胜出</li>
<li>数据 version 相同的情况下，server id 大的胜出</li>
</ul>
</li>
</ol>
<p>以上，只要有超过半数的机器存活，最终会完成投票</p>
<h4 id="选举机制（半数机制）"><a href="#选举机制（半数机制）" class="headerlink" title="选举机制（半数机制）"></a>选举机制（半数机制）</h4><p>​        集群中<strong>半数以上</strong>机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</p>
<p>​        Zookeeper虽然在配置文件中并没有指定Master和Slave。Zookeeper工作时只有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制<strong>临时产生</strong>的</p>
<h3 id="zkClient"><a href="#zkClient" class="headerlink" title="zkClient"></a>zkClient</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk客户端</span><br><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="meta">#</span>#指定访问server</span><br><span class="line">zkCli.sh -server 192.168.1.1:2181</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##常用操作</span><br><span class="line">create /dh "shuaige"</span><br><span class="line">get /dh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#创建短暂节点</span><br><span class="line">create -e /dh/fat "fat"</span><br><span class="line"><span class="meta">#</span>#创建带顺序号的持久节点</span><br><span class="line">create -s /dh/handsome "handsome"</span><br><span class="line"><span class="meta">#</span>#修改节点的值</span><br><span class="line">set /dh/fat "littlefat" 0</span><br><span class="line"><span class="meta">#</span>#删除节点</span><br><span class="line">delete /dh/fat 0</span><br><span class="line"><span class="meta">#</span>#递归删除</span><br><span class="line">rmr /dh</span><br></pre></td></tr></table></figure>
<h4 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h4><table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>使用 ls 命令来查看当前znode中所包含的内容</td>
</tr>
<tr>
<td>ls2 path [watch]</td>
<td>查看当前节点数据并能看到更新次数等数据（详细数据）</td>
</tr>
<tr>
<td>create [选项]</td>
<td>普通创建一个zNode    -s ：含有序列    -e：临时（重启或者超时消失）</td>
</tr>
<tr>
<td>get path [watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set path  data  [version]</td>
<td>设置（修改）节点的具体值，可根据版本号对节点的值进行修改（推荐使用版本号修改，乐观锁机制）</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete path  data [version]</td>
<td>删除节点，可根据版本号对节点进行删除（推荐使用版本号删除，乐观锁机制）</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody>
</table>
<h4 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>
<ol>
<li><p>cZxid：创建节点的事务zxid</p>
<p>​        每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID</p>
<p>​        事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</p>
</li>
<li><p>ctime：znode被创建的毫秒数(从1970年开始)</p>
</li>
<li><p>mzxid：znode最后更新的事务zxid</p>
</li>
<li><p>mtime：znode最后修改的毫秒数(从1970年开始)</p>
</li>
<li><p>pZxid：znode最后更新的子节点zxid</p>
</li>
<li><p>cversion：znode子节点变化版本号，znode子节点修改次数</p>
</li>
<li><p>dataversion：znode数据变化版本号</p>
</li>
<li><p>aclVersion：znode访问控制列表的变化版本号</p>
</li>
<li><p>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</p>
</li>
<li><font color="red">dataLength：znode的数据长度</font>
</li>
<li><font color="red">numChildren：znode子节点数量</font>



</li>
</ol>
<h4 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h4><p>​        watcher是zk中的监听器机制，父节点或者子节点的增删改操作都能够触发watcher事件</p>
<p><strong>事件类型</strong></p>
<ol>
<li>父节点创建：NodeCreated</li>
<li>父节点数据修改：NodeDataChanged</li>
<li>父节点删除：NodeDeleted</li>
<li>创建了子节点：NodeChildrenChanged</li>
<li>删除子节点：NodeChildrenChanged</li>
<li>修改子节点不触发任何事件</li>
</ol>
<p><strong>watcher机制的使用场景</strong></p>
<p>​        统一的配置管理，可以监听配置信息的节点，当配置信息的节点数据发生变化的时候触发客户端更新配置的操作</p>
<h4 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h4><p>​        ACL（access control lists），可以针对节点设置读写等权限，可以保障数据的安全性；如果没有权限，则会抛出异常</p>
<p>zk的acl通过 [scheme​ : id : ​permissions] 的形式来构成权限的列表</p>
<ul>
<li>scheme：代表采用的某种权限机制</li>
<li>id：代表允许访问的用户</li>
<li>permissions：权限组合字符串（有crdwa）<ul>
<li>c：CREATE，创建子节点</li>
<li>r：READ，获取节点/子节点</li>
<li>d：DELETE，删除子节点</li>
<li>w：WRITE，设置节点数据</li>
<li>a：ADMIN，设置权限</li>
</ul>
</li>
</ul>
<blockquote>
<p>权限示例：</p>
<p>world：world:anyone:[permissions]</p>
<p>auth：auth:user:password:[permissions] 代表认证登录，需要注册的用户有操作权限即可</p>
<p>digest：digest:username:BASE64(SHA1(password)):[permissions] 表示需要对密码进行加密才可以访问</p>
<p>ip：ip:ip地址:[permissions]  可以限制指定ip才能访问该节点</p>
</blockquote>
<p><strong>ACL的命令行操作</strong></p>
<ol>
<li><p>getAcl：获取某个节点的acl权限信息</p>
</li>
<li><p>setAcl：设置某个节点的acl权限信息</p>
<blockquote>
<p>示例：（1和2是等价的）</p>
<ol>
<li>setAcl /path auth:dai:dai:cdrwa</li>
<li>setAcl /path digest:dai:password:cdrwa</li>
</ol>
<p>上面两个操作后需要进行addauth操作后才能够对 /path 进行操作</p>
<ol start="3">
<li>setAcl /path ip:192.168.1.1:cdrwa</li>
</ol>
<p>设置ip后，只有指定ip的客户端才有权限去访问该节点</p>
</blockquote>
</li>
<li><p>addauth：输入认证授权信息，注册时输入明文密码，在zk系统中，密码都是以加密的形式存在的</p>
<blockquote>
<p>参照2的示例： 执行 addauth digest:dai:dai  登录后能获取上面设置节点的操作权限  </p>
<p>​        注意：要使用 dai 用户前需要先注册 dai 用户才可以设置成功，注册用户同样是addAuth命令：addauth digest  dai:dai</p>
<p>​        注意：使用 digest 来设置权限时，查看加密后的password可以通过getAcl，比如：</p>
<p>getAcl /dh</p>
<p>​    ‘digest，’dai:password（此处的password是加密后的显示）</p>
</blockquote>
</li>
</ol>
<h2 id="Java使用ZK"><a href="#Java使用ZK" class="headerlink" title="Java使用ZK"></a>Java使用ZK</h2><h3 id="原生ZK的API"><a href="#原生ZK的API" class="headerlink" title="原生ZK的API"></a>原生ZK的API</h3><h4 id="引入POM"><a href="#引入POM" class="headerlink" title="引入POM"></a>引入POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本与ZK版本一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="连接ZK"><a href="#连接ZK" class="headerlink" title="连接ZK"></a>连接ZK</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ZKConnect.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line"><span class="comment">//	public static final String zkServerPath = "192.168.1.1:2181,192.168.1.2:2182,192.168.1.3:2183";</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 客户端和zk服务端链接是一个异步的过程</span></span><br><span class="line"><span class="comment">		 * 当连接成功后后，客户端会收的一个watch通知</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * connectString：连接服务器的ip字符串，</span></span><br><span class="line"><span class="comment">		 * 		比如: "192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181"</span></span><br><span class="line"><span class="comment">		 * 		可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群</span></span><br><span class="line"><span class="comment">		 * 		</span></span><br><span class="line"><span class="comment">		 * sessionTimeout：超时时间，心跳收不到了，那就超时</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，</span></span><br><span class="line"><span class="comment">		 * 					 此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionId：会话的id</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionPasswd：会话密码	</span></span><br><span class="line"><span class="comment">		 *          当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(zkServerPath, timeout, <span class="keyword">new</span> ZKDemo());</span><br><span class="line">		log.warn(<span class="string">"连接状态：&#123;&#125;"</span>, zk.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始会话重连</span></span><br><span class="line">        <span class="keyword">long</span> sessionId = zk.getSessionId();</span><br><span class="line">		<span class="keyword">byte</span>[] sessionPassword = zk.getSessionPasswd();</span><br><span class="line">		log.warn(<span class="string">"开始会话重连..."</span>);</span><br><span class="line">		ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(zkServerPath, </span><br><span class="line">											timeout, </span><br><span class="line">											<span class="keyword">new</span> ZKDemo(), </span><br><span class="line">											sessionId, </span><br><span class="line">											sessionPassword);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">		<span class="keyword">new</span> Thread().sleep(<span class="number">1000</span>);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		log.warn(<span class="string">"接受到watch通知：&#123;&#125;"</span>, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK的节点操作"><a href="#ZK的节点操作" class="headerlink" title="ZK的节点操作"></a>ZK的节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNode</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNode());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNode zkServer = <span class="keyword">new</span> ZKNode(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *查询节点是否存在</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：watch</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Stat stat = zkServer.getZookeeper().exists(<span class="string">"/dh-demo"</span>, <span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"查询的节点版本为dataVersion："</span> + stat.getVersion());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"该节点不存在..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		  * 同步或者异步创建节点，都不支持子节点的递归创建，异步有一个callback函数</span></span><br><span class="line"><span class="comment">		  * 参数：</span></span><br><span class="line"><span class="comment">		  * path：创建的路径</span></span><br><span class="line"><span class="comment">		  * data：存储的数据的byte[]</span></span><br><span class="line"><span class="comment">		  * acl：控制权限策略</span></span><br><span class="line"><span class="comment">		  * 			Ids.OPEN_ACL_UNSAFE --&gt; world:anyone:cdrwa</span></span><br><span class="line"><span class="comment">		  * 			CREATOR_ALL_ACL --&gt; auth:user:password:cdrwa</span></span><br><span class="line"><span class="comment">		  * createMode：节点类型, 是一个枚举</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT：持久节点</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT_SEQUENTIAL：持久顺序节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL：临时节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL_SEQUENTIAL：临时顺序节点</span></span><br><span class="line"><span class="comment">		  */</span> 	       </span><br><span class="line">        String ctx = <span class="string">"&#123;'create':'success'&#125;"</span>;</span><br><span class="line">		zookeeper.create(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.get, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> CreateCallBack(), ctx);</span><br><span class="line">             </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *获取一个节点的值</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：true或者false，注册一个watch事件</span></span><br><span class="line"><span class="comment">		 * stat：状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] resByte = zkServer.getZookeeper().getData(<span class="string">"/dh"</span>, <span class="keyword">true</span>, stat);</span><br><span class="line">		String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line">		System.out.println(<span class="string">"当前值:"</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *设置节点的数据</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * data：数据</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		stat  = zkServer.getZookeeper().setData(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		System.out.println(status.getVersion());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *删除节点(带回调的)</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        String ctx = <span class="string">"&#123;'delete':'success'&#125;"</span>;</span><br><span class="line">		zkServer.getZookeeper().delete(<span class="string">"/dh-path"</span>, stat.getVersion(), <span class="keyword">new</span> DeleteCallBack(), ctx);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对节点的监听</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getType() == EventType.NodeCreated) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点创建"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点数据改变"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDeleted) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点删除"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CallBack回调</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCallBack</span> <span class="keyword">implements</span> <span class="title">StringCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建节点: "</span> + path);</span><br><span class="line">		<span class="comment">//ctx 就是create方法传入的ctx参数</span></span><br><span class="line">		System.out.println((String)ctx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildrenCallBack</span> <span class="keyword">implements</span> <span class="title">ChildrenCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String s : children) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"ChildrenCallback:"</span> + path);</span><br><span class="line">		System.out.println((String)ctx);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNodeAcl</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNodeAcl());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createZKNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acls)</span> </span>&#123;</span><br><span class="line">		String result = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			result = zookeeper.create(path, data, acls, CreateMode.PERSISTENT);</span><br><span class="line">			System.out.println(<span class="string">"创建节点：\t"</span> + result + <span class="string">"\t成功..."</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNodeAcl zkServer = <span class="keyword">new</span> ZKNodeAcl(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * ======================  创建node start  ======================  </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// acl 任何人都可以访问</span></span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl"</span>, <span class="string">"data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 自定义用户认证访问</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * DigestAuthenticationProvider.generateDigest(String str)</span></span><br><span class="line"><span class="comment">         * 这个方法是zk客户端提供的加密方式 BASE61(SHA1(password))</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id acl1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        </span><br><span class="line">		Id acl2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.ALL, acl1));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.READ, acl2));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.DELETE | Perms.CREATE, acl2));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test"</span>, <span class="string">"testdigest"</span>.getBytes(), acls);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 注册过的用户必须通过addAuthInfo才能操作节点，参考命令行 addauth</span></span><br><span class="line">		zkServer.getZookeeper().addAuthInfo(<span class="string">"digest"</span>, <span class="string">"dai1:123456"</span>.getBytes());</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test/childtest"</span>, <span class="string">"childtest"</span>.getBytes(), Ids.CREATOR_ALL_ACL);</span><br><span class="line">		Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/test"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ip方式的acl</span></span><br><span class="line">		List&lt;ACL&gt; aclsIP = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id ipId = <span class="keyword">new</span> Id(<span class="string">"ip"</span>, <span class="string">"192.168.1.10"</span>);</span><br><span class="line">		aclsIP.add(<span class="keyword">new</span> ACL(Perms.ALL, ipId));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"data"</span>.getBytes(), aclsIP);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 验证ip是否有权限</span></span><br><span class="line">        zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"setdata"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/aclimooc/iptest6"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		System.out.println(stat.getVersion());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Apache-Curator"><a href="#Apache-Curator" class="headerlink" title="Apache Curator"></a>Apache Curator</h3><h4 id="ZK连接及节点操作"><a href="#ZK连接及节点操作" class="headerlink" title="ZK连接及节点操作"></a>ZK连接及节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy1 = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryNTimes</span></span><br><span class="line"><span class="comment">         *              n：重试的次数</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries：每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryOneTime</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetry:每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy2 = <span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryUntilElapsed</span></span><br><span class="line"><span class="comment">         *              maxElapsedTimeMs:最大重试时间</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries:每次重试间隔</span></span><br><span class="line"><span class="comment">         *              重试时间超过maxElapsedTimeMs,就不再重试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy3 = <span class="keyword">new</span> RetryUntilElapsed(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//判断链接是否成功</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建节点:</span></span><br><span class="line"><span class="comment">         *      creatingParentsIfNeeded : 开启递归的创建方式,不用一层一层的创建</span></span><br><span class="line"><span class="comment">         *      withMode  : 节点的类型</span></span><br><span class="line"><span class="comment">         *      withACL   : acl权限</span></span><br><span class="line"><span class="comment">         *      forPath   : 节点路径和数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String nodePath = <span class="string">"/dai"</span>;</span><br><span class="line">        String str = client.create()</span><br><span class="line">                            .creatingParentsIfNeeded()</span><br><span class="line">                            .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                            .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                            .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点数据:</span></span><br><span class="line"><span class="comment">         *      storingStatIn : 把服务器端获取的状态数据存储到stat对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = client.getData()</span><br><span class="line">                            .storingStatIn(stat)</span><br><span class="line">                            .forPath(nodePath);</span><br><span class="line">        System.out.println(<span class="string">"节点"</span> + nodePath + <span class="string">"的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">        System.out.println(<span class="string">"该节点的版本号为: "</span> + stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新节点数据:</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.setData()</span><br><span class="line">                .withVersion(stat.getVersion())</span><br><span class="line">                .forPath(nodePath, <span class="string">"update"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除节点:</span></span><br><span class="line"><span class="comment">         *      guaranteed : 保障措施,只要客户端会话有效; 那么Curator会在后台持续进行删除操作,直到删除节点成功</span></span><br><span class="line"><span class="comment">         *      deletingChildrenIfNeeded : 递归删除,有子节点的情况下会将所有子节点也一并删除</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        client.getData().storingStatIn(stat).forPath(nodePath);</span><br><span class="line">		client.delete()</span><br><span class="line">              .guaranteed()</span><br><span class="line">              .deletingChildrenIfNeeded()</span><br><span class="line">              .withVersion(stat.getVersion())</span><br><span class="line">              .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查询子节点</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		List&lt;String&gt; childNodes = client.getChildren().forPath(nodePath);</span><br><span class="line">		System.out.println(<span class="string">"开始打印子节点："</span>);</span><br><span class="line">		<span class="keyword">for</span> (String child : childNodes) &#123;</span><br><span class="line">			System.out.println(child);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断节点是否存在,如果不存在则为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		Stat statExist = client.checkExists().forPath(nodePath + <span class="string">"/exist"</span>);</span><br><span class="line">		System.out.println(statExist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件:</span></span><br><span class="line"><span class="comment">         *      当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.getData().usingWatcher(<span class="keyword">new</span> MyCuratorWatcher()).forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      NodeCache: 监听数据节点的变更，会触发事件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, nodePath);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  参数:</span></span><br><span class="line"><span class="comment">         *      buildInitial : 初始化的时候获取node的值并且缓存</span></span><br><span class="line"><span class="comment">         *          只有开启这个缓存后,下面的getCurrentData方法才能拿到数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为空..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">"节点数据为空"</span>);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String data = <span class="keyword">new</span> String(nodeCache.getCurrentData().getData());</span><br><span class="line">				System.out.println(<span class="string">"节点路径："</span> + nodeCache.getCurrentData().getPath() + <span class="string">"  数据："</span> + data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为子节点添加watcher事件</span></span><br><span class="line"><span class="comment">         *      PathChildrenCache: 监听数据节点的增删改，会触发事件</span></span><br><span class="line"><span class="comment">         *      cacheData: 是否设置缓存节点的数据状态</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, nodePath, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * StartMode: 初始化方式</span></span><br><span class="line"><span class="comment">         *      POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件</span></span><br><span class="line"><span class="comment">         *      NORMAL：异步初始化</span></span><br><span class="line"><span class="comment">         *      BUILD_INITIAL_CACHE：同步初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line"></span><br><span class="line">        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line">        System.out.println(<span class="string">"当前数据节点的子节点数据列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (ChildData child : childDataList) &#123;</span><br><span class="line">            String childData = <span class="keyword">new</span> String(child.getData());</span><br><span class="line">            System.out.println(childData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"子节点初始化ok..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED))&#123;</span><br><span class="line">                    String path = event.getData().getPath();</span><br><span class="line">                    <span class="keyword">if</span> (path.equals(<span class="string">"dh-add"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加子节点:"</span> + event.getData().getPath());</span><br><span class="line">                        System.out.println(<span class="string">"子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">"/super/imooc/e"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加不正确..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"删除子节点:"</span> + event.getData().getPath());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点路径:"</span> + event.getData().getPath());</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted2 = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCuratorWatcher</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"触发了watch 事件，节点路径："</span> + watchedEvent.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限-1"><a href="#ACL权限-1" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        List&lt;ACL&gt; aclList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Id 构造参数:</span></span><br><span class="line"><span class="comment">         *         scheme:认证方式</span></span><br><span class="line"><span class="comment">         *                      world：默认方式，相当于全世界都能访问</span></span><br><span class="line"><span class="comment">         *                      auth：代表已经认证通过的用户</span></span><br><span class="line"><span class="comment">         *                      digest：即用户名:密码这种方式认证</span></span><br><span class="line"><span class="comment">         *                      ip：使用Ip地址认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Id id1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        Id id2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ACL 构造参数:</span></span><br><span class="line"><span class="comment">         *          perms:五种权限:</span></span><br><span class="line"><span class="comment">         *                          CREATE: 能创建子节点</span></span><br><span class="line"><span class="comment">         *                          READ：能获取节点数据和列出其子节点</span></span><br><span class="line"><span class="comment">         *                          WRITE: 能设置节点数据</span></span><br><span class="line"><span class="comment">         *                          DELETE: 能删除子节点</span></span><br><span class="line"><span class="comment">         *                          ADMIN: 能设置权限</span></span><br><span class="line"><span class="comment">         *             Id:就是上面的Id类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.ALL, id1));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.READ, id2));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.CREATE | Perms.WRITE, id2));</span><br><span class="line">        client.setACL().withACL(aclList).forPath(<span class="string">"/dai/dh/hao"</span>);</span><br><span class="line">        client.create()</span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * withACL 第二个参数applyToParents :</span></span><br><span class="line"><span class="comment">                 *                      如果设置为true,那么会将这些acl权限加到创建的父节点上(递归创建)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .withACL(aclList, <span class="keyword">true</span>)</span><br><span class="line">                .forPath(<span class="string">"/dai/dh/hao"</span>, <span class="string">"data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/CAP理论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/CAP理论/" itemprop="url">CAP理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T23:00:10+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CAP理论</p>
<h2 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h2><p>​    CAP理论指的是在一个<strong>分布式系统</strong>中，不能同时满足一致性，可用性和分区容错性</p>
<ol>
<li><p>C（Consistency）：一致性</p>
<blockquote>
<p>在分布式系统中的所有数据备份，在同一时刻是否是同样的值</p>
</blockquote>
</li>
<li><p>A（Availabe）：可用性</p>
<blockquote>
<p>​    可用性指在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</p>
<p>​    可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。“有效的时间内”是指，对于用户的一个操作请求，<strong>系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的</strong></p>
</blockquote>
</li>
<li><p>P（Partition Tolenrance）：分区容错性</p>
<blockquote>
<p>​    以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用</p>
</blockquote>
</li>
</ol>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>​    分区容错性约束了一个分布式系统具有如下特性：<font color="red">分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</font></p>
<p><strong>网络分区</strong></p>
<p>​    网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况；但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p>
<p>​    需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区</p>
<h3 id="Consistency一致性强弱"><a href="#Consistency一致性强弱" class="headerlink" title="Consistency一致性强弱"></a>Consistency一致性强弱</h3><p>​    一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即<strong><font color="red">数据变动在系统内部各节点应该是同步的</font></strong></p>
<p>根据一致性强弱可分为：</p>
<ol>
<li><strong>强一致性</strong>（Strong Consistency）任何时刻，任何用户都能读取到最近一次成功更新的数据</li>
<li><strong>单调一致性</strong>（Monotonic Consistency）任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说<strong>可获取的数据顺序必是单调递增的</strong></li>
<li><strong>会话一致性</strong>（Session Consistency）任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在<font color="blue">本次会话中就不会再读到比这个值更旧的值</font>。<u>会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障</u></li>
<li><strong>最终一致性</strong>（Eventual Consistency）用户只能读到某次更新后的值，<font color="blue">但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障</font></li>
<li><strong>弱一致性</strong>（Weak Consistency）用户无法在确定时间内读到最新更新的值</li>
</ol>
<h3 id="CAP的抉择"><a href="#CAP的抉择" class="headerlink" title="CAP的抉择"></a>CAP的抉择</h3><table>
<thead>
<tr>
<th><strong>选    择</strong></th>
<th style="text-align:left"><strong>说    明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td style="text-align:left">放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td>
</tr>
<tr>
<td>AP</td>
<td style="text-align:left">放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td style="text-align:left">放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<h4 id="简单的CAP例子"><a href="#简单的CAP例子" class="headerlink" title="简单的CAP例子"></a>简单的CAP例子</h4><p>​    一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取    </p>
<ol>
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功</strong></p>
<blockquote>
<p>在没有出现网络故障的时候，满足CA原则</p>
<ul>
<li>C 即我的任何一个写入，更新操作成功并返回客户端完成后，分布式的所有节点在同一时间的数据完全一致</li>
<li>A 即我的读写操作都能够成功</li>
</ul>
<font color="blue">但是当出现网络故障时，我不能同时保证CA，即P条件无法满足</font>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><strong>假设DB的更新操作是只写本地机房成功就返回，通过binlog/oplog回放方式同步至侧边机房</strong></p>
<blockquote>
<p>​    这种操作保证了在出现网络故障时，双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP </p>
<p>​    但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在<strong><font color="red">短暂数据不一致</font></strong>，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务</strong></p>
<blockquote>
<p>降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是这无法满足可用性原则</p>
</blockquote>
</li>
</ol>
<h4 id="选择权衡"><a href="#选择权衡" class="headerlink" title="选择权衡"></a>选择权衡</h4><p>​    对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么<u>分布式系统中的组件必然需要被部署到不同的节点</u>，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统往往需要根据业务特点在C（一致性）和A（可用性）之间寻求平衡</p>
<p>​    对于大多数互联网应用来说，因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有舍弃强一致性（可以保证最终一致性）来保证服务的AP</p>
<p>​    但是对于需要确保强一致性的场景，如银行业务，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>​    BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<p>​    BASE理论的核心思想是：<strong><font color="red">即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</font></strong></p>
<ol>
<li><p>Basically Available（基本可用）</p>
<blockquote>
<p>基本可用是指分布式系统在出现不可预知故障的时候，<font color="blue">允许损失部分可用性</font></p>
<p>注意，这绝不等价于系统不可用。如：</p>
<ul>
<li><p>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p>
</li>
<li><p>系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p>
</li>
</ul>
</blockquote>
</li>
<li><p>Soft state（软状态）</p>
<blockquote>
<p>​    软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</strong></p>
</blockquote>
</li>
<li><p>Eventually consistent（最终一致性）</p>
<blockquote>
<p>​    最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态</p>
<p>​    因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
</blockquote>
</li>
</ol>
<h4 id="最终一致性变种"><a href="#最终一致性变种" class="headerlink" title="最终一致性变种"></a>最终一致性变种</h4><ol>
<li><p>因果一致性：</p>
<blockquote>
<p>​    因果一致性是指：如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制</p>
</blockquote>
</li>
<li><p>读己之所写：</p>
<blockquote>
<p>​    读己之所写是指：进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。</p>
<p>​    也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性</p>
</blockquote>
</li>
<li><p>会话一致性：</p>
<blockquote>
<p>​    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性</p>
<p>​    也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值</p>
</blockquote>
</li>
<li><p>单调读一致性：</p>
<blockquote>
<p>​       单调读一致性是指：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值</p>
</blockquote>
</li>
<li><p>单调写一致性：</p>
<blockquote>
<p> 单调写一致性是指：一个系统需要能够保证来自同一个进程的写操作被顺序地执行</p>
</blockquote>
</li>
</ol>
<p>​    总的来说：BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是<strong>通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。</p>
<p>​    在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/JVM垃圾收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/JVM垃圾收集/" itemprop="url">JVM垃圾收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T16:51:50+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文基于JDK7 HotSpot VM</p>
</blockquote>
<h3 id="判定对象无用的根据"><a href="#判定对象无用的根据" class="headerlink" title="判定对象无用的根据"></a>判定对象无用的根据</h3><p>​    通过可达性算法判断对象是否不再使用。即GC Roots，将GC Roots作为起始点向下搜索引用，还被GC Roots引用的对象就是可用的，而当一个对象没有到GC Roots有任何引用链的即为可回收的对象。</p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>当前各线程执行方法中的局部变量（包括形参）引用的对象</li>
<li>已被加载的类的 static 域引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>JNI （Native方法）引用的对象</li>
</ul>
<h3 id="内存的分配和回收"><a href="#内存的分配和回收" class="headerlink" title="内存的分配和回收"></a>内存的分配和回收</h3><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>​    在堆为对象分配内存空间之前，应该先知道对象在内存中存储的布局；对象在内存中的存储布局主要分为：对象头，实例数据和对齐填充。</p>
<ul>
<li>对象头：主要用于存储对象自身运行时的数据和类型指针<ul>
<li>运行时数据包括：哈希码（HashCode）、GC分代年龄、锁状态标志</li>
<li>类型指针是指向类元数据的指针</li>
</ul>
</li>
<li>实例数据：对象中的字段数据和父类继承过来的字段数据等</li>
<li>对齐填充：只是起到占位符的作用。因为HotSpotVM要求对象的起始地址必须是8字节的整数倍，当一个对象的实例数据（对象头是32bit或者64bit）不是8字节的整数倍时，就需要对齐填充来补全了</li>
</ul>
<h4 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h4><p>​        对象的内存分配主要在新生区的Eden空间上，当Eden区没有足够的连续空间时会触发一次MinorGC；但是一些需要连续大量内存空间的对象（很长的字符串或者数组）就会导致Eden区容纳不下这个对象（垃圾清理后仍然放不下），这个时候会直接在老年代中为其分配内存。</p>
<p>​    同时虚拟机也提供了-XX:PretenureSizeThreshold的参数，当对象的大小大于这个设置值的时候，会直接在老年代中进行内存分配，这样也可以避免新生代频繁的进行垃圾收集（新生代的垃圾收集是复制算法）</p>
<h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>​        了解了对象内存分配的位置，那么就需要知道内存分配的方式了。</p>
<ol>
<li>有大片连续内存空间时（常用于<strong>带压缩算法</strong>的收集器，如Serial，ParNew）</li>
</ol>
<p>​        当存在大片连续的内存可用于分配给新对象时，可以采用<strong>指针碰撞</strong>的方式（每次分配对象空间只要检测一下是否有足够的空间，如果有那么指针往前移动 N 位就分配好空间了，然后就可以初始化这个对象了）</p>
<p>​    对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot 使用了称之为<strong>Thread-Local Allocation Buffers (TLABs) 的技术</strong>，该技术能改善多线程空间分配的吞吐量。TLABs首先给予每个线程一部分内存作为缓存区，<font color="blue">每个线程都在自己的缓存区中进行指针碰撞</font>，这样就不用获取全局锁了。只有当一个线程使用完了它的 TLAB，它才需要使用同步锁定来获取一个新的缓冲区。</p>
<p>​    HotSpot 使用了多项技术来降低 TLAB 对于内存的浪费。比如，TLAB 的平均大小被限制在 Eden 区大小的 1% 之内。TLABs 和使用指针碰撞的线性分配结合，使得内存分配非常简单高效。</p>
<blockquote>
<p>可用-XX:+UseTLAB 来启用TLAB技术</p>
</blockquote>
<ol start="2">
<li>内存空间碎片较多时（如CMS收集器，使用Mark-Sweep算法）</li>
</ol>
<p>​        当已经使用的内存和空闲内存相互交错的时候，就不能直接的进行指针碰撞来分配内存了；这个时候虚拟机就会维护一个 <strong>“空闲列表”</strong> 来记录可用的内存块，在分配内存的时候会再列表中找到足够大的空间划分给对象，并且会更新列表上的记录</p>
<h4 id="内存分代思想"><a href="#内存分代思想" class="headerlink" title="内存分代思想"></a>内存分代思想</h4><p>​    虚拟机采用了分代收集的思想去管理堆内存；分代思想指的是虚拟机根据对象的存活周期来划分内存，一般将堆内存划分为年轻代（新生代）和老年代；年轻代是在垃圾收集的时候会有大量的对象死去的内存区域，而老年代中的对象普遍是存活率高的</p>
<p>​    年轻代因为每次都有大量的对象死去，所以一般会采用复制算法（下文介绍，因为此算法只需要复制少量的存活对象，成本较低）；虚拟机在对象创建的时候会给对象定义一个<font color="red">对象年龄的计数器</font>，对象在年轻代（Eden区）被创建并且经历过一次Minor GC（年轻代垃圾收集）并且存活，将会被移到Survivor区并且设置对象年龄为1，<u>该对象每熬过一次MinorGC，对象年龄就会加一</u>，当对象年龄达到一定程度就会晋升到老年代中（默认是15，可以通过-XX:MaxTenuringThreshold=15来设置）</p>
<p>​    但是如果每个对象都需要等到晋升年龄的话，Survivor区不一定能够容纳下这么多的对象。所以为了应对这种内存状况，虚拟机的解决办法是：<font color="red">如果Survivor区中<strong>相同年龄的所有对象大小的总和</strong>大于Survivor空间的一半，那么对象年龄大于或等于该值的对象就直接进入老年代，不需要达到晋升年龄</font></p>
<h3 id="什么时候触发垃圾收集"><a href="#什么时候触发垃圾收集" class="headerlink" title="什么时候触发垃圾收集"></a>什么时候触发垃圾收集</h3><ol>
<li>当年轻代被填满后（一般新对象在Eden区申请内存空间失败的时候），会进行一次年轻代垃圾收集（也叫做 Minor GC）</li>
<li>Full GC（通常也叫Major GC）会对整个堆进行垃圾收集，触发的情况：<ul>
<li>老年代或者永久代被填满的时候触发</li>
<li>当新生代对象晋升到老年代担保失败的时候触发（即年轻代垃圾收集后会有一部分晋升到老年代的对象，当老年代不能容纳这些晋升的对象时会触发）</li>
</ul>
</li>
<li>CMS垃圾收集器的触发时机；CMS垃圾收集器不会等到老年代或者永久代满了才开始进行垃圾收集（CMS只收集老年代old Gen），会有一个<strong>预设占用率（initiating occupancy）</strong><ul>
<li>老年代的使用率达到阈值（通过JVM参数：<strong>–XX:CMSInitiatingOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>永久代的使用率到达阈值（<strong>–XX:CMSInitiatingPermOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>当新生代对象晋升到老年代担保失败的时候触发</li>
</ul>
</li>
</ol>
<p>注意： <strong>只有CMS的concurrent collection是只收集old Gen的，其他的老年代垃圾收集器在满足条件后会触发Full GC，此时Full GC会收集整个GC堆，会先进行young GC（即使用年轻代的垃圾收集算法去收集年轻代的垃圾），然后使用老年代算法去收集老年代和方法区。</strong></p>
<p>​    <strong>这里还有个值得注意的地方，当要进行一次young GC时，如果发现统计数据说之前young GC的<font color="blue">平均晋升大小比目前old gen剩余的空间大</font>，则不会进行young GC，而是会采用老年代的垃圾收集算法对<font color="red">整个堆</font>进行垃圾收集（除了CMS）</strong></p>
<p>​    为什么说除了CMS呢，因为CMS垃圾收集器不能收集年轻代的垃圾。而且CMS有预设占用率会触发老年代的垃圾收集，所以CMS一般不会发生Full GC，但是当CMS发生concurrent mode failure的时候是会退化到发生Full GC，这个时候会变成使用备选的Serial Old收集器来对老年代进行垃圾收集（也有可能对整个堆进行垃圾收集哦，也就是发生上面一段话所说的情况）</p>
<h4 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h4><p>​    分配担保机制指的是：<font color="red">在MinorGC后新生代还有大量的对象存活，并且Survivor区不能存放所有的存活对象的情况下，会将无法容纳的对象直接晋升到老年代中</font></p>
<p>​    分配担保机制触发是在<u><strong>老年代中的内存还有能容纳晋升上来的对象的空间</strong></u>，而且在最坏的情况下是整个Eden区的对象都是存活的，所以在发生MinorGC之前，虚拟机都会先检查老年代的最大可用的连续内存空间是否大于新生代所有对象的总和，如果条件成立，那么可以直接进行MinorGC。</p>
<p>​    否则会根据是否设置了担保失败机制来选择下一步</p>
<ul>
<li><p>如果允许出现担保失败，则继续检查老年代中的最大可用连续内存空间<font color="blue">是否大于之前每次垃圾回收晋升到老年代对象容量的平均值大小</font>，如果大于则进行MinorGC，否则会进行Full GC来让老年代腾出更大的内存空间；比较平均值是一种动态手段，这种情况下如果出现上面最坏的情况，存活的对象远远高于平均值，是会出现担保失败的情况的（Handle Promotion Failure）；出现这种情况，会重新的进行一次Full GC去腾出更多空间。</p>
<blockquote>
<p>-XX:+HandlePromotionFailure    允许担保失败</p>
<p>-XX:-HandlePromotionFailure    不允许担保失败</p>
</blockquote>
</li>
<li><p>如果不允许出现担保失败，则直接进行Full GC腾出空间。</p>
</li>
</ul>
<p>注：推荐允许担保失败，因为这样能够避免频繁的Full GC    </p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>三种常用的垃圾收集算法的思想：</p>
<ol>
<li><p>标记清除算法</p>
<ul>
<li>首先标记出需要进行回收的对象，然后统一回收这些被标记的对象</li>
<li>这个算法回收完对象之后会产生大量的不连续的内存空间，这些内存碎片容易导致在后续分配大对象的时候无法找到足够的连续的内存空间</li>
</ul>
</li>
<li><p>标记复制算法</p>
<ul>
<li>这里以年轻代为例子说明：将内存划分为一个<strong>Eden区</strong>和两个<strong>Survivor区</strong>，每次使用Eden区和其中一个Survivor区（为了内存利用率），当回收垃圾的时候，将Eden区和Survivor区存活的对象复制到另外一块Survivor区中，然后再将Eden区和用过的Survivor区的内存空间清理掉</li>
<li>虚拟机会给对象定义一个对象年龄的计数器，当对象复制到Survivor区的时候，对象的年龄增加1，当达到一定程度的时候会晋升到老年代中</li>
<li>当复制过去的对象在Survivor区中不够大小存放的时候（内存不足），此时会触发<strong>分配担保机制</strong>，直接将这些对象晋升到老年代中</li>
</ul>
<p><img src="/2019/04/14/JVM垃圾收集/From-To1.png" alt="MinorGC Start"></p>
<p><img src="/2019/04/14/JVM垃圾收集/From-To2.png" alt="MinorGC After"></p>
</li>
<li><p>标记整理算法（标记 -&gt; 清除 -&gt; 压缩）</p>
<ul>
<li>这个算法跟标记清除算法差不多一样，只是当回收完被标记的对象后，会对内存空间进行压缩，将所有活的对象移到一边，然后会剩下一大片连续的内存空间，当产生新的对象时就很容易进行内存分配了</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>在了解垃圾收集器之前需要先认识几个概念</p>
<ul>
<li><p><strong>并行</strong>：多个垃圾回收线程同时工作，此时用户线程处于等待状态。</p>
</li>
<li><p><strong>并发</strong>：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起。</p>
</li>
<li><p><strong>Stop-the-world</strong>：在垃圾收集时，需要将应用程序完全挂起的事件称为stop-the-world。</p>
<blockquote>
<p>​    这是因为GC需要在垃圾收集前分析堆中对象的引用关系并且保存准确性所导致的结果（如果不停顿应用线程的执行，那么会导致在分析过程中还会出现引用关系变化的情况，从而会让可达性算法分析的结果变得更加复杂和不准确）。</p>
<p>​    应用stop-the-world的垃圾收集器会简单很多，应为在应用程序停顿的时候，堆内存空间是不会发生变化了，此时就能够准确的标记无用的对象。但是在web应用环境下，它挂起应用线程的时间是不能被接受的。</p>
</blockquote>
</li>
<li><p><strong>吞吐量</strong>：应用程序执行时间   / （应用程序执行时间 + 垃圾收集时间）</p>
</li>
</ul>
<h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p>​    年轻代和老年代都使用单线程的方式来进行垃圾收集（在多核CPU下也只会使用一个CPU进行垃圾收集），收集过程需要stop-the-world。</p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>​    用于年轻代的垃圾收集，主要采用了标记复制算法。</p>
<h5 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h5><p>​    用于老年代的垃圾收集，主要采用了标记整理算法（标记 -&gt; 清除 -&gt; 压缩算法）</p>
<h5 id="串行垃圾收集的优点"><a href="#串行垃圾收集的优点" class="headerlink" title="串行垃圾收集的优点"></a>串行垃圾收集的优点</h5><ul>
<li>简单高效</li>
<li>对于单个CPU的环境下，串行收集器没有线程间交互的时间开销</li>
<li>适用于运行在client模式下的程序</li>
</ul>
<p>可以使用<code>-XX:+UseSerialGC</code>来使用Serial + SerialOld的组合进行垃圾收集</p>
<h4 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h4><p>​    并行垃圾收集器利用多核的优势，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行的收集器仍然会stop-the-world，只不过使用多核的优势并行执行，降低停顿的时间；同时降低垃圾收集的时间，从而提高吞吐量。</p>
<p>​    并行垃圾收集器能够通过 <code>–XX:ParallelGCThreads=n</code>来控制垃圾收集线程的个数，<strong>合理利用CPU的资源能够有效的降低垃圾收集的停顿时间</strong>，但是上面说过了串行收集器在单CPU环境下是没有线程间交互的开销的，所以在单CPU的环境下，可能效率会比串行收集器更低。</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>​    多线程版本的Serial收集器，它能够配合CMS收集器一起工作（CMS是老年代的收集器；因为是Serial的多线程版本，所以Serial收集器也能和CMS收集器配合工作）。和Serial一样采用标记复制算法，不过是并行的复制算法，需要stop-the-world。</p>
<p>​    可以用<code>-XX:+UseConcMarkSweepGC</code>来使用CMS + ParNew组合的垃圾收集器（这里会有个情况，当CMS出现concurrent mode failure的时候会使用Serial Old收集器来手机老年代的对象）；还可以用<code>-XX:+UseParNewGC</code>来使用Serial Old + ParNew的组合进行内存回收。</p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>​    吞吐量收集器，可以这样形容这个收集器。显而易见，这是能够控制吞吐量的垃圾收集器，同样的也是采用复制算法（需要stop-the-world）。此收集器提供了两个参数来控制吞吐量（控制GC的停顿时间），分别是：<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>（<strong>MaxGCPauseMillis</strong>优先度更高）</p>
<ol>
<li><p>MaxGCPauseMillis是设置最大的垃圾收集停顿时间</p>
<ul>
<li>过分的降低停顿时间的话（设置停顿时间很短的情况下），是会降低整体的吞吐量的。因为设置了很低的停顿时间，可能会使得虚拟机对新生代的空间进行调整（调整Eden和Survivor区的比例），当Eden区的空间变小了，会导致更频繁的进行垃圾收集。垃圾收集的停顿时间确实会因为Eden区变小从而降低了，但是更频繁的垃圾收集也会导致整体吞吐量降低。</li>
</ul>
</li>
<li><p>GCTimeRatio是用来设置吞吐量的。此参数的值是：垃圾收集时间与应用程序运行时间的比值；例如</p>
<ul>
<li><p><code>-XX:GCTimeRatio=99</code> (同时也是默认值)此时相当于 垃圾收集时间:程序运行时间=1:99，则吞吐量=1/(1+99)=1% </p>
<blockquote>
<p>个人观点（勿喷）：周志明老师JVM书上的描述有点不对，书中描述GCTimeRatio设置的值是吞吐量的倒数，比如默认值99，如果是吞吐量的倒数的话，那么吞吐量就是1/99了，这样看来是不对的。所以我认为描述为吞吐量倒数应该是不正确的。应该是垃圾收集时间与应用程序运行时间的比值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当我们能够通过设置上面两个参数来控制吞吐量，但是不知道什么样的情况下是最好的（即不知道该如何设置年轻代内存大小和各个区之间的比值等）；这种情况下可以使用 <code>-XX:+UseAdaptiveSizePolicy</code> 来动态的调整虚拟机相关细节参数来达到设置好的停顿时间或者吞吐量，这中调节方式被称为GC自适应调节策略（建议使用该收集器时开启这个参数）</p>
</li>
</ol>
<p>可以使用<code>-XX:+UseParallelOldGC</code>来使用Parallel Scavenge + Parallel Old的组合回收内存</p>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>​    Parallel Old是Parallel Scavenge的老年代版本。采用的是并行标记整理算法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/rifumei.jpg" alt="Adrian Dai">
            
              <p class="site-author-name" itemprop="name">Adrian Dai</p>
              <p class="site-description motion-element" itemprop="description">看板娘赛高！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/daiadrian" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:daiadrian@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/Adrian_Dai" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adrian Dai</span>

  
</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"vOffset":-100,"hOffset":0},"mobile":{"show":true,"motion":true},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
