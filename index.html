<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="看板娘赛高！">
<meta property="og:type" content="website">
<meta property="og:title" content="Adrian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Adrian">
<meta property="og:description" content="看板娘赛高！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Adrian">
<meta name="twitter:description" content="看板娘赛高！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Adrian</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/daiadrian" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Adrian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/14/ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/14/ThreadPoolExecutor/" itemprop="url">ThreadPoolExecutor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-14T12:00:30+08:00">
                2019-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法参数解析"><a href="#构造方法参数解析" class="headerlink" title="构造方法参数解析"></a>构造方法参数解析</h3><ol>
<li><p><strong><font color="green">corePoolSize</font></strong>：核心线程数</p>
</li>
<li><p><strong><font color="green">maximumPoolSize</font></strong>：最大线程数，线程池允许创建的最大线程数</p>
</li>
<li><p><strong><font color="green">workQueue</font></strong>：任务队列，<code>BlockingQueue</code> 接口的某个实现（常使用 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>）</p>
</li>
<li><p><strong><font color="green">keepAliveTime</font></strong>：空闲线程的<strong>保活时间</strong>，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了</p>
<blockquote>
<p><font color="red"><strong>注意：</strong></font>这个值并不会对所有线程起作用；</p>
<ol>
<li>如果<strong>线程池中的线程数</strong>少于等于核心线程数 <code>corePoolSize</code><strong>，那么这些线程不会因为空闲太长时间而被关闭，</strong></li>
<li><strong>可以通过调用 <code>allowCoreThreadTimeOut(true)</code></strong> 使核心线程数内的线程也可以被回收</li>
</ol>
</blockquote>
</li>
<li><p><strong><font color="green">TimeUnit</font></strong>：参数的时间单位；<code>TimeYnit</code> 是枚举类</p>
</li>
<li><p><strong><font color="green">threadFactory</font></strong>：<strong>用于生成线程</strong>，一般我们可以用默认的就可以了</p>
<blockquote>
<p>通常，我们可以通过它将我们的线程的名字设置得比较可读一些</p>
<p>如 <code>Message-Thread-1</code>， <code>Message-Thread-2</code> 类似这样</p>
</blockquote>
</li>
<li><p><strong><font color="green">handler</font></strong>：当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定</p>
<blockquote>
<p> <code>rejectedExecutionHandler</code> 用于处理当线程池不能执行此任务时的情况</p>
<p>主要的策略有：（默认策略是 抛出异常）</p>
<ol>
<li><strong>抛出 RejectedExecutionException 异常</strong></li>
<li><strong>忽略任务</strong></li>
<li><strong>使用提交任务的线程来执行此任务</strong></li>
<li><strong>将队列中等待最久的任务删除，然后提交此任务</strong></li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="任务策略"><a href="#任务策略" class="headerlink" title="任务策略"></a>任务策略</h3><p>​        任务策略执行的时期是<font color="red"><strong>线程池的线程达到 <code>maximumPoolSize</code> 的时候，此时新提交的任务就会按照指定策略进行操作</strong></font></p>
<ul>
<li><strong>CallerRunsPolicy</strong>：只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</li>
</ul>
<ul>
<li><strong>AbortPolicy</strong>：不管怎样，直接抛出 <code>RejectedExecutionException</code> 异常（默认）</li>
</ul>
<ul>
<li><strong>DiscardPolicy</strong>：不做任何处理，直接忽略掉这个任务</li>
</ul>
<ul>
<li><strong>DiscardOldestPolicy</strong>：如果线程池没有被关闭的话，把<font color="blue">队列队头的任务（也就是等待了最长时间的）直接扔掉</font>，然后提交这个任务到等待队列中</li>
</ul>
<h3 id="线程池中的线程创建时机"><a href="#线程池中的线程创建时机" class="headerlink" title="线程池中的线程创建时机"></a>线程池中的线程创建时机</h3><ol>
<li>如果当前线程数少于 <code>corePoolSize</code>，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务</li>
<li>如果当前线程数已经达到 <code>corePoolSize</code>，那么将<strong>提交的任务添加到队列中</strong>，<strong>等待线程池中的线程去队列中取任务</strong></li>
<li><strong>如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 <code>maximumPoolSize</code>，如果此时线程数超过了 <code>maximumPoolSize</code>，那么执行拒绝策略</strong></li>
</ol>
<p><font color="red"><strong>注意：</strong></font>如果将队列设置为<strong>无界队列</strong>，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了</p>
<h3 id="线程池的状态和状态间的转换"><a href="#线程池的状态和状态间的转换" class="headerlink" title="线程池的状态和状态间的转换"></a>线程池的状态和状态间的转换</h3><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li><p><strong><font color="blue">RUNNING（-1）</font></strong>：这是正常的状态：接受新的任务，处理等待队列中的任务</p>
</li>
<li><p><strong><font color="blue">SHUTDOWN（0）：</font></strong>不接受新的任务提交，但是会继续处理等待队列中的任务</p>
</li>
<li><p><strong><font color="blue">STOP（1）：</font></strong>不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</p>
</li>
<li><p><strong><font color="blue">TIDYING（2）：</font></strong>所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</p>
</li>
<li><p><strong><font color="blue">TERMINATED（3）：</font></strong>terminated() 方法结束后，线程池的状态就会变成这个</p>
</li>
</ul>
<blockquote>
<p><strong>线程池状态</strong>等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断</p>
</blockquote>
<h4 id="状态间的切换"><a href="#状态间的切换" class="headerlink" title="状态间的切换"></a>状态间的切换</h4><ul>
<li><p><strong><font color="green">RUNNING -&gt; SHUTDOWN：</font></strong>当调用了 <strong>shutdown()</strong> 后，会发生这个状态转换，这也是最重要的</p>
</li>
<li><p><strong><font color="green">(RUNNING or SHUTDOWN) -&gt; STOP：</font></strong>当调用 <strong>shutdownNow()</strong> 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</p>
</li>
<li><p><strong><font color="green">SHUTDOWN -&gt; TIDYING：</font></strong>当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</p>
</li>
<li><p><strong><font color="green">STOP -&gt; TIDYING：</font></strong>当任务队列清空后，发生这个转换</p>
</li>
<li><p><strong><font color="green">TIDYING -&gt; TERMINATED：</font></strong>这个前面说了，当 terminated() 方法结束后</p>
</li>
</ul>
<h3 id="ThreadPoolExecutor总结"><a href="#ThreadPoolExecutor总结" class="headerlink" title="ThreadPoolExecutor总结"></a>ThreadPoolExecutor总结</h3><ol>
<li><p><code>corePoolSize</code> 到 <code>maximumPoolSize</code> 之间的线程<strong>会被回收</strong>，<code>corePoolSize</code>  的线程也可以通过设置而得到回收（<code>allowCoreThreadTimeOut(true)</code>）</p>
</li>
<li><p><strong><code>workQueue</code> 用于存放任务，</strong>添加任务的时候，如果当前线程数超过了 <code>corePoolSize</code>，那么往该队列中插入任务，<strong>线程池中的线程会负责到队列中拉取任务</strong></p>
</li>
<li><p>如果某个任务执行<strong>出现异常</strong>，那么<strong><font color="red">执行任务的线程会被关闭</font></strong>，而不是继续接收其他任务。然后会<strong>启动一个新的线程来代替它</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/List总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/List总结/" itemprop="url">List总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T23:03:52+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>ArrayList底层实现是数组，而且允许元素为null值</li>
<li><font color="red"><strong>增加和删除的操作效率低，因为有扩容和数组复制的开销存在</strong></font>（如果是根据下标去删除元素的会比较快）</li>
<li><font color="green"><strong>查询和修改的效率较高，可以直接通过下标去访问元素，时间复杂度为O(1)</strong></font></li>
<li>ArrayList 插入元素需要复制的元素，所以 <font color="blue"><strong>ArrayList 插入元素的位置越靠后效率越高</strong></font></li>
<li>多线程操作同一个ArrayList是不安全的</li>
</ul>
<blockquote>
<p>PS：如果事先知道要存储的元素个数，那么最好使用带<code>int</code>参数的构造函数，因为这样能够减少数组扩容的开销</p>
</blockquote>
<h3 id="大致结构"><a href="#大致结构" class="headerlink" title="大致结构"></a>大致结构</h3><p>​    ArrayList是使用数组实现的列表，具有顺序性。ArrayList内部使用了<code>transient Object[] elementData;</code> 来存储列表中的元素（即数组的缓存区）；ArrayList的容量就是该缓存区的数组长度</p>
<ol>
<li><p><code>private static final int DEFAULT_CAPACITY = 10</code> <strong>默认容量</strong>，只有在add的时候判断elementData是空数组的时候，就会初始化这个默认容量的数组赋值给elementData</p>
</li>
<li><p><code>modCount</code> 这个属性是用来记录List列表的表结构发生变化的次数（要对list的结构发生变化的操作，都会使得modCount的值进行加一；结构性操作指对列表长度进行修改的，即add/remove操作）；这个属性比较重要</p>
</li>
</ol>
<blockquote>
<p>modCount其实是<strong>fail-fast 机制</strong>的实现，即当某一个线程A通过<code>Iterator</code>去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出<code>ConcurrentModificationException</code>异常，产生fail-fast事件</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>无参构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="comment">//无参的构造函数得到的是一个空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>带int参数的构造方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数大于0返回<code>int</code>大小的数组</li>
<li>参数为0返回空的数组</li>
<li>参数小于0则抛出异常<code>IllegalArgumentException</code></li>
</ul>
<ol start="3">
<li>构造一个包含指定元素的列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// c.toArray might (incorrectly) not return Object[]</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    构造指定元素的列表，当指定的元素为空时返回的是一个空的数组；如果元素不为空，那么直接得到一个指定元素的数组</p>
<p>​    这里有个官方的注释，这里的作用是：如果得到的element数组类型不是Obejct类型的数组，那么就要将其转换成Object类型的数组，至于这样做的原因是：</p>
<blockquote>
<p>如果没有这个Object类型转换的情况会是怎么样的，我们模拟一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;(Arrays.asList(<span class="string">"yes"</span>, <span class="string">"no"</span>));</span><br><span class="line">&gt; list.set(<span class="number">0</span>, <span class="keyword">new</span> Object());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<font color="red"><strong>注意：此处模拟指没有类型转换的情况</strong></font>

<p>执行上面的代码，会调用指定元素的构造方法（推荐debug看）</p>
<ol>
<li><p>当执行<code>elementData = c.toArray();</code> 之后，elementData会是 String[] 类型的数组，而不是 Object[] 类型的</p>
</li>
<li><p>那么执行完该构造方法之后，上面代码就会等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    Object[] list = <span class="keyword">new</span> String[]&#123;<span class="string">"yes"</span>,<span class="string">"no"</span>&#125;;</span><br><span class="line">&gt;    list[<span class="number">0</span>]=<span class="keyword">new</span> Object();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>然后当你再执行<code>list.set(0, new Object());</code> 的时候，就会抛出<code>ArrayStoreException</code> 异常了</li>
</ol>
<p>根本原因是<code>toArray()</code>方法中调用的是<code>copyOf</code> 方法，该方法实际使用的是泛型，虽然返回的是 Object[] 类型的数组，但是<strong>实际的类型</strong>已经声明成 String[] 了</p>
</blockquote>
<h3 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><h4 id="System-arraycopy、Arrays-copyOf"><a href="#System-arraycopy、Arrays-copyOf" class="headerlink" title="System.arraycopy、Arrays.copyOf"></a>System.arraycopy、Arrays.copyOf</h4><p>了解这两个方法对看下面几个方法很有帮助</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src      源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos   源数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest     目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos  指定目标数据中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length   要复制的数组元素的数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> original 	要复制的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLength 要返回的副本的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newType 	要返回的副本的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行顺序1.</span></span><br><span class="line"><span class="comment">//size默认值是0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.其实是执行3和4的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这个方法是计算list的容量的:</span></span><br><span class="line"><span class="comment">  *    上面add方法调用的时候会传入(size+1)到这个计算的方法中</span></span><br><span class="line"><span class="comment">  *    如果当前的数组是空数组,那么就比较(size+1)与默认的容量(默认是10),取较大的值返回.</span></span><br><span class="line"><span class="comment">  *    如果不是空数组,那么直接返回(size+1)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//默认容量DEFAULT_CAPACITY是10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 因为是add操作,对列表结构有改动,需要modCount++</span></span><br><span class="line"><span class="comment">  * 如果传入的(size+1)值大于当前数组的长度的时候,才对此数组进行扩容的操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.如果是超过当前数组长度才需要进行数组扩容的操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果新数组大小还是小于传入的容量的话,那就直接取传入的容量作为新数组的长度</span></span><br><span class="line"><span class="comment"> * 如果新数组的长度要比最大定义的数组长的话</span></span><br><span class="line"><span class="comment"> *      (最大的数组长度是Integer.MAX_VALUE-8)</span></span><br><span class="line"><span class="comment"> *      那么就直接使用Integer.MAX_VALUE作为数组的长度.</span></span><br><span class="line"><span class="comment"> * 然后就将数组的元素拷贝到一个新的数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//右移1位，此处得到新容量是旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <code>addAll(Collection&lt;? extends E&gt; c)</code> 方法和普通add方法类似，主要使用了<code>System.arraycopy</code>方法来拷贝指定元素</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入到index的下标的位置,然后返回旧的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><ol>
<li>根据传入下标来移除列表中的元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	<span class="comment">//删除操作修改了列表结构</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">	<span class="comment">//需要进行移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//移动数组的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//更新列表的元素个数,清除最后一个元素,让GC回收</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据传入的对象来删除元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//移除null值元素</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//for循环遍历列表,根据对象的equals方法来移除对应元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法是移除列表中的元素,根据下标志移除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>移除包含指定元素的列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果参数为null,那么抛出异常</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意此处的complement是false</span></span><br><span class="line">        <span class="comment">//所以就是将elementData中不存在c中的元素留下</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//这里的判断的原因是因为 contains 方法可能会抛出异常</span></span><br><span class="line">        <span class="comment">//如果抛出异常的情况下,就需要对 elementData 进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里很简单,清除元素,修改 modCount 的值,然后返回true</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的迭代器"><a href="#ArrayList的迭代器" class="headerlink" title="ArrayList的迭代器"></a>ArrayList的迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList使用的迭代器是其内部类<code>Itr</code></p>
<blockquote>
<p>其内部类还有<code>ListItr</code>也是迭代器，只是这个迭代器可以在任意方向遍历列表，即可以向前/向后遍历。可以通过<code>public ListIterator&lt;E&gt; listIterator()</code>方法得到该迭代器</p>
</blockquote>
<p>此处专注于迭代器<code>Itr</code>，先来查看该类的属性</p>
<ul>
<li><code>int cursor</code>  ：要返回的下一个元素的索引</li>
<li><code>int lastRet = -1</code>：返回的最后一个元素的索引，如果没有返回-1</li>
<li><code>int expectedModCount = modCount</code>：结构修改次数</li>
</ul>
<ol>
<li>遍历元素的方法</li>
</ol>
<p>在遍历元素前列表都会比较结构修改次数，如果结构修改次数不对应，那么会抛出<code>ConcurrentModificationException</code>异常；所以在多线程对同个列表进行迭代和增删操作的时候，很大可能会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否还有下一个可遍历的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">//这里都是判断下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">//游标+1</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在获取元素之前，需要先判断列表结构是否被修改过</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>移除元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个地方就是为什么需要先执行 next 方法后才能调用 remove 方法的原因</span></span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="comment">//在移除元素之前，需要先判断列表结构是否被修改过</span></span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用arrayList的remove方法</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="comment">//重置一下游标,因为 next 操作里面将游标+1了</span></span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新结构修改次数，上面调用remove方法导致modCount增加了</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的遍历方式及问题"><a href="#ArrayList的遍历方式及问题" class="headerlink" title="ArrayList的遍历方式及问题"></a>ArrayList的遍历方式及问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * List的遍历方式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cycleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.asList(ints) 将数组转成List</span></span><br><span class="line">    List&lt;Integer&gt; lists = Arrays.asList(ints);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.for循环遍历</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * foreach循环(增强for循环)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lists.size();i++) &#123;</span><br><span class="line">        System.out.println(lists.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : lists) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 2.迭代器遍历</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = lists.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 3.JDK8的stream流方式</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    lists.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>for循环遍历元素的时候，如果需要在for循环中删除元素，此时需要注意：</p>
<ul>
<li>使用foreach（即增强for循环）的话会有下标越界问题</li>
<li>for循环如果长度length是每次判断都重新获取的话是没有问题的</li>
<li>for循环如果是事先定义好长度length的话会发生下标越界问题</li>
</ul>
<h3 id="ArrayList元素去重"><a href="#ArrayList元素去重" class="headerlink" title="ArrayList元素去重"></a>ArrayList元素去重</h3><h4 id="遍历列表去重"><a href="#遍历列表去重" class="headerlink" title="遍历列表去重"></a>遍历列表去重</h4><p>实现思路：</p>
<ol>
<li>定义（new）一个新的List集合</li>
<li>遍历原集合中的每一个元素，然后判断新集合中是否包含了该元素<ul>
<li>包含就不添加到新集合</li>
<li>不包含则加到新集合中</li>
</ul>
</li>
<li>然后返回新的集合得到去重后的List</li>
</ol>
<h4 id="自定义对象去重"><a href="#自定义对象去重" class="headerlink" title="自定义对象去重"></a>自定义对象去重</h4><p>实现思路：跟遍历去重方式思路基本上一致，只是对于对象的遍历判断，是需要重写equals和hasCode方法来比较对象是否重复</p>
<h4 id="JDK8的流方式去重"><a href="#JDK8的流方式去重" class="headerlink" title="JDK8的流方式去重"></a>JDK8的流方式去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<font color="red"><strong>注意：</strong></font> 如果列表中是对象的话，一定要重写对象的<code>equals()</code> 和<code>hasCode()</code> 方法来定义对象是否重复的规则<br><br><br><br>### SubList方法的坑<br><br>SubList方法能够返回指定下标区间的父List的<strong>视图</strong>、<strong>视图</strong>、<strong>视图</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不包含toIndex下标的元素，即左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line">SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">    <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><font color="red">要注意的地方就是</font></strong>：调用这个方法并不是返回一个全新的列表，而是返回一个视图。所以在操作这个方法得到的视图会影响原列表的内容。简单来说就是subList后得到的列表跟原列表是同一个对象<br><br><br><br>## LinkedList<br><br>### 小结<br><br>- LinkedList底层的实现是链表（双向链表），可以允许元素为null值，<strong>LinkedList是有序集合</strong><br>- <font color="green"><strong>增加和删除的时候只需要修改节点上的指针即可，效率比较高</strong></font><br>- <font color="red"><strong>查找和修改的时候就只能从链表的头出发一直往下遍历找到该目标元素的节点才能进行操作，效率很低</strong></font><br>- <font color="blue">LinkedList内部查询的时候使用的<strong><code>size &gt;&gt; 1</code> </strong>的方式（即折半法查找）来查找index，从而提高查询的效率</font><br>- LinkedList 集合插入元素的位置影响 LinkedList 集合插入的效率，<font color="red">插入位置越靠前或者越靠后，效率越高；位置越中间效率低</font>



<h3 id="大致结构-1"><a href="#大致结构-1" class="headerlink" title="大致结构"></a>大致结构</h3><ol>
<li><code>transient Node&lt;E&gt; first</code> 存放头结点</li>
<li><code>transient Node&lt;E&gt; last</code> 存放尾节点</li>
<li>modCount：<strong>fail-fast机制</strong></li>
<li>Node节点；LinkedList内部使用了Node类的存放元素的，新增元素的时候，会将元素包装成Node节点来进行操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;        <span class="comment">//元素</span></span><br><span class="line">    Node&lt;E&gt; next;  <span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;  <span class="comment">//前置节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>无参构造（真无参。。）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>指定元素列表的构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用addAll方法，这个下面详说</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增删改查方法-1"><a href="#增删改查方法-1" class="headerlink" title="增删改查方法"></a>增删改查方法</h3><h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><p>LinkedList的增加方法的核心是<code>linkBefore(E e, Node&lt;E&gt; succ)</code>、<code>linkFirst(E e)</code>、<code>linkLast(E e)</code>和<code>node(int index)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素到链表末尾</span></span><br><span class="line"><span class="comment">//将元素包装成Node节点,然后就是链表的操作了</span></span><br><span class="line"><span class="comment">//	如果尾节点是空的,那么将该节点作为头和尾节点</span></span><br><span class="line"><span class="comment">//	如果尾节点非空,那么将该节点作为尾节点,并且加入到链表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素到链表头</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表操作,将 e 插入到 succ 前面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// succ 不能为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//即succ是头节点的情况</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用折半法得到index所在的位置(左/右区间)</span></span><br><span class="line"><span class="comment"> * 然后采用for循环遍历的方式得到index位置上的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">//注意：这里是从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>add(E e)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入链表的末尾</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>add(int index, E element)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">//添加到链表最后,即调用上面的add(E e)方法</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//插入node(index)节点之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查下标是否越界和index是否小于0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>addAll</code>方法，带参构造函数中也调用此方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//得到指定插入的元素</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//获取插入位置的前驱和后继节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//for循环插入指定元素,并且设置好上面的前驱和后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Get-1"><a href="#Get-1" class="headerlink" title="Get"></a>Get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回头节点元素内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回尾节点元素内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取指定下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//折半for循环查找指定下标的元素</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查下标是否越界和index是否小于0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Remove-1"><a href="#Remove-1" class="headerlink" title="Remove"></a>Remove</h4><p>LinkedList的删除方法的核心是<code>unlink(Node&lt;E&gt; x)</code>、<code>unlinkFirst(Node&lt;E&gt; f)</code>和<code>unlinkLast(Node&lt;E&gt; l)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求参数 x 不能为null</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到需要删除节点的内容、前驱节点和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该节点是头结点的情况</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//该节点是尾节点的情况</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要求f是头节点并且不为null</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//链表元素只有一个的情况</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要求l是尾节点并且不为null</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//链表元素只有一个的情况</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>remove()</code>移除第一个节点，即当前头节点</li>
<li><code>remove(int index)</code>移除下标是index的节点，先检查下标是否越界，再利用<code>node(int index)</code>方法得到节点，最后用<code>unlink(Node&lt;E&gt; x)</code>移除</li>
<li><code>removeFirst()</code>和<code>removeLast()</code>方法。根据名称可知作用，如果头结点/尾节点为null的情况，即链表为空的情况会抛出<code>NoSuchElementException</code>，然后各自调用<code>unlinkFirst</code>和<code>unlinkLast</code>删除节点</li>
<li><code>remove(Object o)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定元素的节点，利用for循环便利链表，找到第一个配对的元素删除</span></span><br><span class="line"><span class="comment">//注意：如果链表有多个相同的元素，该方法只会删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查下标是否越界或者index是否小于0</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//找到index下标的元素,更新该item内容后返回旧值</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pop、poll、peek、push、offer"><a href="#pop、poll、peek、push、offer" class="headerlink" title="pop、poll、peek、push、offer"></a>pop、poll、peek、push、offer</h4><ol>
<li><strong>peek获取头结点</strong>；<font color="red">如果链表为空则返回null</font></li>
<li><strong>pop弹出头结点</strong>，头结点会被删除。如果链表为空，那么抛出<code>NoSuchElementException</code></li>
<li><strong>poll弹出头结点</strong>，头结点会被删除。如果链表为空则返回null</li>
<li><strong>push插入元素作为头结点</strong></li>
<li><strong>offer插入节点到链表末尾，相当于入队操作</strong></li>
</ol>
<p><strong>peek和pop方法的区别是：</strong>peek方法和pop方法都是返回头节点的元素，但是<strong><font color="red">peek方法不会删除头结点只返回null，而pop方法会删除头节点（相当于出栈）</font></strong></p>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><h3 id="底层实现和线程安全问题"><a href="#底层实现和线程安全问题" class="headerlink" title="底层实现和线程安全问题"></a>底层实现和线程安全问题</h3><ul>
<li>ArrayList<ul>
<li>底层数据结构是数组。线程不安全</li>
</ul>
</li>
<li>LinkedList<ul>
<li>底层数据结构是链表。线程不安全</li>
</ul>
</li>
<li>Vector<ul>
<li>底层数据结构是数组。线程安全（方法都加上了<code>synchronized</code>同步锁）</li>
</ul>
</li>
</ul>
<h3 id="增删改查方面"><a href="#增删改查方面" class="headerlink" title="增删改查方面"></a>增删改查方面</h3><p><strong>总体来说：</strong></p>
<ul>
<li>ArrayList 查询和修改要比 LinkedList 快</li>
<li>LinkedList 增加和删除要比 ArrayList 快</li>
</ul>
<font color="red"><strong>注意：上面是总体而已，某些情况下不成立</strong></font>

<ol>
<li>如果<strong>删除元素是删除末尾元素</strong>的情况下，ArrayList 要比 LinkedList 快，因为 LinkedList 需要操作前后指针</li>
<li>如果<strong>删除的是中间的位置的元素</strong>，还是 ArrayList 快，因为 LinkedList 的折半查找法分别是从 头/尾 往中间找元素的，所以索引越靠近中间，LinkedList 的性能就越差</li>
<li>如果<strong>增加的元素一直都是在列表的最后增加</strong>， 那么 ArrayList 会比 LinkedList 快；此时的扩容操作占整体时间是很少的，而 LinkedList 还需要新建对象并且操作链表的前驱和后继节点</li>
</ol>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>​    <code>CopyOnWriteArrayList</code>是JUC包提供的线程安全的ArrayList，底层通过<strong>复制数组</strong>的方式来实现；<code>CopyOnWriteArrayList</code>在迭代器遍历的使用不会抛出<code>ConcurrentModificationException</code>异常（即没有快速失败机制），并且迭代器遍历的时候就不用额外加锁</p>
<p>​    copy-on-write是指写时复制；如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取<strong>相同的指针指向相同的资源</strong>，直到某个调用者<strong>试图修改</strong>资源的内容时，系统才会<strong>真正复制一份专用副本</strong>（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变</p>
<blockquote>
<p> <strong>优点</strong>是如果调用者<strong>没有修改该资源，就不会有副本</strong>（private copy）被建立，因此多个调用者只是读取操作时可以<strong>共享同一份资源</strong></p>
</blockquote>
<h3 id="大致结构-2"><a href="#大致结构-2" class="headerlink" title="大致结构"></a>大致结构</h3><ol>
<li><code>final transient ReentrantLock lock = new ReentrantLock()</code> 该列表通过 ReentrantLock 来实现加锁操作</li>
<li><code>private transient volatile Object[] array</code> CowArrayList用来存储数据的数组</li>
</ol>
<h3 id="对数组的修改操作"><a href="#对数组的修改操作" class="headerlink" title="对数组的修改操作"></a>对数组的修改操作</h3><h4 id="add-2"><a href="#add-2" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制一个新的数组，新增操作在新数组上完成</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//将新数组设置到 array 上</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CowArrayList通过复制一个新数组，并且<strong>增加操作在新数组上完成</strong>，最后将array指向到新数组中；跟ArrayList的区别就是：</p>
<ul>
<li>CowArrayList有加锁操作</li>
<li>CowArrayList新增的操作在复制好的新数组上完成，而ArrayList是在原数组上完成</li>
</ul>
<p>CowArrayList的<code>set()</code>、<code>remove()</code>操作都类似<code>add()</code>操作，都是在新数组上完成操作后将array指向新数组</p>
<h3 id="剖析迭代器"><a href="#剖析迭代器" class="headerlink" title="剖析迭代器"></a>剖析迭代器</h3><p>​    因为<code>CopyOnWriteArrayList</code>在迭代器遍历的使用不会抛出<code>ConcurrentModificationException</code>异常，并且迭代器遍历的时候就不用额外加锁；这个原因就在于<code>CopyOnWriteArrayList</code>在使用迭代器的时候，保存了一份原数组的副本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//原数组的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">//游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList调用 iterator() 执行的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList的迭代器不支持一下方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见：</p>
<p>​    在调用迭代器的方法时，迭代器会保存一份原数组的副本，即<code>snapshot</code>。该迭代器的所有操作都是对原数组进行操作，因此也就没有线程间的读写问题了，也就不需要快速失败机制和加锁操作了，所以<font color="red">CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong></font></p>
<h3 id="CopyOnWriteArrayList小结"><a href="#CopyOnWriteArrayList小结" class="headerlink" title="CopyOnWriteArrayList小结"></a>CopyOnWriteArrayList小结</h3><ul>
<li>如果 CopyOnWriteArrayList 需要经常增删改列表的数据，经常要执行<code>add()、set()、remove()</code>的话，那是比较耗费内存的（因为都需要复制一个新数组进行增删改）</li>
<li><strong>数据一致性</strong>：<font color="red">CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong></font></li>
<li>相对于ArrayList和Vector来说，遍历数组时不会受其他线程对数组操作而造成影响（读的是原数组的副本）</li>
</ul>
<blockquote>
<p>Set 对应的是 CopyOnWriteArraySet</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/跨域请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/跨域请求/" itemprop="url">跨域请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T21:33:24+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>​    <strong>跨域请求</strong>就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为如果协议 + 域名 + 端口号均相同，那么就是同域，否则则是跨域的</p>
<p>​    跨域请求是由于浏览器的<font color="red"><strong>同源策略</strong></font>导致的，浏览器的同源策略是不能没有的（同源策略是浏览器最核心最基础的安全策略）</p>
<ol>
<li><strong>同源策略禁止 Ajax 直接发起跨域HTTP请求（其实可以发送请求，结果被浏览器拦截，不展示），同时 Ajax 请求不能携带与本网站不同源的 Cookie</strong>；如果没有同源策略别的域名就可以拿到你浏览器上其他的Cookie信息，这样会导致很多重要的信息泄露，例如不法的网站可能会利用你的cookie去登录一些网站，盗用你的信息等。</li>
<li>DOM 层面的同源策略限制了来自不同源的<code>Document</code>对象或 JS 脚本，对当前<code>document</code>对象的读取或设置某些属性；没有同源策略，一些脚本就能获取到你的用户密码输入框的内容信息</li>
</ol>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>​    JSONP 是一种非官方的跨域数据交互协议；JSONP 本质上是利用 <script><img><iframe> 等标签不受同源策略限制，可以从不同域加载并执行资源的特性，来实现数据跨域传输</p>
<p>​    <strong>JSONP 的理念就是</strong>：与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段<code>Javascript</code>，在这段  <code>Javascript</code> 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 <code>Javascript</code> 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了</p>
<p>​    JSONP<strong><font color=red>只支持 get请求，只支持 get请求，只支持 get请求</font></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 如果使用了springmvc 3.2以上的版本 和5.0以下的版本可以配置一个jsonp 的 Advice 就可以了</span></span><br><span class="line"><span class="comment">  *   spring会自动做相应的处理</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  注意：springboot2.0以上舍弃了AbstractJsonpResponseBodyAdvice</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonPAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonPAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样如果请求中带 callback 参数，Spring 就知道这个是 jsonp 的请求了</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"callback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * JsonP 只支持get方法</span></span><br><span class="line"><span class="comment">  * 需要配置dataType为 jsonp</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJsonP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"get"</span>,</span><br><span class="line">        url:<span class="string">"http://localhost:8088/getJsonP/value.do"</span>,</span><br><span class="line">        dataType:<span class="string">"jsonp"</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(data.userName);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(<span class="string">"错误了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>​    跨源资源共享 Cross-Origin Resource Sharing(CORS) 是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。换言之，它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpReuest 请求，从而克服 Ajax 只能同源使用的限制</p>
<h4 id="CORS新增的HTTP头信息"><a href="#CORS新增的HTTP头信息" class="headerlink" title="CORS新增的HTTP头信息"></a>CORS新增的HTTP头信息</h4><ol>
<li><p>Access-Control-Allow-Origin  <origin> | *</p>
<blockquote>
<p>​    响应首部中可以携带这个头部表示服务器允许哪些域可以访问该资源</p>
<p>​    origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Methods  <method>[…, <method>] | *</p>
<blockquote>
<p>该首部字段用于预检请求的响应，指明实际请求所允许使用的HTTP方法</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Headers  <field-name>[…, <field-name>] | *</p>
<blockquote>
<p>该首部字段用于预检请求的响应。指明了实际请求中允许携带的首部字段</p>
</blockquote>
</li>
<li><p>Access-Control-Allow-Credentials  true | false</p>
<blockquote>
<p>表示是否允许发送Cookie</p>
<p>​    <strong>注意：</strong>如果需要在 Ajax 中设置和获取 Cookie，那么<code>Access-Control-Allow-Origin</code>首部字段不能设置为<code>*</code> ，必须设置为具体的 origin 源站</p>
</blockquote>
</li>
</ol>
<h4 id="Configuration配置方式"><a href="#Configuration配置方式" class="headerlink" title="Configuration配置方式"></a>Configuration配置方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果使用了springmvc4.2以上的版本，直接使用mvc相关配置即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * springboot 2.0 以上的版本中 WebMvcConfigurerAdapter 已经过时了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  可以实现 WebMvcConfigurer 来达到相同的目的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//addMapping是指定支持跨域的路径     </span></span><br><span class="line">      	registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">              <span class="comment">//如果前端不带cookie过来或者不限制域访问的话，那么设置 .allowedOrigins("*") 即可</span></span><br><span class="line">              <span class="comment">//.allowedOrigins("*")</span></span><br><span class="line">              .allowedOrigins(<span class="string">"http://localhost:8001"</span>, <span class="string">"http://localhost:8002"</span>)</span><br><span class="line">              .allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</span><br><span class="line">              .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * crossDomain: true，这里代表使用跨域请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  xhrFields: &#123;withCredentials: true&#125;</span></span><br><span class="line"><span class="comment"> *      这样配置就可以把 cookie 带过去了,不然我们连 session 都没法维护</span></span><br><span class="line"><span class="comment"> *      当然,如果你没有这个需求,也就不需要配置这个了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    注意：如果配置了true 需要带cookie信息过去的话,后端的Access-Control-Allow-Origin不能配置成 *</span></span><br><span class="line"><span class="comment"> *           需要配置为具体的 origin 源站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"POST"</span>,</span><br><span class="line">        url:<span class="string">"http://localhost:8088/getCors/value.do"</span>,</span><br><span class="line">        dataType:<span class="string">"json"</span>,</span><br><span class="line">        crossDomain: <span class="literal">true</span>,</span><br><span class="line">        xhrFields: &#123;</span><br><span class="line">            withCredentials: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(data.userName);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#userName"</span>).val(<span class="string">"错误了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CrossOrigin注解方式"><a href="#CrossOrigin注解方式" class="headerlink" title="CrossOrigin注解方式"></a>CrossOrigin注解方式</h4><p>​    <strong>除了Configuration的配置方式外，springMVC4.2之后的版本都支持注解的方式</strong>，可以使用<code>@CrossOrigin</code> 注解来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CrossOrigin &#123;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Origin 是 '*'</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] DEFAULT_ORIGINS = <span class="keyword">new</span> String[]&#123;<span class="string">"*"</span>&#125;;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Headers 是 ‘*’</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    String[] DEFAULT_ALLOWED_HEADERS = <span class="keyword">new</span> String[]&#123;<span class="string">"*"</span>&#125;;</span><br><span class="line">    <span class="comment">//默认的Access-Control-Allow-Credentials 是false;即不允许发送cookie</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">boolean</span> DEFAULT_ALLOW_CREDENTIALS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//默认在1800秒内，不需要发出第二次预检请求</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">long</span> DEFAULT_MAX_AGE = <span class="number">1800L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"origins"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] origins() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] allowedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] exposedHeaders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] methods() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">allowCredentials</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">maxAge</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CrossOrigin 注解可以作用在整个Controller上或者作用在方法上</span></span><br><span class="line"><span class="comment"> *      作用在类上是：表示支持拦截整个controller的接口</span></span><br><span class="line"><span class="comment"> *      作用在方法上是：表示支持拦截指定的接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      配置中value和origins等价,均为配置Access-Control-Allow-Origin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CrossOrigin</span>(origins = &#123;<span class="string">"http://localhost:8001"</span>, <span class="string">"http://localhost:8002"</span>&#125;,</span><br><span class="line">            methods = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE&#125;,</span><br><span class="line">            allowCredentials = <span class="string">"true"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getCors"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/value.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsUser <span class="title">getCors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsUser(<span class="string">"我是Cors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpServletResponse方式"><a href="#HttpServletResponse方式" class="headerlink" title="HttpServletResponse方式"></a>HttpServletResponse方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getCors"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/value.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsUser <span class="title">getCors</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        response.addHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsUser(<span class="string">"我是Cors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JsonP和CORS的比较"><a href="#JsonP和CORS的比较" class="headerlink" title="JsonP和CORS的比较"></a>JsonP和CORS的比较</h3><ol>
<li><code>JSONP</code> 只能实现 GET 请求，而 <code>CORS</code> 支持所有类型的 HTTP 请求</li>
<li>使用 CORS 可以使用普通的 XMLHttpRequest 发起请求和获取数据，比 JSONP 有更好的错误处理</li>
<li>CORS 的兼容性比不上 JSONP，一些比较老的浏览器只支持 JSONP</li>
</ol>
</script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/分布式锁及其实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/分布式锁及其实现/" itemprop="url">分布式锁及其实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T19:53:58+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了</p>
<p>​    在分布式场景下，CAP理论已经证明了任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项；所以为了保证在分布式环境下的数据最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</p>
<h3 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h3><ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行 </li>
<li>高可用、高性能的获取锁与释放锁</li>
<li>具备可重入特性</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ol>
<h2 id="分布式锁的三种实现方案"><a href="#分布式锁的三种实现方案" class="headerlink" title="分布式锁的三种实现方案"></a>分布式锁的三种实现方案</h2><h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><p>​    数据库实现分布式锁主要是依赖<strong>唯一索引</strong></p>
<p>（唯一索引：<u>不允许具有索引值相同的行，从而禁止重复的索引或键值</u>。数据库会在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句时进行检查）</p>
<p>​    <font color="green"><strong>实现的思路：</strong></font>在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，因为做了唯一索引，所以即使多个请求同时提交到数据库，都只会保证只有一个操作能够成功，插入成功则获取到该方法的锁，执行完成后删除对应的行数据释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`distributed_lock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'方法名(需要锁住的方法名)'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,  </span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`index_method_name`</span> (<span class="string">`method_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<h4 id="数据库实现分布式锁的增强"><a href="#数据库实现分布式锁的增强" class="headerlink" title="数据库实现分布式锁的增强"></a>数据库实现分布式锁的增强</h4><ol>
<li><font color="blue">该分布式锁依赖数据库的可用性</font>，如果数据库是单点且挂掉，那么分布式锁功能失效<ul>
<li><strong>解决方案：</strong><ul>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">同一个线程在释放锁之前，行数据一直存在，无法再次插入数据；这种情况下该分布式锁不具备可重入性</font><ul>
<li><strong>解决方案</strong>：在表中新增一列用于记录当前获取到锁的机器和线程信息，在该线程再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁</li>
</ul>
</li>
<li><font color="blue">没有锁失效的机制可能会出现在获取锁之后，数据库宕机，对应的行数据没有被删除，等到数据库服务器恢复后，表中的数据仍然存在，从而无法再获取到锁；或者释放锁失败</font><ul>
<li><strong>解决方案</strong>：<ul>
<li>在表中新增一列，用于记录失效时间，并且需要有<strong>定时任务</strong>清除这些失效的数据；此时也需要根据业务需求考虑定时任务的执行时间，不能过长或者过短</li>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">阻塞锁特性</font>，在代码逻辑中增加失败重试机制（while循环），根据业务需求多次去获取锁直到成功或者达到失败次数后返回等等</li>
</ol>
<h4 id="数据库实现分布式锁的问题"><a href="#数据库实现分布式锁的问题" class="headerlink" title="数据库实现分布式锁的问题"></a>数据库实现分布式锁的问题</h4><p>​    虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。</p>
<p>​    但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁</p>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><font color="green"><strong>实现思路</strong></font>：<br><br>- setnx：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0<br><br>1. 获取锁的时候，使用setnx加锁，锁的value值可以是一个随机生成的UUID，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁<br>2. 获取锁的时候设置一个获取锁的超时时间，若超过这个时间则放弃获取锁<br>3. 释放锁的时候，通过随机生成的UUID去匹对锁的键值对是否对应，若是则执行delete释放锁<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 存放redis中的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeOut 分布式锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">lockWithTimeOut</span><span class="params">(String lockName, <span class="keyword">int</span> acquireTimeOut, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先setnx key是否成功;</span></span><br><span class="line"><span class="comment">         *      成功则设置随机值(UUID),然后设置过期时间,返回随机值给释放锁用</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      失败则计算获取锁的超时时间,时间未到则自旋获取锁直到成功或者达到超时时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String identifier = UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        timeout = System.currentTimeMillis() + timeout;</span><br><span class="line">        String reIdentifier = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//带超时时间的循环获取锁实现锁阻塞特性</span></span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() &lt; timeout)&#123;</span><br><span class="line">                Long setnx = jedis.setnx(lockName, identifier);</span><br><span class="line">                <span class="keyword">if</span> (setnx != <span class="keyword">null</span> &amp;&amp; setnx == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//设置过期时间</span></span><br><span class="line">                    jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    reIdentifier = identifier;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//这一步很重要   </span></span><br><span class="line">                 <span class="comment">//如果key已经存在,查看过期时间,如果该key无过期时间则重新设置过期时间,以免发生死锁</span></span><br><span class="line">                    Long ttl = jedis.ttl(lockName);</span><br><span class="line">                    <span class="keyword">if</span> (ttl == -<span class="number">1</span>)&#123;</span><br><span class="line">                        jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程中断"</span>);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 锁的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifier 锁的标识(用来验证锁中的val是否一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockName, String identifier)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            jedis.watch(lockName);</span><br><span class="line">            String result = jedis.get(lockName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; identifier.equals(result))&#123;</span><br><span class="line">                Transaction multi = jedis.multi();</span><br><span class="line">                multi.del(lockName);</span><br><span class="line">                List&lt;Object&gt; exec = multi.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec != <span class="keyword">null</span> &amp;&amp; exec.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### Redis分布式锁的增强<br><br>1. <font color="blue"><strong>锁失效时间</strong></font><br>   - 锁失效的时间需要根据实际业务需求来设置一个合适的值<br>   - <strong><font color="red">如果设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题</font></strong><br>   - <strong>如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间</strong><br>2. <font color="blue">可利用while循环去获取锁，可以设置重试间隔时间和最大重试时间来实现锁阻塞特性</font><br>3. <font color="blue">不可重入</font><br>   - <strong>解决方案</strong>：<br>     - 线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者；释放锁的时候将这些信息删除<br>4. <font color="blue">单点故障</font><br>   - <strong>解决方案：</strong><br>     - Redis集群，Redis主从<br><br><br><br>#### Redis实现分布式锁存在的问题<br><br>​    这类最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：<br><br>1. 在Redis的master节点上拿到了锁<br>2. 但是这个加锁的key还没有同步到slave节点<br>3. master故障，发生故障转移，slave节点升级为master节点<br>4. 导致锁丢失<br><br><br><br>### Zookeeper实现分布式锁<br><br><font color="green"><strong>实现思路：</strong></font>

<p>​    每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的<strong>瞬时有序节点</strong>（EPHEMERAL_SEQUENTIAL）</p>
<p>​    使用Zookeeper可以实现的分布式锁是阻塞的，客户端可以通过在ZK中创建瞬时有序节点，并且在节点上绑定监听器，一旦节点发生变化，ZK会通知客户端，客户端可以检查自己创建的节点是不是<strong><font color="red">当前所有节点中序号最小的</font></strong>，如果是那么自己就获取到锁，反之则继续等待</p>
<p>​     当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题，因为<strong>瞬时节点在会话断开后就会自动删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zookeeper 实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK对象</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分布式锁的根节点</span></span><br><span class="line">    <span class="keyword">private</span> String rootLockNode;</span><br><span class="line">    <span class="comment">// 竞争资源，用来生成子节点名称</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="comment">// 当前锁</span></span><br><span class="line">    <span class="keyword">private</span> String currentLock;</span><br><span class="line">    <span class="comment">// 等待的锁（前一个锁）</span></span><br><span class="line">    <span class="keyword">private</span> String waitLock;</span><br><span class="line">    <span class="comment">// 计数器（用来在加锁失败时阻塞加锁线程）</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造器中创建ZK链接，创建锁的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkAddress     ZK的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rootLockNode  根节点名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName      子节点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperLock</span><span class="params">(String zkAddress, String rootLockNode, String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootLockNode = rootLockNode;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建连接，zkAddress格式为：IP:PORT</span></span><br><span class="line"><span class="comment">             * watcher监听器为自身</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(zkAddress, <span class="keyword">this</span>.sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测锁的根节点是否存在，不存在则创建</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Stat stat = zk.exists(rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == stat) &#123;</span><br><span class="line">                zk.create(rootLockNode, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法，先尝试加锁，不能加锁则等待上一个锁的释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】加锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> waitOtherLock(<span class="keyword">this</span>.waitLock, <span class="keyword">this</span>.sessionTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分隔符</span></span><br><span class="line">        String split = <span class="string">"_lock_"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lockName.contains(<span class="string">"_lock_"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"lockName can't contains '_lock_' "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建锁节点（临时有序节点）并且得到节点名称</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * path: 根节点/子锁名称+分隔符</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.currentLock = zk.create(<span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + <span class="keyword">this</span>.lockName + split, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>],</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"】创建锁节点（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功，开始竞争..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(<span class="keyword">this</span>.rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有正在竞争lockName的锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; lockNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String nodeName : nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodeName.split(split)[<span class="number">0</span>].equals(<span class="keyword">this</span>.lockName)) &#123;</span><br><span class="line">                    lockNodes.add(nodeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(lockNodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取最小节点与当前锁节点比对加锁</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *      比对最小节点的名称是否跟刚才创建的临时节点名称一致</span></span><br><span class="line"><span class="comment">             *      一致则证明当前加锁成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockPath = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + lockNodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.currentLock.equals(currentLockPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁失败，设置前一节点为等待锁节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockNode = <span class="keyword">this</span>.currentLock.substring(<span class="keyword">this</span>.currentLock.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> preNodeIndex = Collections.binarySearch(lockNodes, currentLockNode) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.waitLock = lockNodes.get(preNodeIndex);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁，带超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitLock          当前节点的前一个锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionTimeout    等待获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitOtherLock</span><span class="params">(String waitLock, <span class="keyword">int</span> sessionTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> islock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 监听等待锁节点</span></span><br><span class="line">            String waitLockNode = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + waitLock;</span><br><span class="line">            Stat stat = zk.exists(waitLockNode, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"】锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败，等待锁（"</span> + waitLockNode + <span class="string">"）释放..."</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 设置计数器，使用计数器阻塞线程,带超时时间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                islock = <span class="keyword">this</span>.countDownLatch.await(sessionTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (islock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁成功，锁（"</span> + waitLockNode + <span class="string">"）已经释放"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                islock = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat stat = zk.exists(<span class="keyword">this</span>.currentLock, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】释放锁 "</span> + <span class="keyword">this</span>.currentLock);</span><br><span class="line">                zk.delete(<span class="keyword">this</span>.currentLock, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.currentLock = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点监听器回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听节点删除的事件</span></span><br><span class="line"><span class="comment">         *      计数器减一，恢复线程操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.countDownLatch &amp;&amp; watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Curator的分布式锁"><a href="#Curator的分布式锁" class="headerlink" title="Curator的分布式锁"></a>Curator的分布式锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator 实现的分布式锁:</span></span><br><span class="line"><span class="comment"> *          InterProcessMutex:          分布式可重入排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessSemaphoreMutex: 分布式排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessReadWriteLock:  分布式读写锁</span></span><br><span class="line"><span class="comment"> *          InterProcessMultiLock:      将多个锁作为单个实体管理的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置重试策略，创建zk客户端</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = </span><br><span class="line">            CuratorFrameworkFactory.newClient(<span class="string">"127.0.0.1:2181"</span>, retryPolicy);</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建分布式可重入排他锁，监听客户端为client，锁的根节点为/locks</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InterProcessMutex mutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/locks"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁操作</span></span><br><span class="line"><span class="comment">             *     public boolean acquire(long time, TimeUnit unit)</span></span><br><span class="line"><span class="comment">             *          第一个参数是超时时间</span></span><br><span class="line"><span class="comment">             *          第二个参数是时间的单位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.acquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 释放锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK实现分布式锁的问题"><a href="#ZK实现分布式锁的问题" class="headerlink" title="ZK实现分布式锁的问题"></a>ZK实现分布式锁的问题</h4><p>​    <strong>使用Zookeeper也有可能带来并发问题：</strong>由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了，就可能产生并发问题。</p>
<p>​    这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，<font color="red">Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点（所以选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡）</font></p>
<h3 id="三者的比较"><a href="#三者的比较" class="headerlink" title="三者的比较"></a>三者的比较</h3><ol>
<li><strong>从性能角度（从高到低）</strong><ul>
<li>缓存 &gt; Zookeeper &gt;= 数据库</li>
</ul>
</li>
<li><strong>从可靠性角度（从高到低）</strong><ul>
<li>Zookeeper &gt; 缓存 &gt; 数据库</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/Linux操作系统的五种IO模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/Linux操作系统的五种IO模型/" itemprop="url">Linux操作系统的五种IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T21:23:09+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux操作系统的五种IO模型</p>
<h3 id="Linux系统的IO"><a href="#Linux系统的IO" class="headerlink" title="Linux系统的IO"></a>Linux系统的IO</h3><p>​    Java中常说的IO是指文件的输入和输出；而在操作系统中的一次IO可以简化成把数据从硬件（硬盘）中读取到用户空间中；详细分为<font color="blue">两个阶段</font></p>
<ul>
<li>将数据从磁盘文件先加载到内核内存空间（缓存区），等待数据准备完成，此过程时间较长。（准备数据的阶段）</li>
<li>然后将数据从内核缓冲区复制到用户空间的进程内存中，此过程时间较短（拷贝数据阶段）</li>
</ul>
<p>在了解五种模型前先知道一些名词</p>
<ul>
<li><p>同步/异步：关注点是消息的通信机制</p>
<ul>
<li>同步：调用者等到被调用者返回消息，才能继续往下执行</li>
<li>异步：被调用者通过状态、通知或者回调机制主动通知调用者当前被调用者的状态</li>
</ul>
</li>
<li><p>阻塞/非阻塞：关注点是调用者在等待结果返回之前所处的状态</p>
<ul>
<li>阻塞：指在IO操作彻底完成后才返回到用户空间，在获得调用结果之前被挂起</li>
<li>非阻塞：指在发起IO操作后立即返回给用户一个状态值，无须等到IO操作彻底完成才返回；在调用结果返回之前，用户进程不会被挂起</li>
</ul>
</li>
<li><p>文件描述符FD</p>
<blockquote>
<p>​    文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数</p>
<p>​    实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符</p>
<p>​    在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</p>
</blockquote>
</li>
</ul>
<h3 id="同步阻塞IO模型"><a href="#同步阻塞IO模型" class="headerlink" title="同步阻塞IO模型"></a>同步阻塞IO模型</h3><p>​    同步阻塞UI模型是最简单的IO模型，用户线程在内核进行IO操作的时候被阻塞；用户线程通过系统调用<code>recvfrom</code> 发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，再将接受的数据拷贝到用户空间，这才能完成一次读操作。</p>
<p>​    但是用户在进行读操作的时候，由于内核还不能立刻准备好数据包，应用进程就会阻塞住，直到内核准备好数据包，<code>recvfrom</code> 完成数据报复制工作，应用进程才能结束阻塞状态；这就导致用户在发起IO请求时，不能再进行其他任何操作，这<strong><font color="red">对CPU的资源利用率是很低的</font></strong></p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/同步阻塞IO模型.jpg" alt="同步阻塞IO模型"></p>
<h3 id="同步非阻塞IO模型"><a href="#同步非阻塞IO模型" class="headerlink" title="同步非阻塞IO模型"></a>同步非阻塞IO模型</h3><p>​    用户线程在发起IO请求后立即返回，但是此时并没有读取到任何数据，用户线程需要不断的通过 <code>recvfrom</code> 调用去和内核交互，直到内核准备好数据（即轮询机制）。如果没有准备好，内核会返回<code>error</code>，应用进程在得到<code>error</code>后，过一段时间再发送<code>recvfrom</code>请求。在两次发送请求的时间段，进程可以先做别的事情</p>
<p>​    整个IO请求的过程，虽然用户线程立即返回了，但是为了得到数据还是需要通过轮询机制去请求是否准备好数据；重复的请求会<strong><font color="red">消耗大量的CPU资源</font></strong>，一般很少会直接使用这个模型</p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/同步非阻塞IO模型.jpg" alt="同步非阻塞IO模型"></p>
<h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>​    用户进程可以通过sigaction系统调用注册一个信号处理程序，然后主程序返回不会阻塞；当有IO操作准备就绪时，由内核通知触发一个SIGIO信号处理程序执行，然后将用户进程再通过<code>recvfrom</code>将数据从内核空间拷贝到用户空间（数据拷贝是同步的）</p>
<p>​    这种模型的优势在于等到数据包到达期间进程不会被阻塞，用户主程序可以继续执行，只要等待来自信号处理函数的通知即可（此模式实现复杂，不常用）</p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/信号驱动IO模型.jpg" alt="信号驱动IO模型"></p>
<h3 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h3><p>​    多个进程的IO可以注册到同一个<code>select</code>上，当用户进程调用该<code>select</code>，<code>select</code>会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，<strong>进程调用<code>select</code>后会阻塞</strong>；当任意一个IO所需的数据准备好之后，<code>select</code>调用就会返回，然后用户进程在通过<code>recvfrom</code>来进行数据拷贝</p>
<p>​    虽然<code>select</code>可以同时监控多个IO操作，但是<strong>每个IO请求过程还是会阻塞（阻塞在select函数）</strong>的；进程在发出<code>select</code>后，要等到<code>select</code>监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝</p>
<p>​    所以<strong>如果处理的连接数不是很高的话</strong>，使用<strong>IO多路复用不一定</strong>比使用<strong>多线程 + 阻塞 IO</strong>的性能更好，可能延迟还更大。<font color="red">IO多路复用的优势并不是对于单个连接能处理得更快，而是在于能<strong>处理更多的连接</strong></font></p>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/IO多路复用模型.jpg" alt="IO多路复用模型"></p>
<h4 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h4><p><code>select</code>，<code>poll</code>，<code>epoll</code> 都是多路复用IO的函数；其三者的区别在于：</p>
<ol>
<li><font color="green"><strong>select</strong></font><ul>
<li>select函数会无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点</li>
<li>其缺点在于单个进程<strong>能够监视的文件描述符的数量存在最大限制</strong>，在Linux上32位机默认是1024个，64位机默认是2048。也可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低</li>
</ul>
</li>
<li><font color="green"><strong>poll</strong></font><ul>
<li>poll本质上和select没有区别， <strong><font color="blue">但是它没有最大连接数的限制</font></strong>，原因是它是基于链表来存储的（select是数组存储）</li>
</ul>
</li>
<li><font color="green"><strong>epoll</strong></font><ul>
<li>epoll是通过事件通知的方式（事件关联上fd），只要有可写的IO就会通过回调的方式告知用户进程</li>
<li>epoll的最大连接数也是没有限制的，其基于哈希表来存储</li>
</ul>
</li>
</ol>
<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>​    用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，<strong>直接把数据拷贝到用户空间</strong>，然后再通知进程本次IO已经完成</p>
<p>​    相比于IO多路复用，异步IO并不常用，更多的服务程序会使用IO多路复用模型 + 多线程任务处理的架构来满足业务需求</p>
<p><strong>异步IO与信号驱动最主要的区别是</strong></p>
<ol>
<li>信号驱动IO是由内核通知用户进程何时进行IO操作，而异步IO是内核把数据拷贝到用户空间后才通知用户进程IO操作何时完成</li>
<li>信号驱动还需要用户进程阻塞在从内核空间缓冲区拷贝数据到用户空间，而异步IO是内核直接把所有数据准备好并且拷贝到用户空间后才通知用户进程可以进行后续的操作；<font color="red"><strong>即数据准备阶段两者都是非阻塞的，而数据拷贝阶段，信号驱动是阻塞的而异步IO是非阻塞的</strong></font></li>
</ol>
<p><img src="/2019/05/08/Linux操作系统的五种IO模型/异步IO模型.jpg" alt="异步IO模型"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/正向代理和反向代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/正向代理和反向代理/" itemprop="url">正向代理和反向代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T21:23:20+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正向代理和反向代理</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​    正向代理是一个<font color="red">位于客户端和原始服务器</font>（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p>​    <strong>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互</strong>；客户端必须要进行一些特别的设置才能使用正向代理</p>
<p>​    举个栗子：一个国内用户访问不了Google，但是他能访问到一个代理服务器，这个代理服务器能够访问Google，于是该用户需要先连上代理服务器，然后告诉代理服务器需要访问哪个网站的内容，代理服务器去将网站内容取回来，然后返回给用户。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉访问的网站</p>
<h4 id="正向代理的用途"><a href="#正向代理的用途" class="headerlink" title="正向代理的用途"></a>正向代理的用途</h4><ol>
<li><p><strong>突破访问限制</strong> </p>
<p>​    通过代理服务器，可以突破自身IP访问限制，访问国外网站等</p>
</li>
<li><p><strong>提高访问速度</strong></p>
<p>​    通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度</p>
</li>
<li><p><strong>隐藏客户端真实IP</strong></p>
<p>​    上网者也可以通过这种方法隐藏自己的IP，免受攻击</p>
</li>
</ol>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​    反向代理（Reverse Proxy）是指以代理服务器来接受Internet上的连接请求，然后<font color="red">将请求转发给<strong>内部网络</strong>上的服务器</font>，并将从服务器上得到的结果返回给Internet上请求连接的客户端，<u>此时代理服务器对外就表现为一个服务器</u></p>
<p>​    <strong>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互</strong>；通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理</p>
<h4 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h4><ol>
<li><p><strong>隐藏服务器真实IP</strong></p>
<p>​    使用反向代理，可以对客户端隐藏服务器的IP地址</p>
</li>
<li><p><strong>负载均衡</strong></p>
<p>​    反向代理服务器可以做负载均衡</p>
<p>​    根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</p>
</li>
<li><p><strong>提高访问速度</strong></p>
<p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容<strong><font color="blue">提供缓存服务</font></strong>，提高访问速度</p>
</li>
<li><p><strong>提供安全保障</strong></p>
<p>​    反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</p>
<p>​    还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</p>
</li>
</ol>
<h3 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h3><ol>
<li><p><strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源</p>
<p><strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等</p>
</li>
</ol>
<ol start="2">
<li><p><strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件</p>
<p><strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器</p>
</li>
</ol>
<ol start="3">
<li><p><strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端</p>
<p><strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器</p>
</li>
</ol>
<ol start="4">
<li><p><strong>正向代理主要是用来解决访问限制问题</strong></p>
<p><strong>反向代理则是提供负载均衡、安全防护等作用</strong></p>
</li>
</ol>
<p>图片来源：<a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">https://www.zhihu.com/question/24723688</a></p>
<p><img src="/2019/05/06/正向代理和反向代理/代理.png" alt="代理"></p>
<h3 id="Java获取用户的IP地址"><a href="#Java获取用户的IP地址" class="headerlink" title="Java获取用户的IP地址"></a>Java获取用户的IP地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求的真实ip地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRealIpAdrress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String ipAdrress = <span class="string">""</span>;</span><br><span class="line">        String forwardFor = request.getHeader(<span class="string">"X-Forwarded-For"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!T.isBlank(forwardFor) &amp;&amp; !<span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            <span class="comment">//多次反向代理后会有多个ip值，第一个ip才是真实ip</span></span><br><span class="line">            <span class="keyword">int</span> index = forwardFor.indexOf(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">                ipAdrress = forwardFor.substring(<span class="number">0</span>,index);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ipAdrress = forwardFor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"Proxy-Client-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"WL-Proxy-Client-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"X-Real-IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"HTTP_CLIENT_IP"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getHeader(<span class="string">"HTTP_X_FORWARDED_FOR"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T.isBlank(ipAdrress) || <span class="string">"unKnown"</span>.equalsIgnoreCase(forwardFor)) &#123;</span><br><span class="line">            ipAdrress = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ipAdrress;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="getRemoteAddr"><a href="#getRemoteAddr" class="headerlink" title="getRemoteAddr"></a>getRemoteAddr</h4><p>​    <code>request.getRemoteAddr()</code>获取客户端的ip地址</p>
<p>​    但是如果使用了反向代理软件，例如Nginx，用request.getRemoteAddr()方法获取的IP地址都会是反向代理服务器的ip，而并不是客户端的真实IP。<br>​    经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了<strong>X-Forwarded-For</strong>信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址</p>
<h4 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-<strong>For</strong></h4><p>​    X-Forwarded-For是用来识别通过<font color="red"><strong>HTTP代理或负载均衡</strong></font>方式连接到Web服务器的客户端<font color="blue">最原始的IP地址</font>的HTTP请求头字段</p>
<p>​    如果有配置X-Forwarded-For设置的话，每次经过proxy转发都会有记录，格式就是：</p>
<p>（client1, proxy1, proxy2） 以逗号隔开各个地址（client指客户端IP，proxy指反向代理服务器的IP）</p>
<p>即设置了X-Forwarded-For，取逗号分隔的第一项即为客户端的IP</p>
<p>在代理转发及反向代理中经常使用X-Forwarded-For 字段</p>
<ol>
<li><p>代理转发（正向代理）</p>
<blockquote>
<p>​    在代理转发的场景中，你可以通过内部代理链以及记录在网关设备上的IP地址追踪到网络中客户端的IP地址</p>
<p>​    处于安全考虑，网关设备在把请求发送到外网（因特网）前，应该<font color="red"><strong>去除 X-Forwarded-For 字段里的所有信息</strong></font></p>
<p>​    这种情况下所有的信息都是在你的内部网络内生成，因此X-Forwarded-For字段中的信息应该是可靠的</p>
</blockquote>
</li>
<li><p>反向代理</p>
<blockquote>
<p>​    在反向代理的情况下，你可以追踪到互联网上连接到你的服务器的客户端的IP地址，即使你的网络服务器和互联网在路由上是不可达的</p>
<p>​    这种情况下你不应该信任所有X-Forwarded-For信息，其中有部分可能是伪造的。因此需要建立一个信任白名单来确保X-Forwarded-For中哪些IP地址对你是可信的</p>
<p>​    最后一次代理服务器的地址并没有记录在代理链中，因此只记录 X-Forwarded-For 字段是不够的。完整起见，Web服务器应该记录请求来源的IP地址以及X-Forwarded-For 字段信息</p>
</blockquote>
</li>
</ol>
<h5 id="X-Forwarded-For-和-X-Real-IP-区别"><a href="#X-Forwarded-For-和-X-Real-IP-区别" class="headerlink" title="X-Forwarded-For 和 X-Real-IP**    区别"></a>X-Forwarded-For<strong> 和 </strong>X-Real-IP**    区别</h5><p>​    X-Real-IP如果经过多级代理的情况下，其记录的IP不一定是真实的客户端IP；如果有多级代理，x-forwarded-for效果是大于x-real-ip的，可以记录完整的代理链路</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/Zookeeper小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/Zookeeper小结/" itemprop="url">zookeeper小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T11:18:00+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Zookeeper？"><a href="#什么是Zookeeper？" class="headerlink" title="什么是Zookeeper？"></a>什么是Zookeeper？</h2><p>​        Zookeeper是一个开源的<strong>分布式的，为分布式应用提供协调服务</strong>的Apache项目。</p>
<p>​        ZooKeeper是一个经典的<strong><font color="red">分布式数据一致性解决方案</font></strong>，致力于为分布式应用提供一个高性能、高可用，且具有<strong>严格顺序访问</strong>控制能力的分布式协调服务</p>
<p>​        分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负载均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。</p>
<h3 id="zookeeper的一些特点"><a href="#zookeeper的一些特点" class="headerlink" title="zookeeper的一些特点"></a>zookeeper的一些特点</h3><ol>
<li>顺序一致性：从同一个client客户端发来的请求，会按其发送的顺序来执行</li>
<li>原子性：一次数据处理要么全部成功，要么全部失败</li>
<li>数据一致性：每个Server保存一份相同的数据，客户端无论连接到哪个Server，数据都是一致的</li>
<li>实时性：在一定时间范围内，客户端能够读取到最新的数据</li>
</ol>
<h3 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h3><p>​        ZK会维护一个具有层次关系的树状的数据结构，每个树节点称为一个ZNode。每个ZNode默认能够存储1MB的数据，每个ZNode都可以通过路径唯一标识</p>
<p>​        一个ZNode既能在它下面创建子节点，作为路径标识的一部分，同时该节点也能存储数据；主要存放分布式应用的配置信息和状态信息等</p>
<p>​        每个ZNode节点都有各自的版本号，当节点数据发生变化是，那该节点的版本号也会累加（乐观锁的机制）</p>
<p><strong>节点类型</strong></p>
<ul>
<li>持久（Persistent）：客户端和服务器断开连接后，创建的节点不会被删除</li>
<li>短暂（Ephemeral）：客户端和服务器断开连接后，创建的节点会自动删除</li>
</ul>
<blockquote>
<p>​        创建ZNode节点的时候可以设置顺序标识，ZNode名称后会附加一个顺序号，这个顺序号是单调递增的计数器，并且是由父节点来维护的</p>
<p>​        注意：在分布式系统中，顺序号可以被用于所有事件的全局排序；客户端可以通过顺序号来推断事件的执行顺序</p>
</blockquote>
<h3 id="Zookeeper的应用场景"><a href="#Zookeeper的应用场景" class="headerlink" title="Zookeeper的应用场景"></a>Zookeeper的应用场景</h3><ol>
<li><p><strong>统一命名服务</strong></p>
<blockquote>
<p>在分布式环境下，对应用/服务进行统一的命名，会便于识别</p>
<p>对外只显示服务的名称，通过节点去访问对应IP的服务</p>
</blockquote>
</li>
<li><p><strong>统一配置管理</strong></p>
<blockquote>
<p>​        集群中一般要求所有节点的配置信息是一致的，例如Kafka集群。并且对配置文件修改后，能够快速更新到各个节点上</p>
<p>​        可以将配置信息写入ZNode中，各个客户端监听该配置信息的状态，一旦ZNode中的数据发生改变，可以及时通知各个客户端将最新的配置信息更新到系统中</p>
</blockquote>
</li>
<li><p><strong>统一集群管理</strong></p>
<blockquote>
<p>​        服务节点动态上下线，当ZK中注册的服务下线时，客户端能够实时的得到下线通知；这里可以通过ZK的监听器去监听节点的动态新增/删除</p>
</blockquote>
</li>
<li><p><strong>分布式锁</strong></p>
<blockquote>
</blockquote>
</li>
<li><p>软负载均衡</p>
<blockquote>
<p>ZK记录节点上的服务，可以让访问数最少的服务器去处理最新的客户端请求</p>
</blockquote>
</li>
</ol>
<h2 id="ZK安装"><a href="#ZK安装" class="headerlink" title="ZK安装"></a>ZK安装</h2><blockquote>
<p>​        注意：下面操作没有设置环境变量，如果设置的环境变量，那么可以在<strong>全局环境</strong>下直接使用zkServer.sh或者zkCli.sh</p>
<p>设置方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> vim /etc/profile</span><br><span class="line"><span class="meta">&gt;</span> export ZOOKEEPER_HOME=/opt/zookeeper</span><br><span class="line"><span class="meta">&gt;</span> export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ol>
<li><p>解压tar.gz文件到指定目录下（/opt）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制conf下的zoo_sample.cfg为新文件zoo.cfg，并且在zookeeper的主目录下创建data文件夹，并在配置文件中设置data目录和dataLog目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zookeeper/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">cd /opt/zookeeper</span><br><span class="line">mkdir data</span><br><span class="line">vim /opt/zookeeper/conf/zoo.cfg</span><br><span class="line">	dataDir=/opt/zookeeper/data</span><br><span class="line">	dataLogDir=/opt/zookeeper/dataLog</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zk</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span>关闭zk</span><br><span class="line">bin/zkServer.sh stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk的状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#查看zk进程是否启动</span><br><span class="line">jps</span><br><span class="line">	4020 Jps</span><br><span class="line">	4001 QuorumPeerMain</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h3><ol>
<li><p>在data目录下创建myid文件，在文件上添加ZK编号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch myid</span><br><span class="line">	1</span><br><span class="line"><span class="meta">#</span>#其他ZK的机子上需要添加不同的编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 zoo.cfg 配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim zoo.cfg</span><br><span class="line"><span class="meta">	#</span>######################cluster##########################</span><br><span class="line">    server.1=zk1:2888:3888</span><br><span class="line">    server.2=zk2:2888:3888</span><br><span class="line">    server.3=zk3:2888:3888</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span>######################cluster##########################</span><br><span class="line">server.1=localhost:2881:3881</span><br><span class="line">server.2=localhost:2882:3882</span><br><span class="line">server.3=localhost:2883:3883</span><br></pre></td></tr></table></figure>
<p>配置文件解析：</p>
<ul>
<li>server后面的数字就是 myid 文件制定的编号</li>
<li>zk1 是你服务器的 ip 地址</li>
<li>2888 是zk集群的信息交换端口（不一定是2888，可自行指定）</li>
<li>3888 是zk集群中Leader节点挂了之后重新选择Leader节点时进行通信的端口（同样可自行选择其他端口）</li>
</ul>
</li>
</ol>
<h2 id="深入学习Zookeeper"><a href="#深入学习Zookeeper" class="headerlink" title="深入学习Zookeeper"></a>深入学习Zookeeper</h2><h3 id="ZK配置文件"><a href="#ZK配置文件" class="headerlink" title="ZK配置文件"></a>ZK配置文件</h3><ol>
<li><p>tickTime</p>
<p>通信心跳数，Zookeeper<strong>服务器与客户端</strong>心跳时间，单位毫秒</p>
<blockquote>
<p>​        Zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳，时间单位为毫秒</p>
<p>​        它用于心跳机制，并且设置最小的session（会话）超时时间为两倍心跳时间（session的最小超时时间是2*tickTime）</p>
</blockquote>
</li>
<li><p>initLimit</p>
<p>集群中主从服务器之间的<strong>初始通信时限</strong></p>
<blockquote>
<p>​        集群中的Follower跟随者服务器与Leader领导者服务器之间初始连接时能容忍的最多心跳数（tickTime的数量），用它来限定集群中的Zookeeper服务器连接到Leader的时限</p>
</blockquote>
</li>
<li><p>syncLimit</p>
<p>集群中主从服务器之间的<strong>同步通信时限</strong></p>
<blockquote>
<p>​        集群中Leader与Follower之间的最大响应时间单位，假如响应超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer</p>
</blockquote>
</li>
<li><p>dataDir</p>
<p>数据文件目录+数据持久化路径</p>
</li>
<li><p>dataLogDir</p>
<p>日志文件目录，如果不配置则使用dataDir的目录进行日志的存放</p>
</li>
<li><p>clientPort </p>
<p>监听客户端连接的端口，默认是2181</p>
</li>
</ol>
<h3 id="ZK集群"><a href="#ZK集群" class="headerlink" title="ZK集群"></a>ZK集群</h3><h4 id="选举机制中的基础概念"><a href="#选举机制中的基础概念" class="headerlink" title="选举机制中的基础概念"></a>选举机制中的基础概念</h4><ol>
<li><p>服务器ID</p>
<blockquote>
<p>即myid文件中的编号；编号越大，权重越大</p>
</blockquote>
</li>
<li><p>Zxid，数据ID</p>
<blockquote>
<p>服务器中存放的最大数据ID；值越大说明该数据越新，权重越大</p>
</blockquote>
</li>
<li><p>Epoch：逻辑时钟</p>
<blockquote>
<p>​    投票的次数（轮数），同一轮投票过程中的逻辑时钟值是相同的</p>
<p>​    每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断</p>
</blockquote>
</li>
<li><p>Server状态：选举状态</p>
<ul>
<li>LOOKING，竞选状态</li>
<li>FOLLOWING，随从状态，同步leader状态，参与投票</li>
<li>OBSERVING，观察状态,同步leader状态，不参与投票</li>
<li>LEADING，领导者状态</li>
</ul>
</li>
</ol>
<h4 id="选举简易流程"><a href="#选举简易流程" class="headerlink" title="选举简易流程"></a>选举简易流程</h4><p>​    目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ol>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于<strong>Looking（竞选状态）</strong></li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果；由于服务器2的编号比服务器1的大，所以服务器2胜出；但此时投票数没有大于半数，所以<strong>两个服务器的状态依然是LOOKING</strong></li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1和2交换信息，由于服务器3的编号最大，所以服务器3胜出，此时投票数正好<strong>大于半数</strong>，所以服务器3成为Leader，服务器1和2成为Follower，状态变成FOLLOWING</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但服务器3的状态已经是Leading，所以服务器4也是Follower</li>
<li>服务器5启动，逻辑同服务器4</li>
</ol>
<p><strong>几种情况的选举</strong></p>
<ol>
<li><p>一台宕机重启的机器加入已有环境，如果已有环境中已经存在Leader，那么该机器会变成Follwoer</p>
</li>
<li><p>一台机器加入正在投票中的环境</p>
<p>所有server都会接受优先级最高的投票，最高优先级最高的选票当选，选举结束</p>
</li>
<li><p>当集群中多数机器宕机重启</p>
<p>​    存活的服务发现不满足多数派，改变状态为LOOKING，投票轮数+1，然后重新开始投票，会按照优先级的选举投票直至结束</p>
<ul>
<li>逻辑时钟小的选举结果被忽略，重新投票</li>
<li>统一逻辑时钟后，数据 version 大的胜出</li>
<li>数据 version 相同的情况下，server id 大的胜出</li>
</ul>
</li>
</ol>
<p>以上，只要有超过半数的机器存活，最终会完成投票</p>
<h4 id="选举机制（半数机制）"><a href="#选举机制（半数机制）" class="headerlink" title="选举机制（半数机制）"></a>选举机制（半数机制）</h4><p>​        集群中<strong>半数以上</strong>机器存活，集群可用。所以Zookeeper适合安装奇数台服务器</p>
<p>​        Zookeeper虽然在配置文件中并没有指定Master和Slave。Zookeeper工作时只有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制<strong>临时产生</strong>的</p>
<h3 id="zkClient"><a href="#zkClient" class="headerlink" title="zkClient"></a>zkClient</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>启动zk客户端</span><br><span class="line">bin/zkCli.sh</span><br><span class="line"><span class="meta">#</span>#指定访问server</span><br><span class="line">zkCli.sh -server 192.168.1.1:2181</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##常用操作</span><br><span class="line">create /dh "shuaige"</span><br><span class="line">get /dh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>#创建短暂节点</span><br><span class="line">create -e /dh/fat "fat"</span><br><span class="line"><span class="meta">#</span>#创建带顺序号的持久节点</span><br><span class="line">create -s /dh/handsome "handsome"</span><br><span class="line"><span class="meta">#</span>#修改节点的值</span><br><span class="line">set /dh/fat "littlefat" 0</span><br><span class="line"><span class="meta">#</span>#删除节点</span><br><span class="line">delete /dh/fat 0</span><br><span class="line"><span class="meta">#</span>#递归删除</span><br><span class="line">rmr /dh</span><br></pre></td></tr></table></figure>
<h4 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h4><table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>使用 ls 命令来查看当前znode中所包含的内容</td>
</tr>
<tr>
<td>ls2 path [watch]</td>
<td>查看当前节点数据并能看到更新次数等数据（详细数据）</td>
</tr>
<tr>
<td>create [选项]</td>
<td>普通创建一个zNode    -s ：含有序列    -e：临时（重启或者超时消失）</td>
</tr>
<tr>
<td>get path [watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set path  data  [version]</td>
<td>设置（修改）节点的具体值，可根据版本号对节点的值进行修改（推荐使用版本号修改，乐观锁机制）</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete path  data [version]</td>
<td>删除节点，可根据版本号对节点进行删除（推荐使用版本号删除，乐观锁机制）</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody>
</table>
<h4 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>
<ol>
<li><p>cZxid：创建节点的事务zxid</p>
<p>​        每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID</p>
<p>​        事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生</p>
</li>
<li><p>ctime：znode被创建的毫秒数(从1970年开始)</p>
</li>
<li><p>mzxid：znode最后更新的事务zxid</p>
</li>
<li><p>mtime：znode最后修改的毫秒数(从1970年开始)</p>
</li>
<li><p>pZxid：znode最后更新的子节点zxid</p>
</li>
<li><p>cversion：znode子节点变化版本号，znode子节点修改次数</p>
</li>
<li><p>dataversion：znode数据变化版本号</p>
</li>
<li><p>aclVersion：znode访问控制列表的变化版本号</p>
</li>
<li><p>ephemeralOwner：如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0</p>
</li>
<li><font color="red">dataLength：znode的数据长度</font>
</li>
<li><font color="red">numChildren：znode子节点数量</font>



</li>
</ol>
<h4 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h4><p>​        watcher是zk中的监听器机制，父节点或者子节点的增删改操作都能够触发watcher事件</p>
<p><strong>事件类型</strong></p>
<ol>
<li>父节点创建：NodeCreated</li>
<li>父节点数据修改：NodeDataChanged</li>
<li>父节点删除：NodeDeleted</li>
<li>创建了子节点：NodeChildrenChanged</li>
<li>删除子节点：NodeChildrenChanged</li>
<li>修改子节点不触发任何事件</li>
</ol>
<p><strong>watcher机制的使用场景</strong></p>
<p>​        统一的配置管理，可以监听配置信息的节点，当配置信息的节点数据发生变化的时候触发客户端更新配置的操作</p>
<h4 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h4><p>​        ACL（access control lists），可以针对节点设置读写等权限，可以保障数据的安全性；如果没有权限，则会抛出异常</p>
<p>zk的acl通过 [scheme​ : id : ​permissions] 的形式来构成权限的列表</p>
<ul>
<li>scheme：代表采用的某种权限机制</li>
<li>id：代表允许访问的用户</li>
<li>permissions：权限组合字符串（有crdwa）<ul>
<li>c：CREATE，创建子节点</li>
<li>r：READ，获取节点/子节点</li>
<li>d：DELETE，删除子节点</li>
<li>w：WRITE，设置节点数据</li>
<li>a：ADMIN，设置权限</li>
</ul>
</li>
</ul>
<blockquote>
<p>权限示例：</p>
<p>world：world:anyone:[permissions]</p>
<p>auth：auth:user:password:[permissions] 代表认证登录，需要注册的用户有操作权限即可</p>
<p>digest：digest:username:BASE64(SHA1(password)):[permissions] 表示需要对密码进行加密才可以访问</p>
<p>ip：ip:ip地址:[permissions]  可以限制指定ip才能访问该节点</p>
</blockquote>
<p><strong>ACL的命令行操作</strong></p>
<ol>
<li><p>getAcl：获取某个节点的acl权限信息</p>
</li>
<li><p>setAcl：设置某个节点的acl权限信息</p>
<blockquote>
<p>示例：（1和2是等价的）</p>
<ol>
<li>setAcl /path auth:dai:dai:cdrwa</li>
<li>setAcl /path digest:dai:password:cdrwa</li>
</ol>
<p>上面两个操作后需要进行addauth操作后才能够对 /path 进行操作</p>
<ol start="3">
<li>setAcl /path ip:192.168.1.1:cdrwa</li>
</ol>
<p>设置ip后，只有指定ip的客户端才有权限去访问该节点</p>
</blockquote>
</li>
<li><p>addauth：输入认证授权信息，注册时输入明文密码，在zk系统中，密码都是以加密的形式存在的</p>
<blockquote>
<p>参照2的示例： 执行 addauth digest:dai:dai  登录后能获取上面设置节点的操作权限  </p>
<p>​        注意：要使用 dai 用户前需要先注册 dai 用户才可以设置成功，注册用户同样是addAuth命令：addauth digest  dai:dai</p>
<p>​        注意：使用 digest 来设置权限时，查看加密后的password可以通过getAcl，比如：</p>
<p>getAcl /dh</p>
<p>​    ‘digest，’dai:password（此处的password是加密后的显示）</p>
</blockquote>
</li>
</ol>
<h2 id="Java使用ZK"><a href="#Java使用ZK" class="headerlink" title="Java使用ZK"></a>Java使用ZK</h2><h3 id="原生ZK的API"><a href="#原生ZK的API" class="headerlink" title="原生ZK的API"></a>原生ZK的API</h3><h4 id="引入POM"><a href="#引入POM" class="headerlink" title="引入POM"></a>引入POM</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 版本与ZK版本一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="连接ZK"><a href="#连接ZK" class="headerlink" title="连接ZK"></a>连接ZK</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ZKConnect.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line"><span class="comment">//	public static final String zkServerPath = "192.168.1.1:2181,192.168.1.2:2182,192.168.1.3:2183";</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 客户端和zk服务端链接是一个异步的过程</span></span><br><span class="line"><span class="comment">		 * 当连接成功后后，客户端会收的一个watch通知</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * connectString：连接服务器的ip字符串，</span></span><br><span class="line"><span class="comment">		 * 		比如: "192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181"</span></span><br><span class="line"><span class="comment">		 * 		可以是一个ip，也可以是多个ip，一个ip代表单机，多个ip代表集群</span></span><br><span class="line"><span class="comment">		 * 		</span></span><br><span class="line"><span class="comment">		 * sessionTimeout：超时时间，心跳收不到了，那就超时</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * watcher：通知事件，如果有对应的事件触发，则会收到一个通知；如果不需要，那就设置为null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * canBeReadOnly：可读，当这个物理机节点断开后，还是可以读到数据的，只是不能写，</span></span><br><span class="line"><span class="comment">		 * 					 此时数据被读取到的可能是旧数据，此处建议设置为false，不推荐使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionId：会话的id</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * sessionPasswd：会话密码	</span></span><br><span class="line"><span class="comment">		 *          当会话丢失后，可以依据 sessionId 和 sessionPasswd 重新获取会话</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(zkServerPath, timeout, <span class="keyword">new</span> ZKDemo());</span><br><span class="line">		log.warn(<span class="string">"连接状态：&#123;&#125;"</span>, zk.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始会话重连</span></span><br><span class="line">        <span class="keyword">long</span> sessionId = zk.getSessionId();</span><br><span class="line">		<span class="keyword">byte</span>[] sessionPassword = zk.getSessionPasswd();</span><br><span class="line">		log.warn(<span class="string">"开始会话重连..."</span>);</span><br><span class="line">		ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(zkServerPath, </span><br><span class="line">											timeout, </span><br><span class="line">											<span class="keyword">new</span> ZKDemo(), </span><br><span class="line">											sessionId, </span><br><span class="line">											sessionPassword);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">		<span class="keyword">new</span> Thread().sleep(<span class="number">1000</span>);</span><br><span class="line">		log.warn(<span class="string">"重新连接状态zkSession：&#123;&#125;"</span>, zkSession.getState());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		log.warn(<span class="string">"接受到watch通知：&#123;&#125;"</span>, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK的节点操作"><a href="#ZK的节点操作" class="headerlink" title="ZK的节点操作"></a>ZK的节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNode</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeExist</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNode());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNode zkServer = <span class="keyword">new</span> ZKNode(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *查询节点是否存在</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：watch</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Stat stat = zkServer.getZookeeper().exists(<span class="string">"/dh-demo"</span>, <span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"查询的节点版本为dataVersion："</span> + stat.getVersion());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"该节点不存在..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		  * 同步或者异步创建节点，都不支持子节点的递归创建，异步有一个callback函数</span></span><br><span class="line"><span class="comment">		  * 参数：</span></span><br><span class="line"><span class="comment">		  * path：创建的路径</span></span><br><span class="line"><span class="comment">		  * data：存储的数据的byte[]</span></span><br><span class="line"><span class="comment">		  * acl：控制权限策略</span></span><br><span class="line"><span class="comment">		  * 			Ids.OPEN_ACL_UNSAFE --&gt; world:anyone:cdrwa</span></span><br><span class="line"><span class="comment">		  * 			CREATOR_ALL_ACL --&gt; auth:user:password:cdrwa</span></span><br><span class="line"><span class="comment">		  * createMode：节点类型, 是一个枚举</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT：持久节点</span></span><br><span class="line"><span class="comment">		  * 			PERSISTENT_SEQUENTIAL：持久顺序节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL：临时节点</span></span><br><span class="line"><span class="comment">		  * 			EPHEMERAL_SEQUENTIAL：临时顺序节点</span></span><br><span class="line"><span class="comment">		  */</span> 	       </span><br><span class="line">        String ctx = <span class="string">"&#123;'create':'success'&#125;"</span>;</span><br><span class="line">		zookeeper.create(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.get, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> CreateCallBack(), ctx);</span><br><span class="line">             </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *获取一个节点的值</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * watch：true或者false，注册一个watch事件</span></span><br><span class="line"><span class="comment">		 * stat：状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] resByte = zkServer.getZookeeper().getData(<span class="string">"/dh"</span>, <span class="keyword">true</span>, stat);</span><br><span class="line">		String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line">		System.out.println(<span class="string">"当前值:"</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *设置节点的数据</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * data：数据</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		stat  = zkServer.getZookeeper().setData(<span class="string">"/dh-path"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		System.out.println(status.getVersion());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *删除节点(带回调的)</span></span><br><span class="line"><span class="comment">		 * 参数：</span></span><br><span class="line"><span class="comment">		 * path：节点路径</span></span><br><span class="line"><span class="comment">		 * version：数据状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        String ctx = <span class="string">"&#123;'delete':'success'&#125;"</span>;</span><br><span class="line">		zkServer.getZookeeper().delete(<span class="string">"/dh-path"</span>, stat.getVersion(), <span class="keyword">new</span> DeleteCallBack(), ctx);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对节点的监听</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getType() == EventType.NodeCreated) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点创建"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点数据改变"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDeleted) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点删除"</span>);</span><br><span class="line">			countDown.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CallBack回调</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateCallBack</span> <span class="keyword">implements</span> <span class="title">StringCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"创建节点: "</span> + path);</span><br><span class="line">		<span class="comment">//ctx 就是create方法传入的ctx参数</span></span><br><span class="line">		System.out.println((String)ctx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子节点的watcher机制回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildrenCallBack</span> <span class="keyword">implements</span> <span class="title">ChildrenCallback</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; children)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String s : children) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"ChildrenCallback:"</span> + path);</span><br><span class="line">		System.out.println((String)ctx);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNodeAcl</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ZooKeeper zookeeper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"192.168.1.1:2181"</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer timeout = <span class="number">5000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKNodeAcl</span><span class="params">(String connectString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			zookeeper = <span class="keyword">new</span> ZooKeeper(connectString, timeout, <span class="keyword">new</span> ZKNodeAcl());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">if</span> (zookeeper != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					zookeeper.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createZKNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acls)</span> </span>&#123;</span><br><span class="line">		String result = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			result = zookeeper.create(path, data, acls, CreateMode.PERSISTENT);</span><br><span class="line">			System.out.println(<span class="string">"创建节点：\t"</span> + result + <span class="string">"\t成功..."</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZKNodeAcl zkServer = <span class="keyword">new</span> ZKNodeAcl(zkServerPath);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * ======================  创建node start  ======================  </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// acl 任何人都可以访问</span></span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl"</span>, <span class="string">"data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 自定义用户认证访问</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * DigestAuthenticationProvider.generateDigest(String str)</span></span><br><span class="line"><span class="comment">         * 这个方法是zk客户端提供的加密方式 BASE61(SHA1(password))</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id acl1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        </span><br><span class="line">		Id acl2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.ALL, acl1));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.READ, acl2));</span><br><span class="line">		acls.add(<span class="keyword">new</span> ACL(Perms.DELETE | Perms.CREATE, acl2));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test"</span>, <span class="string">"testdigest"</span>.getBytes(), acls);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 注册过的用户必须通过addAuthInfo才能操作节点，参考命令行 addauth</span></span><br><span class="line">		zkServer.getZookeeper().addAuthInfo(<span class="string">"digest"</span>, <span class="string">"dai1:123456"</span>.getBytes());</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/test/childtest"</span>, <span class="string">"childtest"</span>.getBytes(), Ids.CREATOR_ALL_ACL);</span><br><span class="line">		Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/test"</span>, <span class="string">"data"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ip方式的acl</span></span><br><span class="line">		List&lt;ACL&gt; aclsIP = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">		Id ipId = <span class="keyword">new</span> Id(<span class="string">"ip"</span>, <span class="string">"192.168.1.10"</span>);</span><br><span class="line">		aclsIP.add(<span class="keyword">new</span> ACL(Perms.ALL, ipId));</span><br><span class="line">		zkServer.createZKNode(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"data"</span>.getBytes(), aclsIP);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 验证ip是否有权限</span></span><br><span class="line">        zkServer.getZookeeper().getData(<span class="string">"/dh-acl/test"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		zkServer.getZookeeper().setData(<span class="string">"/dh-acl/iptest"</span>, <span class="string">"setdata"</span>.getBytes(), stat.getVersion());</span><br><span class="line">		<span class="keyword">byte</span>[] data = zkServer.getZookeeper().getData(<span class="string">"/aclimooc/iptest6"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">		System.out.println(stat.getVersion());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZookeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeper</span><span class="params">(ZooKeeper zookeeper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.zookeeper = zookeeper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Apache-Curator"><a href="#Apache-Curator" class="headerlink" title="Apache Curator"></a>Apache Curator</h3><h4 id="ZK连接及节点操作"><a href="#ZK连接及节点操作" class="headerlink" title="ZK连接及节点操作"></a>ZK连接及节点操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy1 = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryNTimes</span></span><br><span class="line"><span class="comment">         *              n：重试的次数</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries：每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryOneTime</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetry:每次重试间隔的时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy2 = <span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:RetryUntilElapsed</span></span><br><span class="line"><span class="comment">         *              maxElapsedTimeMs:最大重试时间</span></span><br><span class="line"><span class="comment">         *              sleepMsBetweenRetries:每次重试间隔</span></span><br><span class="line"><span class="comment">         *              重试时间超过maxElapsedTimeMs,就不再重试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		RetryPolicy retryPolicy3 = <span class="keyword">new</span> RetryUntilElapsed(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//判断链接是否成功</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建节点:</span></span><br><span class="line"><span class="comment">         *      creatingParentsIfNeeded : 开启递归的创建方式,不用一层一层的创建</span></span><br><span class="line"><span class="comment">         *      withMode  : 节点的类型</span></span><br><span class="line"><span class="comment">         *      withACL   : acl权限</span></span><br><span class="line"><span class="comment">         *      forPath   : 节点路径和数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String nodePath = <span class="string">"/dai"</span>;</span><br><span class="line">        String str = client.create()</span><br><span class="line">                            .creatingParentsIfNeeded()</span><br><span class="line">                            .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                            .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                            .forPath(nodePath, <span class="string">"data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取节点数据:</span></span><br><span class="line"><span class="comment">         *      storingStatIn : 把服务器端获取的状态数据存储到stat对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] data = client.getData()</span><br><span class="line">                            .storingStatIn(stat)</span><br><span class="line">                            .forPath(nodePath);</span><br><span class="line">        System.out.println(<span class="string">"节点"</span> + nodePath + <span class="string">"的数据为: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">        System.out.println(<span class="string">"该节点的版本号为: "</span> + stat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新节点数据:</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.setData()</span><br><span class="line">                .withVersion(stat.getVersion())</span><br><span class="line">                .forPath(nodePath, <span class="string">"update"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除节点:</span></span><br><span class="line"><span class="comment">         *      guaranteed : 保障措施,只要客户端会话有效; 那么Curator会在后台持续进行删除操作,直到删除节点成功</span></span><br><span class="line"><span class="comment">         *      deletingChildrenIfNeeded : 递归删除,有子节点的情况下会将所有子节点也一并删除</span></span><br><span class="line"><span class="comment">         *      withVersion : 数据版本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        client.getData().storingStatIn(stat).forPath(nodePath);</span><br><span class="line">		client.delete()</span><br><span class="line">              .guaranteed()</span><br><span class="line">              .deletingChildrenIfNeeded()</span><br><span class="line">              .withVersion(stat.getVersion())</span><br><span class="line">              .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查询子节点</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		List&lt;String&gt; childNodes = client.getChildren().forPath(nodePath);</span><br><span class="line">		System.out.println(<span class="string">"开始打印子节点："</span>);</span><br><span class="line">		<span class="keyword">for</span> (String child : childNodes) &#123;</span><br><span class="line">			System.out.println(child);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断节点是否存在,如果不存在则为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		Stat statExist = client.checkExists().forPath(nodePath + <span class="string">"/exist"</span>);</span><br><span class="line">		System.out.println(statExist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件:</span></span><br><span class="line"><span class="comment">         *      当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		client.getData().usingWatcher(<span class="keyword">new</span> MyCuratorWatcher()).forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * watcher 事件：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      NodeCache: 监听数据节点的变更，会触发事件</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, nodePath);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  参数:</span></span><br><span class="line"><span class="comment">         *      buildInitial : 初始化的时候获取node的值并且缓存</span></span><br><span class="line"><span class="comment">         *          只有开启这个缓存后,下面的getCurrentData方法才能拿到数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"节点初始化数据为空..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		nodeCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(<span class="string">"节点数据为空"</span>);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String data = <span class="keyword">new</span> String(nodeCache.getCurrentData().getData());</span><br><span class="line">				System.out.println(<span class="string">"节点路径："</span> + nodeCache.getCurrentData().getPath() + <span class="string">"  数据："</span> + data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为子节点添加watcher事件</span></span><br><span class="line"><span class="comment">         *      PathChildrenCache: 监听数据节点的增删改，会触发事件</span></span><br><span class="line"><span class="comment">         *      cacheData: 是否设置缓存节点的数据状态</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, nodePath, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * StartMode: 初始化方式</span></span><br><span class="line"><span class="comment">         *      POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件</span></span><br><span class="line"><span class="comment">         *      NORMAL：异步初始化</span></span><br><span class="line"><span class="comment">         *      BUILD_INITIAL_CACHE：同步初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line"></span><br><span class="line">        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line">        System.out.println(<span class="string">"当前数据节点的子节点数据列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (ChildData child : childDataList) &#123;</span><br><span class="line">            String childData = <span class="keyword">new</span> String(child.getData());</span><br><span class="line">            System.out.println(childData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加节点数据监听器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.getListenable()</span><br><span class="line">                .addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"子节点初始化ok..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED))&#123;</span><br><span class="line">                    String path = event.getData().getPath();</span><br><span class="line">                    <span class="keyword">if</span> (path.equals(<span class="string">"dh-add"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加子节点:"</span> + event.getData().getPath());</span><br><span class="line">                        System.out.println(<span class="string">"子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path.equals(<span class="string">"/super/imooc/e"</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"添加不正确..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"删除子节点:"</span> + event.getData().getPath());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点路径:"</span> + event.getData().getPath());</span><br><span class="line">                    System.out.println(<span class="string">"修改子节点数据:"</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted2 = client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCuratorWatcher</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"触发了watch 事件，节点路径："</span> + watchedEvent.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ACL权限-1"><a href="#ACL权限-1" class="headerlink" title="ACL权限"></a>ACL权限</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKCurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String zkServerPath = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        List&lt;ACL&gt; aclList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Id 构造参数:</span></span><br><span class="line"><span class="comment">         *         scheme:认证方式</span></span><br><span class="line"><span class="comment">         *                      world：默认方式，相当于全世界都能访问</span></span><br><span class="line"><span class="comment">         *                      auth：代表已经认证通过的用户</span></span><br><span class="line"><span class="comment">         *                      digest：即用户名:密码这种方式认证</span></span><br><span class="line"><span class="comment">         *                      ip：使用Ip地址认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Id id1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai1:123456"</span>));</span><br><span class="line">        Id id2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, DigestAuthenticationProvider.generateDigest(<span class="string">"dai2:123456"</span>));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ACL 构造参数:</span></span><br><span class="line"><span class="comment">         *          perms:五种权限:</span></span><br><span class="line"><span class="comment">         *                          CREATE: 能创建子节点</span></span><br><span class="line"><span class="comment">         *                          READ：能获取节点数据和列出其子节点</span></span><br><span class="line"><span class="comment">         *                          WRITE: 能设置节点数据</span></span><br><span class="line"><span class="comment">         *                          DELETE: 能删除子节点</span></span><br><span class="line"><span class="comment">         *                          ADMIN: 能设置权限</span></span><br><span class="line"><span class="comment">         *             Id:就是上面的Id类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.ALL, id1));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.READ, id2));</span><br><span class="line">        aclList.add(<span class="keyword">new</span> ACL(Perms.CREATE | Perms.WRITE, id2));</span><br><span class="line">        client.setACL().withACL(aclList).forPath(<span class="string">"/dai/dh/hao"</span>);</span><br><span class="line">        client.create()</span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * withACL 第二个参数applyToParents :</span></span><br><span class="line"><span class="comment">                 *                      如果设置为true,那么会将这些acl权限加到创建的父节点上(递归创建)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .withACL(aclList, <span class="keyword">true</span>)</span><br><span class="line">                .forPath(<span class="string">"/dai/dh/hao"</span>, <span class="string">"data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zk客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/CAP理论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/CAP理论/" itemprop="url">CAP理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T23:00:10+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CAP理论</p>
<h2 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h2><p>​    CAP理论指的是在一个<strong>分布式系统</strong>中，不能同时满足一致性，可用性和分区容错性</p>
<ol>
<li><p>C（Consistency）：一致性</p>
<blockquote>
<p>在分布式系统中的所有数据备份，在同一时刻是否是同样的值</p>
</blockquote>
</li>
<li><p>A（Availabe）：可用性</p>
<blockquote>
<p>​    可用性指在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求</p>
<p>​    可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。“有效的时间内”是指，对于用户的一个操作请求，<strong>系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的</strong></p>
</blockquote>
</li>
<li><p>P（Partition Tolenrance）：分区容错性</p>
<blockquote>
<p>​    以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用</p>
</blockquote>
</li>
</ol>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>​    分区容错性约束了一个分布式系统具有如下特性：<font color="red">分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</font></p>
<p><strong>网络分区</strong></p>
<p>​    网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络）中，由于一些特殊的原因导致这些子网络出现网络不连通的状况；但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</p>
<p>​    需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区</p>
<h3 id="Consistency一致性强弱"><a href="#Consistency一致性强弱" class="headerlink" title="Consistency一致性强弱"></a>Consistency一致性强弱</h3><p>​    一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即<strong><font color="red">数据变动在系统内部各节点应该是同步的</font></strong></p>
<p>根据一致性强弱可分为：</p>
<ol>
<li><strong>强一致性</strong>（Strong Consistency）任何时刻，任何用户都能读取到最近一次成功更新的数据</li>
<li><strong>单调一致性</strong>（Monotonic Consistency）任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说<strong>可获取的数据顺序必是单调递增的</strong></li>
<li><strong>会话一致性</strong>（Session Consistency）任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在<font color="blue">本次会话中就不会再读到比这个值更旧的值</font>。<u>会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障</u></li>
<li><strong>最终一致性</strong>（Eventual Consistency）用户只能读到某次更新后的值，<font color="blue">但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障</font></li>
<li><strong>弱一致性</strong>（Weak Consistency）用户无法在确定时间内读到最新更新的值</li>
</ol>
<h3 id="CAP的抉择"><a href="#CAP的抉择" class="headerlink" title="CAP的抉择"></a>CAP的抉择</h3><table>
<thead>
<tr>
<th><strong>选    择</strong></th>
<th style="text-align:left"><strong>说    明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CA</td>
<td style="text-align:left">放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</td>
</tr>
<tr>
<td>AP</td>
<td style="text-align:left">放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此</td>
</tr>
<tr>
<td>CP</td>
<td style="text-align:left">放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用</td>
</tr>
</tbody>
</table>
<h4 id="简单的CAP例子"><a href="#简单的CAP例子" class="headerlink" title="简单的CAP例子"></a>简单的CAP例子</h4><p>​    一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取    </p>
<ol>
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功</strong></p>
<blockquote>
<p>在没有出现网络故障的时候，满足CA原则</p>
<ul>
<li>C 即我的任何一个写入，更新操作成功并返回客户端完成后，分布式的所有节点在同一时间的数据完全一致</li>
<li>A 即我的读写操作都能够成功</li>
</ul>
<font color="blue">但是当出现网络故障时，我不能同时保证CA，即P条件无法满足</font>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><strong>假设DB的更新操作是只写本地机房成功就返回，通过binlog/oplog回放方式同步至侧边机房</strong></p>
<blockquote>
<p>​    这种操作保证了在出现网络故障时，双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP </p>
<p>​    但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在<strong><font color="red">短暂数据不一致</font></strong>，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p><strong>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务</strong></p>
<blockquote>
<p>降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是这无法满足可用性原则</p>
</blockquote>
</li>
</ol>
<h4 id="选择权衡"><a href="#选择权衡" class="headerlink" title="选择权衡"></a>选择权衡</h4><p>​    对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么<u>分布式系统中的组件必然需要被部署到不同的节点</u>，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统往往需要根据业务特点在C（一致性）和A（可用性）之间寻求平衡</p>
<p>​    对于大多数互联网应用来说，因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有舍弃强一致性（可以保证最终一致性）来保证服务的AP</p>
<p>​    但是对于需要确保强一致性的场景，如银行业务，通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡（并不是所有情况CP都好于CA，只能查看信息不能更新信息有时候从产品层面还不如直接拒绝服务）</p>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>​    BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<p>​    BASE理论的核心思想是：<strong><font color="red">即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</font></strong></p>
<ol>
<li><p>Basically Available（基本可用）</p>
<blockquote>
<p>基本可用是指分布式系统在出现不可预知故障的时候，<font color="blue">允许损失部分可用性</font></p>
<p>注意，这绝不等价于系统不可用。如：</p>
<ul>
<li><p>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</p>
</li>
<li><p>系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</p>
</li>
</ul>
</blockquote>
</li>
<li><p>Soft state（软状态）</p>
<blockquote>
<p>​    软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</strong></p>
</blockquote>
</li>
<li><p>Eventually consistent（最终一致性）</p>
<blockquote>
<p>​    最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态</p>
<p>​    因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
</blockquote>
</li>
</ol>
<h4 id="最终一致性变种"><a href="#最终一致性变种" class="headerlink" title="最终一致性变种"></a>最终一致性变种</h4><ol>
<li><p>因果一致性：</p>
<blockquote>
<p>​    因果一致性是指：如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制</p>
</blockquote>
</li>
<li><p>读己之所写：</p>
<blockquote>
<p>​    读己之所写是指：进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。</p>
<p>​    也就是说，对于单个数据获取者而言，其读取到的数据一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性</p>
</blockquote>
</li>
<li><p>会话一致性：</p>
<blockquote>
<p>​    会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性</p>
<p>​    也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值</p>
</blockquote>
</li>
<li><p>单调读一致性：</p>
<blockquote>
<p>​       单调读一致性是指：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值</p>
</blockquote>
</li>
<li><p>单调写一致性：</p>
<blockquote>
<p> 单调写一致性是指：一个系统需要能够保证来自同一个进程的写操作被顺序地执行</p>
</blockquote>
</li>
</ol>
<p>​    总的来说：BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是<strong>通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。</p>
<p>​    在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/JVM垃圾收集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/JVM垃圾收集/" itemprop="url">JVM垃圾收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T16:51:50+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文基于JDK7 HotSpot VM</p>
</blockquote>
<h3 id="判定对象无用的根据"><a href="#判定对象无用的根据" class="headerlink" title="判定对象无用的根据"></a>判定对象无用的根据</h3><p>​    通过可达性算法判断对象是否不再使用。即GC Roots，将GC Roots作为起始点向下搜索引用，还被GC Roots引用的对象就是可用的，而当一个对象没有到GC Roots有任何引用链的即为可回收的对象。</p>
<p>可作为GC Roots的对象：</p>
<ul>
<li>当前各线程执行方法中的局部变量（包括形参）引用的对象</li>
<li>已被加载的类的 static 域引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>JNI （Native方法）引用的对象</li>
</ul>
<h3 id="内存的分配和回收"><a href="#内存的分配和回收" class="headerlink" title="内存的分配和回收"></a>内存的分配和回收</h3><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>​    在堆为对象分配内存空间之前，应该先知道对象在内存中存储的布局；对象在内存中的存储布局主要分为：对象头，实例数据和对齐填充。</p>
<ul>
<li>对象头：主要用于存储对象自身运行时的数据和类型指针<ul>
<li>运行时数据包括：哈希码（HashCode）、GC分代年龄、锁状态标志</li>
<li>类型指针是指向类元数据的指针</li>
</ul>
</li>
<li>实例数据：对象中的字段数据和父类继承过来的字段数据等</li>
<li>对齐填充：只是起到占位符的作用。因为HotSpotVM要求对象的起始地址必须是8字节的整数倍，当一个对象的实例数据（对象头是32bit或者64bit）不是8字节的整数倍时，就需要对齐填充来补全了</li>
</ul>
<h4 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h4><p>​        对象的内存分配主要在新生区的Eden空间上，当Eden区没有足够的连续空间时会触发一次MinorGC；但是一些需要连续大量内存空间的对象（很长的字符串或者数组）就会导致Eden区容纳不下这个对象（垃圾清理后仍然放不下），这个时候会直接在老年代中为其分配内存。</p>
<p>​    同时虚拟机也提供了-XX:PretenureSizeThreshold的参数，当对象的大小大于这个设置值的时候，会直接在老年代中进行内存分配，这样也可以避免新生代频繁的进行垃圾收集（新生代的垃圾收集是复制算法）</p>
<h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>​        了解了对象内存分配的位置，那么就需要知道内存分配的方式了。</p>
<ol>
<li>有大片连续内存空间时（常用于<strong>带压缩算法</strong>的收集器，如Serial，ParNew）</li>
</ol>
<p>​        当存在大片连续的内存可用于分配给新对象时，可以采用<strong>指针碰撞</strong>的方式（每次分配对象空间只要检测一下是否有足够的空间，如果有那么指针往前移动 N 位就分配好空间了，然后就可以初始化这个对象了）</p>
<p>​    对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot 使用了称之为<strong>Thread-Local Allocation Buffers (TLABs) 的技术</strong>，该技术能改善多线程空间分配的吞吐量。TLABs首先给予每个线程一部分内存作为缓存区，<font color="blue">每个线程都在自己的缓存区中进行指针碰撞</font>，这样就不用获取全局锁了。只有当一个线程使用完了它的 TLAB，它才需要使用同步锁定来获取一个新的缓冲区。</p>
<p>​    HotSpot 使用了多项技术来降低 TLAB 对于内存的浪费。比如，TLAB 的平均大小被限制在 Eden 区大小的 1% 之内。TLABs 和使用指针碰撞的线性分配结合，使得内存分配非常简单高效。</p>
<blockquote>
<p>可用-XX:+UseTLAB 来启用TLAB技术</p>
</blockquote>
<ol start="2">
<li>内存空间碎片较多时（如CMS收集器，使用Mark-Sweep算法）</li>
</ol>
<p>​        当已经使用的内存和空闲内存相互交错的时候，就不能直接的进行指针碰撞来分配内存了；这个时候虚拟机就会维护一个 <strong>“空闲列表”</strong> 来记录可用的内存块，在分配内存的时候会再列表中找到足够大的空间划分给对象，并且会更新列表上的记录</p>
<h4 id="内存分代思想"><a href="#内存分代思想" class="headerlink" title="内存分代思想"></a>内存分代思想</h4><p>​    虚拟机采用了分代收集的思想去管理堆内存；分代思想指的是虚拟机根据对象的存活周期来划分内存，一般将堆内存划分为年轻代（新生代）和老年代；年轻代是在垃圾收集的时候会有大量的对象死去的内存区域，而老年代中的对象普遍是存活率高的</p>
<p>​    年轻代因为每次都有大量的对象死去，所以一般会采用复制算法（下文介绍，因为此算法只需要复制少量的存活对象，成本较低）；虚拟机在对象创建的时候会给对象定义一个<font color="red">对象年龄的计数器</font>，对象在年轻代（Eden区）被创建并且经历过一次Minor GC（年轻代垃圾收集）并且存活，将会被移到Survivor区并且设置对象年龄为1，<u>该对象每熬过一次MinorGC，对象年龄就会加一</u>，当对象年龄达到一定程度就会晋升到老年代中（默认是15，可以通过-XX:MaxTenuringThreshold=15来设置）</p>
<p>​    但是如果每个对象都需要等到晋升年龄的话，Survivor区不一定能够容纳下这么多的对象。所以为了应对这种内存状况，虚拟机的解决办法是：<font color="red">如果Survivor区中<strong>相同年龄的所有对象大小的总和</strong>大于Survivor空间的一半，那么对象年龄大于或等于该值的对象就直接进入老年代，不需要达到晋升年龄</font></p>
<h3 id="什么时候触发垃圾收集"><a href="#什么时候触发垃圾收集" class="headerlink" title="什么时候触发垃圾收集"></a>什么时候触发垃圾收集</h3><ol>
<li>当年轻代被填满后（一般新对象在Eden区申请内存空间失败的时候），会进行一次年轻代垃圾收集（也叫做 Minor GC）</li>
<li>Full GC（通常也叫Major GC）会对整个堆进行垃圾收集，触发的情况：<ul>
<li>老年代或者永久代被填满的时候触发</li>
<li>当新生代对象晋升到老年代担保失败的时候触发（即年轻代垃圾收集后会有一部分晋升到老年代的对象，当老年代不能容纳这些晋升的对象时会触发）</li>
</ul>
</li>
<li>CMS垃圾收集器的触发时机；CMS垃圾收集器不会等到老年代或者永久代满了才开始进行垃圾收集（CMS只收集老年代old Gen），会有一个<strong>预设占用率（initiating occupancy）</strong><ul>
<li>老年代的使用率达到阈值（通过JVM参数：<strong>–XX:CMSInitiatingOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>永久代的使用率到达阈值（<strong>–XX:CMSInitiatingPermOccupancyFraction=n</strong>设定，JDK8默认为92%）</li>
<li>当新生代对象晋升到老年代担保失败的时候触发</li>
</ul>
</li>
</ol>
<p>注意： <strong>只有CMS的concurrent collection是只收集old Gen的，其他的老年代垃圾收集器在满足条件后会触发Full GC，此时Full GC会收集整个GC堆，会先进行young GC（即使用年轻代的垃圾收集算法去收集年轻代的垃圾），然后使用老年代算法去收集老年代和方法区。</strong></p>
<p>​    <strong>这里还有个值得注意的地方，当要进行一次young GC时，如果发现统计数据说之前young GC的<font color="blue">平均晋升大小比目前old gen剩余的空间大</font>，则不会进行young GC，而是会采用老年代的垃圾收集算法对<font color="red">整个堆</font>进行垃圾收集（除了CMS）</strong></p>
<p>​    为什么说除了CMS呢，因为CMS垃圾收集器不能收集年轻代的垃圾。而且CMS有预设占用率会触发老年代的垃圾收集，所以CMS一般不会发生Full GC，但是当CMS发生concurrent mode failure的时候是会退化到发生Full GC，这个时候会变成使用备选的Serial Old收集器来对老年代进行垃圾收集（也有可能对整个堆进行垃圾收集哦，也就是发生上面一段话所说的情况）</p>
<h4 id="空间分配担保机制"><a href="#空间分配担保机制" class="headerlink" title="空间分配担保机制"></a>空间分配担保机制</h4><p>​    分配担保机制指的是：<font color="red">在MinorGC后新生代还有大量的对象存活，并且Survivor区不能存放所有的存活对象的情况下，会将无法容纳的对象直接晋升到老年代中</font></p>
<p>​    分配担保机制触发是在<u><strong>老年代中的内存还有能容纳晋升上来的对象的空间</strong></u>，而且在最坏的情况下是整个Eden区的对象都是存活的，所以在发生MinorGC之前，虚拟机都会先检查老年代的最大可用的连续内存空间是否大于新生代所有对象的总和，如果条件成立，那么可以直接进行MinorGC。</p>
<p>​    否则会根据是否设置了担保失败机制来选择下一步</p>
<ul>
<li><p>如果允许出现担保失败，则继续检查老年代中的最大可用连续内存空间<font color="blue">是否大于之前每次垃圾回收晋升到老年代对象容量的平均值大小</font>，如果大于则进行MinorGC，否则会进行Full GC来让老年代腾出更大的内存空间；比较平均值是一种动态手段，这种情况下如果出现上面最坏的情况，存活的对象远远高于平均值，是会出现担保失败的情况的（Handle Promotion Failure）；出现这种情况，会重新的进行一次Full GC去腾出更多空间。</p>
<blockquote>
<p>-XX:+HandlePromotionFailure    允许担保失败</p>
<p>-XX:-HandlePromotionFailure    不允许担保失败</p>
</blockquote>
</li>
<li><p>如果不允许出现担保失败，则直接进行Full GC腾出空间。</p>
</li>
</ul>
<p>注：推荐允许担保失败，因为这样能够避免频繁的Full GC    </p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>三种常用的垃圾收集算法的思想：</p>
<ol>
<li><p>标记清除算法</p>
<ul>
<li>首先标记出需要进行回收的对象，然后统一回收这些被标记的对象</li>
<li>这个算法回收完对象之后会产生大量的不连续的内存空间，这些内存碎片容易导致在后续分配大对象的时候无法找到足够的连续的内存空间</li>
</ul>
</li>
<li><p>标记复制算法</p>
<ul>
<li>这里以年轻代为例子说明：将内存划分为一个<strong>Eden区</strong>和两个<strong>Survivor区</strong>，每次使用Eden区和其中一个Survivor区（为了内存利用率），当回收垃圾的时候，将Eden区和Survivor区存活的对象复制到另外一块Survivor区中，然后再将Eden区和用过的Survivor区的内存空间清理掉</li>
<li>虚拟机会给对象定义一个对象年龄的计数器，当对象复制到Survivor区的时候，对象的年龄增加1，当达到一定程度的时候会晋升到老年代中</li>
<li>当复制过去的对象在Survivor区中不够大小存放的时候（内存不足），此时会触发<strong>分配担保机制</strong>，直接将这些对象晋升到老年代中</li>
</ul>
<p><img src="/2019/04/14/JVM垃圾收集/From-To1.png" alt="MinorGC Start"></p>
<p><img src="/2019/04/14/JVM垃圾收集/From-To2.png" alt="MinorGC After"></p>
</li>
<li><p>标记整理算法（标记 -&gt; 清除 -&gt; 压缩）</p>
<ul>
<li>这个算法跟标记清除算法差不多一样，只是当回收完被标记的对象后，会对内存空间进行压缩，将所有活的对象移到一边，然后会剩下一大片连续的内存空间，当产生新的对象时就很容易进行内存分配了</li>
</ul>
</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>在了解垃圾收集器之前需要先认识几个概念</p>
<ul>
<li><p><strong>并行</strong>：多个垃圾回收线程同时工作，此时用户线程处于等待状态。</p>
</li>
<li><p><strong>并发</strong>：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起。</p>
</li>
<li><p><strong>Stop-the-world</strong>：在垃圾收集时，需要将应用程序完全挂起的事件称为stop-the-world。</p>
<blockquote>
<p>​    这是因为GC需要在垃圾收集前分析堆中对象的引用关系并且保存准确性所导致的结果（如果不停顿应用线程的执行，那么会导致在分析过程中还会出现引用关系变化的情况，从而会让可达性算法分析的结果变得更加复杂和不准确）。</p>
<p>​    应用stop-the-world的垃圾收集器会简单很多，应为在应用程序停顿的时候，堆内存空间是不会发生变化了，此时就能够准确的标记无用的对象。但是在web应用环境下，它挂起应用线程的时间是不能被接受的。</p>
</blockquote>
</li>
<li><p><strong>吞吐量</strong>：应用程序执行时间   / （应用程序执行时间 + 垃圾收集时间）</p>
</li>
</ul>
<h4 id="串行垃圾收集器"><a href="#串行垃圾收集器" class="headerlink" title="串行垃圾收集器"></a>串行垃圾收集器</h4><p>​    年轻代和老年代都使用单线程的方式来进行垃圾收集（在多核CPU下也只会使用一个CPU进行垃圾收集），收集过程需要stop-the-world。</p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>​    用于年轻代的垃圾收集，主要采用了标记复制算法。</p>
<h5 id="SerialOld收集器"><a href="#SerialOld收集器" class="headerlink" title="SerialOld收集器"></a>SerialOld收集器</h5><p>​    用于老年代的垃圾收集，主要采用了标记整理算法（标记 -&gt; 清除 -&gt; 压缩算法）</p>
<h5 id="串行垃圾收集的优点"><a href="#串行垃圾收集的优点" class="headerlink" title="串行垃圾收集的优点"></a>串行垃圾收集的优点</h5><ul>
<li>简单高效</li>
<li>对于单个CPU的环境下，串行收集器没有线程间交互的时间开销</li>
<li>适用于运行在client模式下的程序</li>
</ul>
<p>可以使用<code>-XX:+UseSerialGC</code>来使用Serial + SerialOld的组合进行垃圾收集</p>
<h4 id="并行垃圾收集器"><a href="#并行垃圾收集器" class="headerlink" title="并行垃圾收集器"></a>并行垃圾收集器</h4><p>​    并行垃圾收集器利用多核的优势，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行的收集器仍然会stop-the-world，只不过使用多核的优势并行执行，降低停顿的时间；同时降低垃圾收集的时间，从而提高吞吐量。</p>
<p>​    并行垃圾收集器能够通过 <code>–XX:ParallelGCThreads=n</code>来控制垃圾收集线程的个数，<strong>合理利用CPU的资源能够有效的降低垃圾收集的停顿时间</strong>，但是上面说过了串行收集器在单CPU环境下是没有线程间交互的开销的，所以在单CPU的环境下，可能效率会比串行收集器更低。</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>​    多线程版本的Serial收集器，它能够配合CMS收集器一起工作（CMS是老年代的收集器；因为是Serial的多线程版本，所以Serial收集器也能和CMS收集器配合工作）。和Serial一样采用标记复制算法，不过是并行的复制算法，需要stop-the-world。</p>
<p>​    可以用<code>-XX:+UseConcMarkSweepGC</code>来使用CMS + ParNew组合的垃圾收集器（这里会有个情况，当CMS出现concurrent mode failure的时候会使用Serial Old收集器来手机老年代的对象）；还可以用<code>-XX:+UseParNewGC</code>来使用Serial Old + ParNew的组合进行内存回收。</p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>​    吞吐量收集器，可以这样形容这个收集器。显而易见，这是能够控制吞吐量的垃圾收集器，同样的也是采用复制算法（需要stop-the-world）。此收集器提供了两个参数来控制吞吐量（控制GC的停顿时间），分别是：<code>-XX:MaxGCPauseMillis</code>和<code>-XX:GCTimeRatio</code>（<strong>MaxGCPauseMillis</strong>优先度更高）</p>
<ol>
<li><p>MaxGCPauseMillis是设置最大的垃圾收集停顿时间</p>
<ul>
<li>过分的降低停顿时间的话（设置停顿时间很短的情况下），是会降低整体的吞吐量的。因为设置了很低的停顿时间，可能会使得虚拟机对新生代的空间进行调整（调整Eden和Survivor区的比例），当Eden区的空间变小了，会导致更频繁的进行垃圾收集。垃圾收集的停顿时间确实会因为Eden区变小从而降低了，但是更频繁的垃圾收集也会导致整体吞吐量降低。</li>
</ul>
</li>
<li><p>GCTimeRatio是用来设置吞吐量的。此参数的值是：垃圾收集时间与应用程序运行时间的比值；例如</p>
<ul>
<li><p><code>-XX:GCTimeRatio=99</code> (同时也是默认值)此时相当于 垃圾收集时间:程序运行时间=1:99，则吞吐量=1/(1+99)=1% </p>
<blockquote>
<p>个人观点（勿喷）：周志明老师JVM书上的描述有点不对，书中描述GCTimeRatio设置的值是吞吐量的倒数，比如默认值99，如果是吞吐量的倒数的话，那么吞吐量就是1/99了，这样看来是不对的。所以我认为描述为吞吐量倒数应该是不正确的。应该是垃圾收集时间与应用程序运行时间的比值</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当我们能够通过设置上面两个参数来控制吞吐量，但是不知道什么样的情况下是最好的（即不知道该如何设置年轻代内存大小和各个区之间的比值等）；这种情况下可以使用 <code>-XX:+UseAdaptiveSizePolicy</code> 来动态的调整虚拟机相关细节参数来达到设置好的停顿时间或者吞吐量，这中调节方式被称为GC自适应调节策略（建议使用该收集器时开启这个参数）</p>
</li>
</ol>
<p>可以使用<code>-XX:+UseParallelOldGC</code>来使用Parallel Scavenge + Parallel Old的组合回收内存</p>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>​    Parallel Old是Parallel Scavenge的老年代版本。采用的是并行标记整理算法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/高并发场景下的优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/高并发场景下的优化/" itemprop="url">高并发场景下的优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T16:58:05+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    当应用在面临高并发访问的情况下，一般的web项目很容易会出现请求处理不过来和性能瓶颈的问题，同时数据库的压力也会变得很大；尤其是单机处理的能力极其有限。那么在这种情况下就需要考虑相关的解决方案去提升应用的并发处理能力了。</p>
<h2 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h2><p>​    关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。</p>
<p>​    数据库分布式核心内容无非就是<strong>数据切分</strong>（Sharding），以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。</p>
<h3 id="数据切分（分库分表）"><a href="#数据切分（分库分表）" class="headerlink" title="数据切分（分库分表）"></a>数据切分（分库分表）</h3><p>​    数据切分指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。数据的切分同时还可以提高系统的总体可用性，因为单台设备Crash之后，只有总体数据的某部分不可用，而不是所有的数据。</p>
<p>数据切分根据其切分类型，可以分为两种方式：</p>
<ul>
<li>按照<font color="red"><strong>不同的表</strong>（或者Schema）来切分到<strong>不同的数据库</strong></font>（主机）之上，这种切可以称之为数据的垂直（纵向）切分</li>
<li>根据表中的数据的逻辑关系，将<font color="red"><strong>同一个表</strong>中的数据按照某种条件拆分到多台数据库</font>（主机）上面，这种切分称之为数据的水平（横向）切分</li>
</ul>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>​    根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库（即根据功能模块来进行数据的切分，不同功能模块的数据存放于不同的数据库主机中）</p>
<h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><p>​    对于单表的垂直切分是基于数据库中的<strong>“列”</strong>进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p>
<p>​    在字段很多的情况下（例如一个大表有100多个字段），通过<strong>“大表拆小表”</strong>，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。</p>
<p>​    另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能</p>
<h4 id="垂直切分的优缺点"><a href="#垂直切分的优缺点" class="headerlink" title="垂直切分的优缺点"></a>垂直切分的优缺点</h4><ul>
<li>优点<ol>
<li>解决业务系统层面的耦合，业务清晰</li>
<li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li>
</ol>
</li>
<li>缺点<ol>
<li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li>
<li>分布式事务处理复杂</li>
<li>依然存在单表数据量过大的问题（需要水平切分）</li>
</ol>
</li>
</ul>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>​    水平切分是根据表内数据内在的逻辑关系，按照某种规则<font color="blue"><em>（如根据某个数字类型字段基于特定数目取模，某个时间类型字段的范围，或者是某个字符类型字段的hash值，或者用户表的地区等等）</em></font>将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</p>
<p>​    当一个应用难以再细粒度的垂直切分，或<strong>切分后数据量行数巨大，存在单库读写、存储性能瓶颈</strong>，这时候就需要进行水平切分了。</p>
<h4 id="水平切分优缺点"><a href="#水平切分优缺点" class="headerlink" title="水平切分优缺点"></a>水平切分优缺点</h4><ul>
<li>优点<ol>
<li>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li>
<li>应用端改造较小，不需要拆分业务模块</li>
</ol>
</li>
<li>缺点<ol>
<li>跨分片的事务一致性难以保证</li>
<li>跨库的join关联查询性能较差</li>
<li>数据多次扩展难度和维护量极大</li>
</ol>
</li>
</ul>
<h4 id="经典的水平切分规则"><a href="#经典的水平切分规则" class="headerlink" title="经典的水平切分规则"></a>经典的水平切分规则</h4><ul>
<li><p>根据数值范围：按照时间区间或ID区间来切分</p>
<blockquote>
<p>这样的优点在于：</p>
<ul>
<li>单表大小可控</li>
<li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</li>
<li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，很少被查询</li>
</ul>
</blockquote>
</li>
<li><p>根据数值取模：一般采用hash取模mod的切分方式</p>
<blockquote>
<p>优点：</p>
<ul>
<li>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</li>
</ul>
<p>缺点：</p>
<ul>
<li>后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）</li>
<li>容易面临跨分片查询的复杂问题（如果查询时无法定位表，那么需要同时对多个数据库表进行查询再合并数据，会拖累数据库）</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="分库分表带来的问题及其解决办法"><a href="#分库分表带来的问题及其解决办法" class="headerlink" title="分库分表带来的问题及其解决办法"></a>分库分表带来的问题及其解决办法</h3><p>​    分库分表能有效的环节单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题：</p>
<ol>
<li><p>事务一致性问题</p>
<ul>
<li>分布式事务：当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务。分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁</li>
<li>最终一致性：对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的<strong>实时一致性</strong>，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等</li>
</ul>
</li>
<li><p>跨节点关联查询 join 问题</p>
<blockquote>
<p>切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询</p>
<p>对于该问题的解决方案：</p>
<ul>
<li>全局表，将所有模块依赖的一些表在每个数据库中都保存一份</li>
<li>增加冗余字段，利用空间换时间，为了性能而避免join查询。例如：订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询User表了</li>
<li>通过应用程序分多次查询，再将得到的数据组装合并</li>
</ul>
</blockquote>
</li>
<li><p>跨节点分页、排序、函数问题</p>
<blockquote>
<p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。</p>
<p>分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户</p>
</blockquote>
</li>
<li><p>全局主键避重问题</p>
<blockquote>
<p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的<strong>ID无法保证全局唯一</strong>。因此需要单独设计全局主键，以避免跨库主键重复问题。（可用UUID或者分布式的全局ID生成器(如推特的Snowflake)）</p>
</blockquote>
</li>
<li><p>数据迁移、扩容问题</p>
<blockquote>
<p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。此外还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W）</p>
<p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦</p>
</blockquote>
</li>
</ol>
<h3 id="什么时候需要分库分表"><a href="#什么时候需要分库分表" class="headerlink" title="什么时候需要分库分表"></a>什么时候需要分库分表</h3><ul>
<li>能不切分尽量不要切分</li>
<li>数据量过大，正常运维影响业务访问</li>
<li>随着业务发展，需要对某些字段垂直拆分</li>
<li>数据量快速增长</li>
<li>安全性和可用性：在业务层面上垂直切分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。利用水平切分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高</li>
</ul>
<h3 id="垂直切分和水平切分的联合使用"><a href="#垂直切分和水平切分的联合使用" class="headerlink" title="垂直切分和水平切分的联合使用"></a>垂直切分和水平切分的联合使用</h3><p>​    一个应用系统的负载都是在慢慢的增长的，当系统开始遇到性能瓶颈的时候。大多数情况下会先选择对数据库进行垂直切分，因为这样的成本最先，最符合这个时期所追求的最大投入产出比。    </p>
<p>​    但是随着业务的不断扩张，系统负载的持续增长，在系统稳定一段时期之后，经过了垂直拆分之后的数据库集群可能会再一次不堪重负，遇到了性能瓶颈。如果再选择对系统数据库进行垂直切分的话，会随着时间又再次面临同样的问题。这个时候就需要通过水平切分的优势来解决这个问题了，而且完全可以在垂直切分后的基础上进行水平切分。</p>
<h2 id="数据库扩容"><a href="#数据库扩容" class="headerlink" title="数据库扩容"></a>数据库扩容</h2><p>​    随着时间的推进和业务的发展，系统的数据量会不停的增长，无论是数据库的容量，还是单库单表的数据量也总会到达天花板，此时该如何扩展我们的数据库性能？</p>
<ul>
<li><p>水平扩容</p>
<blockquote>
<ol>
<li><font color="red">增加服务器数量</font>，就能线性扩充系统性能</li>
<li>但是增加过多的服务器会增加网络、数据库IO开销、管理多个服务器的难度</li>
</ol>
</blockquote>
</li>
<li><p>垂直扩容：提升单机处理能力</p>
<blockquote>
<ol>
<li>增强单机硬件性能（升级CPU,SSD固态硬盘等）</li>
<li>提升单机架构性能（使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间）</li>
<li>但是这样会增大单个服务中其他软件设施的依赖与管理、服务内部复杂度</li>
</ol>
</blockquote>
</li>
</ul>
<p>​        对数据库的扩容不管是垂直还是水平扩容都会有优缺点，这就需要根据实际的业务需求来选择了更加合适的解决方案了：</p>
<ul>
<li><font color="blue">读操作扩展</font>：假如网站是<strong>读操作</strong>比较多，比如博客网站。通过对数据库进行垂直扩容并且结合redis、CDN等构建一个健壮的缓存系统是个不错的选择。如果系统超负荷运行，将更多的数据放在缓存中来缓解系统的读压力。采用水平扩容没有太大的意义，因为性能的瓶颈不在写操作，所以不需要实时去完成，用更多的服务器来分担压力性价比太低。</li>
<li><font color="blue">写操作扩展</font>：假如写操作比较多，比如大型网站的交易系统，可考虑水平扩展的数据存储方式，比如Cassandra、Hbase等。和大多数的关系型数据库不同，这种数据存储会随着数据量的增长从而增加更多的节点。也可以考虑垂直扩容提升单个数据库的性能，但会发现资金与硬盘的IO能力是有限的，所以需要增加更多数据库来分担写的压力</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>​    <strong>使用缓存可以减少数据库压力(I/O压力)与提高访问性能</strong></p>
<p>​    缓存通常适合<font color="red">读多写少</font>的业务场景，实时性要求越低越适合缓存（即数据在缓存中更新的次数越少越适合）</p>
<ol>
<li><p>缓存特征</p>
<ul>
<li><p>命中率：命中数 /（命中数 + 没有命中数），命中率越高产生收益也就越高，性能也就越好，相应的也就越短，吞吐量也就越高，抗并发的能力也就越强</p>
</li>
<li><p>最大元素（空间）：缓存中存放的最大元素的数量，当缓存的数量超过了缓存空间，则会触发缓存清空策略</p>
</li>
<li><p>清空策略：</p>
<blockquote>
<p>一旦缓存中元素数量最大元素或者缓存数据所占空间超过其最大支持空间，那么将会触发缓存清空策略，根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存</p>
</blockquote>
<ul>
<li>FIFO先进先出策略，先进入的优先清除</li>
<li>LFU（Least Frequently Used，根据数据的历史访问频率来淘汰数据，对比命中数；其核心思想是<strong>“如果数据过去被访问多次，那么将来被访问的频率也更高”</strong>）</li>
<li>LRU（Least recently used，最近最少使用策略；其核心思想是<strong>“如果数据最近被访问过，那么将来被访问的几率也更高”</strong>）</li>
<li>过期时间（根据元素设置的过期时间来清除缓存）</li>
<li>随机清除</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存分类</p>
<ul>
<li>本地缓存：Java中的本地缓存是存在当前应用进程内部的，没有过多的网络开销。在集群节点之间不需要互相通知的情况下使用较为合适</li>
<li>分布式缓存：应用分离的缓存服务，其自身就是一个独立的应用，与本地应用是隔离的，多个应用之间共享缓存</li>
</ul>
</li>
<li><p>高并发场景下缓存常见问题</p>
<ul>
<li><p>缓存一致性</p>
<blockquote>
<p>当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存</p>
</blockquote>
</li>
<li><p>缓存并发</p>
<blockquote>
<p>在高并发场景下，多个请求并发的去从数据库获取数据，会对后端数据库造成极大的冲击，甚至导致 “雪崩”现象。当某个缓存key在被更新时，同时也可能被大量请求在获取，这也会导致缓存一致性的问题。</p>
<p>那如何解决类似问题呢？在缓存更新或者过期的情况下，先尝试获取到锁（分布式锁），当更新或者从数据库获取完成后再释放锁，其他的请求只需要牺牲一定的等待时间，即可直接从缓存中继续获取数据</p>
</blockquote>
</li>
<li><p>缓存穿透</p>
<blockquote>
<p>在高并发场景下，如果某一个key被高并发访问，没有被命中，出于对容错性考虑，会尝试去从后端数据库中获取，从而导致了大量请求达到数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的去执行了很多不必要的查询操作，从而导致数据库的压力增大。</p>
<p>那如何解决类似问题呢？</p>
<ul>
<li>缓存空对象；对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非null），如果是缓存单个对象，可以通过字段标识来区分。这样避免请求穿透到后端数据库。同时，也需要保证缓存数据的时效性。这种方式实现起来成本较低，比较适合命中不高，但<strong>可能被频繁更新的数据</strong></li>
<li>单独过滤处理；对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂，比较适合命中不高，但是<strong>更新不频繁的数据</strong></li>
</ul>
</blockquote>
</li>
<li><p>缓存雪崩</p>
<blockquote>
<p>缓存雪崩就是指由于缓存没有命中的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。“缓存并发”，“缓存穿透”等问题，都可能会导致缓存雪崩现象发生，这些问题可能会被恶意攻击者所利用。</p>
<p>还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效</p>
<p>从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难</p>
</blockquote>
</li>
</ul>
</li>
<li><p>缓存介质</p>
<ul>
<li><strong>内存</strong>：将缓存存储于内存中是最快的选择，无需额外的I/O开销，但是内存的缺点是存储的数据没有持久化，一旦应用异常或者宕机，数据很难或者无法复原</li>
<li><strong>硬盘</strong>：很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的</li>
</ul>
</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>​    消息队列已经逐渐成为<strong>系统内部通信的核心手段和异步RPC</strong>的主要手段。</p>
<p>​    它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能</p>
<ol>
<li><p>消息队列的特性</p>
<ul>
<li>业务无关：只做消息的分发</li>
<li>FIFO：先进入队列的先到达</li>
<li>容灾：节点的动态增删和消息的持久化</li>
<li>性能：吞吐量提升，系统内部通信效率提高</li>
</ul>
</li>
<li><p>使用消息队列的好处</p>
<ul>
<li><p><strong>异步解耦</strong></p>
<blockquote>
<p>使用消息队列，可以异步处理请求，从而缓解系统的压力</p>
<p>例如：短信发送时只要保证放到消息队列中就可以接着做后面的事情。一个事务只关心本质的流程，需要依赖其他事情但是不那么重要的时候，有通知即可，无需等待结果</p>
</blockquote>
</li>
<li><p><strong>保证最终一致性</strong></p>
<blockquote>
<p>最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的</p>
</blockquote>
</li>
<li><p><strong>错峰与流控</strong></p>
<blockquote>
<p>上下游对于事情的处理是不同的，比如WEB前端每秒承受上千万的请求都是可以的但是数据库的处理却非常有限；迫于成本的压力我们不能要求数据库的机器数量与前端资源一样；这样的问题同样存在于系统与系统之间,比如短信系统的速度卡在网关上边它与前端的并发量不是一个数量级的，用户玩几秒种收到短信也是可以的；针对于这样的场景如果没有消息队列也能实现但是系统的复杂度非常的高</p>
</blockquote>
</li>
<li><p><strong>广播</strong> </p>
<blockquote>
<p>如果没有消息队列每一个新的业务方介入都需要联调一次接口，使用消息队列只需要关心消息是否送达到消息队列，新接入的接口订阅相关的消息自己做处理就可以了</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="应用拆分"><a href="#应用拆分" class="headerlink" title="应用拆分"></a>应用拆分</h2><ol>
<li><p>拆分的原则</p>
<ul>
<li>业务优先：每个系统都会有多个模块，每个模块又有多个业务功能；按照业务边界进行切割，再对模块进行拆分</li>
<li>循序渐进：边拆分边测试，保证系统的正常运行</li>
<li>兼顾技术：重构、分层（不能为了分布式而分布式，拆分过程不仅是业务梳理也是代码重构的过程，根据技术进行分层来分配工作）</li>
<li>可靠测试：测试完毕后，才可进行下一步，每一步都要有足够的测试才可进行下一步，避免小错误引起蝴蝶效应</li>
</ul>
</li>
<li><p>应用拆分时设计和选择</p>
<ul>
<li><p>应用之间通信：RPC 、消息队列、API（基于RESTFul风格的接口原则）</p>
<blockquote>
<p>消息队列通常用于传输数据包小但是数据量大，对实时性要求低的场景。而采用RPC要求实时性高</p>
</blockquote>
</li>
<li><p>应用之间数据库设计：每个应用都有独立的数据库</p>
<blockquote>
<p>通常情况下，每个应用都有自己独立的数据库，如果共同使用的信息，可以考虑放在common中使用</p>
</blockquote>
</li>
<li><p>避免事务操作跨应用；分布式事务是一个很消耗资源的问题，应用之间服务分开开发，能够保持相互独立</p>
</li>
</ul>
</li>
</ol>
<h2 id="应用限流"><a href="#应用限流" class="headerlink" title="应用限流"></a>应用限流</h2><p>​    每个API接口都是有访问上限的，当访问频率或者并发量超过其承受范围时候，我们就必须考虑限流来保证接口的可用性或者降级可用性。即接口也需要安装上保险丝，以防止非预期的请求对系统压力过大而引起的系统瘫痪。首先先了解一下一些衡量服务器指标的概念：</p>
<ul>
<li>QPS：对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准（每秒查询率）<ul>
<li>QPS = 并发量 / 平均响应时间</li>
<li>通常QPS用来表达和衡量当前系统的负载</li>
<li>对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力</li>
</ul>
</li>
<li>响应时间（RT）：响应时间是指系统对请求作出响应的时间<ul>
<li>它完整地记录了整个计算机系统处理请求的时间</li>
<li>响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度</li>
</ul>
</li>
<li>吞吐量（TPS）：系统在单位时间内处理请求的数量<ul>
<li>对于没有并发的系统而言，吞吐量就是响应时间的倒数</li>
<li>通常用吞吐量作为并发系统的性能指标</li>
<li>对于一个有并发的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致</li>
</ul>
</li>
<li>并发量：系统可以同时承载的正常使用系统功能的用户的数量<ul>
<li>对于网站系统一般会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数</li>
</ul>
</li>
</ul>
<p>​    限流就是通过对并发访问/请求进行限速或一个时间窗口内的请求进行限速，从而达到保护系统的目的。一般系统可以通过压测来<strong>预估能处理的峰值</strong>，一旦达到设定的峰值阀值，则可以：</p>
<ul>
<li>拒绝服务（定向错误页或告知资源没有了）</li>
<li>排队或等待（例如：秒杀、评论、下单）</li>
<li>降级（返回默认数据）</li>
</ul>
<p>限流常用算法：</p>
<ol>
<li><p>计数器法</p>
<blockquote>
<p>​    该算法主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流</p>
<p>​    这个方法有一个致命问题：临界问题——当遇到恶意请求，比如设定的阈值是1分钟内100次请求，在59秒时，瞬间请求100次，并且在60秒时请求100次，那么这个用户在1秒内请求了200次，用户可以在重置节点（就是重置计数器的值）时突发请求，而瞬间超过我们设置的速率限制，用户可能通过算法漏洞击垮我们的应用</p>
</blockquote>
</li>
<li><p>滑动窗口算法</p>
<blockquote>
<p>​    滑动窗口算法类似将上面计数器法的1s时间拆分成若干个小窗口（此例拆分成4个窗口），每个窗口对应250ms；假设用户利用上一秒最后一刻和下一秒第一刻发起瞬间的高并发请求；此时会统计前一秒中的最后750ms和下一秒的前250ms，这样能够判断出用户的访问依旧超过了1s的访问数量，因此依然会阻拦用户的访问</p>
</blockquote>
</li>
<li><p>漏桶算法</p>
<blockquote>
<p>​    水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水（请求）流入速度过大会直接溢出（访问频率超过接口响应速率），然后就拒绝请求（丢弃溢出的数据包）；可以看出<strong>漏桶算法能强行限制数据的传输速率</strong>。</p>
<p>​    因为漏桶的漏出速率是固定的，所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使流突发（burst）到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率</p>
</blockquote>
<p><img src="/2019/03/02/高并发场景下的优化/LeakyBucket.jpg" alt="漏桶算法示意图"></p>
</li>
<li><p>令牌桶算法</p>
<blockquote>
<p>​    随着时间流逝，系统会按恒定1/QPS时间间隔（单位是ms）往桶里加入Token（想象和漏洞漏水相反，有个水龙头在不断的加水）；如果桶已经满了就不再加了，新请求来临时会拿走一个Token，如果没有Token可拿了就阻塞（可以加入等待队列）或者拒绝服务。</p>
<p>​    <strong>令牌桶的好处是可以方便的改变速度</strong>：一旦需要提高速率（应对突发传输），则按需提高放入桶中的令牌的速率.。一般会定时（比如100毫秒）往桶中增加一定数量的令牌,，有些变种算法则实时的计算应该增加的令牌的数量</p>
</blockquote>
</li>
</ol>
<h2 id="服务降级与服务熔断"><a href="#服务降级与服务熔断" class="headerlink" title="服务降级与服务熔断"></a>服务降级与服务熔断</h2><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>​    服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。同时保证大部分请求，客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个<strong>默认</strong>的返回</p>
<h4 id="降级分类"><a href="#降级分类" class="headerlink" title="降级分类"></a>降级分类</h4><ol>
<li>降级按照是否自动化可分为：</li>
</ol>
<ul>
<li><font color="green"><strong>自动降级</strong></font>

<ul>
<li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li>
<li>失败次数降级：主要是一些不稳定的API，当<strong>失败调用次数</strong>达到一定阀值自动降级，同样要使用异步机制探测回复情况</li>
<li><font color="red">故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、RPC服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</font></li>
<li><font color="red">限流降级</font>：当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行<strong>限制访问量，当达到限流阀值，后续请求会被降级</strong>；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）</li>
</ul>
</li>
<li><p>人工降级</p>
<blockquote>
<p>在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：服务器挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；此时就可以使用开关来完成降级</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>降级按照功能可分为：</p>
<ul>
<li><p>读服务降级：对于读服务降级一般采用的策略有：暂时切换读（降级到读缓存、降级到走静态化）、暂时屏蔽读（屏蔽读入口、屏蔽某个读服务）</p>
<blockquote>
<p>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景</p>
</blockquote>
</li>
<li><p>写服务降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache</p>
</li>
</ul>
</li>
<li><p>降级按照处于的系统层次可分为：</p>
<ul>
<li>多级降级：缓存是离用户最近越高效；而降级是<strong>离用户越近</strong>越能对系统保护的好。因为业务的复杂性导致越到后端QPS/TPS越低</li>
</ul>
</li>
</ol>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>​    服务熔断一般是指软件系统中，由于某些原因使得服务出现了<strong>过载现象</strong>，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护</p>
<h3 id="服务熔断和服务降级比较"><a href="#服务熔断和服务降级比较" class="headerlink" title="服务熔断和服务降级比较"></a>服务熔断和服务降级比较</h3><ul>
<li>相似点：<ol>
<li>目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段</li>
<li>最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用</li>
<li>粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）</li>
<li>自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段</li>
</ol>
</li>
<li>不同点：<ol>
<li>触发原因不太一样，<strong>服务熔断一般是某个服务（下游服务）故障引起</strong>，而<strong>服务降级一般是从整体负荷考虑</strong></li>
<li>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li>
<li>实现方式不太一样</li>
</ol>
</li>
</ul>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>​    Hystrix旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包（<code>request collapsing</code>，即自动批处理），以及监控和配置等功能</p>
<h4 id="Hystrix能做什么"><a href="#Hystrix能做什么" class="headerlink" title="Hystrix能做什么"></a>Hystrix能做什么</h4><ul>
<li>在通过第三方客户端访问依赖服务出现高延迟或者失败时，为系统提供保护和控制</li>
<li>在分布式系统中防止级联失败</li>
<li>快速失败（Fail fast）同时能快速恢复</li>
<li>提供失败回退（Fallback）和优雅的服务降级机制</li>
<li>提供近实时的监控、报警和运维控制手段</li>
</ul>
<h4 id="Hystrix设计原则"><a href="#Hystrix设计原则" class="headerlink" title="Hystrix设计原则"></a>Hystrix设计原则</h4><ul>
<li>防止单个依赖耗尽容器（例如 Tomcat）内所有用户线程</li>
<li>降低系统负载，对无法及时处理的请求快速失败（Fail fast）而不是排队</li>
<li>提供失败回退（Fallback），以在必要时让失效对用户透明化</li>
<li>使用隔离机制（例如熔断器模式等）降低依赖服务对整个系统的影响</li>
<li>针对系统服务的度量、监控和报警，提供优化以满足近实时性的要求</li>
<li>在绝大部分需要动态调整配置并快速部署到所有应用方面，提供优化以满足快速恢复的要求</li>
<li>能保护应用不受依赖服务的整个执行过程中失败的影响，而不仅仅是网络请求</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/rifumei.jpg" alt="Adrian Dai">
            
              <p class="site-author-name" itemprop="name">Adrian Dai</p>
              <p class="site-description motion-element" itemprop="description">看板娘赛高！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/daiadrian" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:daiadrian@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/Adrian_Dai" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adrian Dai</span>

  
</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"vOffset":-100,"hOffset":0},"mobile":{"show":true,"motion":true},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
