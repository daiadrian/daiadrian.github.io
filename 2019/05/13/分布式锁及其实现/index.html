<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="分布式锁,Redis分布式锁,ZK分布式锁,">










<meta name="description" content="为什么需要分布式锁​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了 ​    在分布式场景下，CAP理论已经证明了任何一个分布式">
<meta name="keywords" content="分布式锁,Redis分布式锁,ZK分布式锁">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁及其实现">
<meta property="og:url" content="http://yoursite.com/2019/05/13/分布式锁及其实现/index.html">
<meta property="og:site_name" content="Adrian">
<meta property="og:description" content="为什么需要分布式锁​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了 ​    在分布式场景下，CAP理论已经证明了任何一个分布式">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-13T11:55:34.123Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式锁及其实现">
<meta name="twitter:description" content="为什么需要分布式锁​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了 ​    在分布式场景下，CAP理论已经证明了任何一个分布式">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/13/分布式锁及其实现/">





  <title>分布式锁及其实现 | Adrian</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/daiadrian" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Adrian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/分布式锁及其实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adrian Dai">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/rifumei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adrian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式锁及其实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T19:53:58+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>​    在单机部署的项目中，多线程间的并发控制可以由Java相关的并发处理API来控制线程间的通信和互斥。但是在分布式集群的系统中，单机部署情况下的并发控制策略就会失效了，单纯的Java API是不具备分布式环境下的并发控制能力的；所以这就需要一种跨JVM的互斥机制来控制对共享资源的访问，这就是分布式锁要解决的问题了</p>
<p>​    在分布式场景下，CAP理论已经证明了任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项；所以为了保证在分布式环境下的数据最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等</p>
<h3 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h3><ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行 </li>
<li>高可用、高性能的获取锁与释放锁</li>
<li>具备可重入特性</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ol>
<h2 id="分布式锁的三种实现方案"><a href="#分布式锁的三种实现方案" class="headerlink" title="分布式锁的三种实现方案"></a>分布式锁的三种实现方案</h2><h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><p>​    数据库实现分布式锁主要是依赖<strong>唯一索引</strong></p>
<p>（唯一索引：<u>不允许具有索引值相同的行，从而禁止重复的索引或键值</u>。数据库会在创建该索引时检查是否有重复的键值，并在每次使用 INSERT 或 UPDATE 语句时进行检查）</p>
<p>​    <font color="green"><strong>实现的思路：</strong></font>在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，因为做了唯一索引，所以即使多个请求同时提交到数据库，都只会保证只有一个操作能够成功，插入成功则获取到该方法的锁，执行完成后删除对应的行数据释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`distributed_lock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'方法名(需要锁住的方法名)'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,  </span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`index_method_name`</span> (<span class="string">`method_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<h4 id="数据库实现分布式锁的增强"><a href="#数据库实现分布式锁的增强" class="headerlink" title="数据库实现分布式锁的增强"></a>数据库实现分布式锁的增强</h4><ol>
<li><font color="blue">该分布式锁依赖数据库的可用性</font>，如果数据库是单点且挂掉，那么分布式锁功能失效<ul>
<li><strong>解决方案：</strong><ul>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">同一个线程在释放锁之前，行数据一直存在，无法再次插入数据；这种情况下该分布式锁不具备可重入性</font><ul>
<li><strong>解决方案</strong>：在表中新增一列用于记录当前获取到锁的机器和线程信息，在该线程再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁</li>
</ul>
</li>
<li><font color="blue">没有锁失效的机制可能会出现在获取锁之后，数据库宕机，对应的行数据没有被删除，等到数据库服务器恢复后，表中的数据仍然存在，从而无法再获取到锁；或者释放锁失败</font><ul>
<li><strong>解决方案</strong>：<ul>
<li>在表中新增一列，用于记录失效时间，并且需要有<strong>定时任务</strong>清除这些失效的数据；此时也需要根据业务需求考虑定时任务的执行时间，不能过长或者过短</li>
<li>多机部署，数据同步，数据库主备切换</li>
</ul>
</li>
</ul>
</li>
<li><font color="blue">阻塞锁特性</font>，在代码逻辑中增加失败重试机制（while循环），根据业务需求多次去获取锁直到成功或者达到失败次数后返回等等</li>
</ol>
<h4 id="数据库实现分布式锁的问题"><a href="#数据库实现分布式锁的问题" class="headerlink" title="数据库实现分布式锁的问题"></a>数据库实现分布式锁的问题</h4><p>​    虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。</p>
<p>​    但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁</p>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><font color="green"><strong>实现思路</strong></font>：<br><br>- setnx：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0<br><br>1. 获取锁的时候，使用setnx加锁，锁的value值可以是一个随机生成的UUID，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁<br>2. 获取锁的时候设置一个获取锁的超时时间，若超过这个时间则放弃获取锁<br>3. 释放锁的时候，通过随机生成的UUID去匹对锁的键值对是否对应，若是则执行delete释放锁<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 存放redis中的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeOut 分布式锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">lockWithTimeOut</span><span class="params">(String lockName, <span class="keyword">int</span> acquireTimeOut, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先setnx key是否成功;</span></span><br><span class="line"><span class="comment">         *      成功则设置随机值(UUID),然后设置过期时间,返回随机值给释放锁用</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      失败则计算获取锁的超时时间,时间未到则自旋获取锁直到成功或者达到超时时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String identifier = UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        timeout = System.currentTimeMillis() + timeout;</span><br><span class="line">        String reIdentifier = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//带超时时间的循环获取锁实现锁阻塞特性</span></span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() &lt; timeout)&#123;</span><br><span class="line">                Long setnx = jedis.setnx(lockName, identifier);</span><br><span class="line">                <span class="keyword">if</span> (setnx != <span class="keyword">null</span> &amp;&amp; setnx == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//设置过期时间</span></span><br><span class="line">                    jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    reIdentifier = identifier;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//这一步很重要   </span></span><br><span class="line">                 <span class="comment">//如果key已经存在,查看过期时间,如果该key无过期时间则重新设置过期时间,以免发生死锁</span></span><br><span class="line">                    Long ttl = jedis.ttl(lockName);</span><br><span class="line">                    <span class="keyword">if</span> (ttl == -<span class="number">1</span>)&#123;</span><br><span class="line">                        jedis.expire(lockName, acquireTimeOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程中断"</span>);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 锁的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifier 锁的标识(用来验证锁中的val是否一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockName, String identifier)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.select(<span class="number">0</span>);</span><br><span class="line">            jedis.watch(lockName);</span><br><span class="line">            String result = jedis.get(lockName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; identifier.equals(result))&#123;</span><br><span class="line">                Transaction multi = jedis.multi();</span><br><span class="line">                multi.del(lockName);</span><br><span class="line">                List&lt;Object&gt; exec = multi.exec();</span><br><span class="line">                <span class="keyword">if</span> (exec != <span class="keyword">null</span> &amp;&amp; exec.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TODO 处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### Redis分布式锁的增强<br><br>1. <font color="blue"><strong>锁失效时间</strong></font><br>   - 锁失效的时间需要根据实际业务需求来设置一个合适的值<br>   - <strong><font color="red">如果设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题</font></strong><br>   - <strong>如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间</strong><br>2. <font color="blue">可利用while循环去获取锁，可以设置重试间隔时间和最大重试时间来实现锁阻塞特性</font><br>3. <font color="blue">不可重入</font><br>   - <strong>解决方案</strong>：<br>     - 线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者；释放锁的时候将这些信息删除<br>4. <font color="blue">单点故障</font><br>   - <strong>解决方案：</strong><br>     - Redis集群，Redis主从<br><br><br><br>#### Redis实现分布式锁存在的问题<br><br>​    这类最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：<br><br>1. 在Redis的master节点上拿到了锁<br>2. 但是这个加锁的key还没有同步到slave节点<br>3. master故障，发生故障转移，slave节点升级为master节点<br>4. 导致锁丢失<br><br><br><br>### Zookeeper实现分布式锁<br><br><font color="green"><strong>实现思路：</strong></font>

<p>​    每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的<strong>瞬时有序节点</strong>（EPHEMERAL_SEQUENTIAL）</p>
<p>​    使用Zookeeper可以实现的分布式锁是阻塞的，客户端可以通过在ZK中创建瞬时有序节点，并且在节点上绑定监听器，一旦节点发生变化，ZK会通知客户端，客户端可以检查自己创建的节点是不是<strong><font color="red">当前所有节点中序号最小的</font></strong>，如果是那么自己就获取到锁，反之则继续等待</p>
<p>​     当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题，因为<strong>瞬时节点在会话断开后就会自动删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zookeeper 实现分布式锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK对象</span></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 分布式锁的根节点</span></span><br><span class="line">    <span class="keyword">private</span> String rootLockNode;</span><br><span class="line">    <span class="comment">// 竞争资源，用来生成子节点名称</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line">    <span class="comment">// 当前锁</span></span><br><span class="line">    <span class="keyword">private</span> String currentLock;</span><br><span class="line">    <span class="comment">// 等待的锁（前一个锁）</span></span><br><span class="line">    <span class="keyword">private</span> String waitLock;</span><br><span class="line">    <span class="comment">// 计数器（用来在加锁失败时阻塞加锁线程）</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  构造器中创建ZK链接，创建锁的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zkAddress     ZK的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rootLockNode  根节点名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName      子节点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperLock</span><span class="params">(String zkAddress, String rootLockNode, String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootLockNode = rootLockNode;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建连接，zkAddress格式为：IP:PORT</span></span><br><span class="line"><span class="comment">             * watcher监听器为自身</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(zkAddress, <span class="keyword">this</span>.sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测锁的根节点是否存在，不存在则创建</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Stat stat = zk.exists(rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == stat) &#123;</span><br><span class="line">                zk.create(rootLockNode, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁方法，先尝试加锁，不能加锁则等待上一个锁的释放</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】加锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> waitOtherLock(<span class="keyword">this</span>.waitLock, <span class="keyword">this</span>.sessionTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分隔符</span></span><br><span class="line">        String split = <span class="string">"_lock_"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lockName.contains(<span class="string">"_lock_"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"lockName can't contains '_lock_' "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建锁节点（临时有序节点）并且得到节点名称</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * path: 根节点/子锁名称+分隔符</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.currentLock = zk.create(<span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + <span class="keyword">this</span>.lockName + split, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>],</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"】创建锁节点（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）成功，开始竞争..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有子节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; nodes = zk.getChildren(<span class="keyword">this</span>.rootLockNode, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取所有正在竞争lockName的锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; lockNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String nodeName : nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodeName.split(split)[<span class="number">0</span>].equals(<span class="keyword">this</span>.lockName)) &#123;</span><br><span class="line">                    lockNodes.add(nodeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(lockNodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取最小节点与当前锁节点比对加锁</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *      比对最小节点的名称是否跟刚才创建的临时节点名称一致</span></span><br><span class="line"><span class="comment">             *      一致则证明当前加锁成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockPath = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + lockNodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.currentLock.equals(currentLockPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁失败，设置前一节点为等待锁节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String currentLockNode = <span class="keyword">this</span>.currentLock.substring(<span class="keyword">this</span>.currentLock.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> preNodeIndex = Collections.binarySearch(lockNodes, currentLockNode) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.waitLock = lockNodes.get(preNodeIndex);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁，带超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitLock          当前节点的前一个锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionTimeout    等待获取锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitOtherLock</span><span class="params">(String waitLock, <span class="keyword">int</span> sessionTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> islock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 监听等待锁节点</span></span><br><span class="line">            String waitLockNode = <span class="keyword">this</span>.rootLockNode + <span class="string">"/"</span> + waitLock;</span><br><span class="line">            Stat stat = zk.exists(waitLockNode, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"】锁（"</span> + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败，等待锁（"</span> + waitLockNode + <span class="string">"）释放..."</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 设置计数器，使用计数器阻塞线程,带超时时间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                islock = <span class="keyword">this</span>.countDownLatch.await(sessionTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">this</span>.countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (islock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁成功，锁（"</span> + waitLockNode + <span class="string">"）已经释放"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】锁（"</span></span><br><span class="line">                            + <span class="keyword">this</span>.currentLock + <span class="string">"）加锁失败..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                islock = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stat stat = zk.exists(<span class="keyword">this</span>.currentLock, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getName() + <span class="string">"】释放锁 "</span> + <span class="keyword">this</span>.currentLock);</span><br><span class="line">                zk.delete(<span class="keyword">this</span>.currentLock, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">this</span>.currentLock = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点监听器回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听节点删除的事件</span></span><br><span class="line"><span class="comment">         *      计数器减一，恢复线程操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.countDownLatch &amp;&amp; watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Curator的分布式锁"><a href="#Curator的分布式锁" class="headerlink" title="Curator的分布式锁"></a>Curator的分布式锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator 实现的分布式锁:</span></span><br><span class="line"><span class="comment"> *          InterProcessMutex:          分布式可重入排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessSemaphoreMutex: 分布式排它锁</span></span><br><span class="line"><span class="comment"> *          InterProcessReadWriteLock:  分布式读写锁</span></span><br><span class="line"><span class="comment"> *          InterProcessMultiLock:      将多个锁作为单个实体管理的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置重试策略，创建zk客户端</span></span><br><span class="line"><span class="comment">         * curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *              baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *              maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *              maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = </span><br><span class="line">            CuratorFrameworkFactory.newClient(<span class="string">"127.0.0.1:2181"</span>, retryPolicy);</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建分布式可重入排他锁，监听客户端为client，锁的根节点为/locks</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InterProcessMutex mutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/locks"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 加锁操作</span></span><br><span class="line"><span class="comment">             *     public boolean acquire(long time, TimeUnit unit)</span></span><br><span class="line"><span class="comment">             *          第一个参数是超时时间</span></span><br><span class="line"><span class="comment">             *          第二个参数是时间的单位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.acquire(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 释放锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ZK实现分布式锁的问题"><a href="#ZK实现分布式锁的问题" class="headerlink" title="ZK实现分布式锁的问题"></a>ZK实现分布式锁的问题</h4><p>​    <strong>使用Zookeeper也有可能带来并发问题：</strong>由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了，就可能产生并发问题。</p>
<p>​    这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，<font color="red">Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点（所以选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡）</font></p>
<h3 id="三者的比较"><a href="#三者的比较" class="headerlink" title="三者的比较"></a>三者的比较</h3><ol>
<li><strong>从性能角度（从高到低）</strong><ul>
<li>缓存 &gt; Zookeeper &gt;= 数据库</li>
</ul>
</li>
<li><strong>从可靠性角度（从高到低）</strong><ul>
<li>Zookeeper &gt; 缓存 &gt; 数据库</li>
</ul>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/分布式锁/" rel="tag"><i class="fa fa-tag"></i> 分布式锁</a>
          
            <a href="/tags/Redis分布式锁/" rel="tag"><i class="fa fa-tag"></i> Redis分布式锁</a>
          
            <a href="/tags/ZK分布式锁/" rel="tag"><i class="fa fa-tag"></i> ZK分布式锁</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/08/Linux操作系统的五种IO模型/" rel="next" title="Linux操作系统的五种IO模型">
                <i class="fa fa-chevron-left"></i> Linux操作系统的五种IO模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/rifumei.jpg" alt="Adrian Dai">
            
              <p class="site-author-name" itemprop="name">Adrian Dai</p>
              <p class="site-description motion-element" itemprop="description">看板娘赛高！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/daiadrian" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:daiadrian@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/Adrian_Dai" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要分布式锁"><span class="nav-number">1.</span> <span class="nav-text">为什么需要分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁的特性"><span class="nav-number">1.1.</span> <span class="nav-text">分布式锁的特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式锁的三种实现方案"><span class="nav-number">2.</span> <span class="nav-text">分布式锁的三种实现方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库实现"><span class="nav-number">2.1.</span> <span class="nav-text">数据库实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库实现分布式锁的增强"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据库实现分布式锁的增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库实现分布式锁的问题"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据库实现分布式锁的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis实现分布式锁"><span class="nav-number">2.2.</span> <span class="nav-text">Redis实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Curator的分布式锁"><span class="nav-number">2.2.1.</span> <span class="nav-text">Curator的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZK实现分布式锁的问题"><span class="nav-number">2.2.2.</span> <span class="nav-text">ZK实现分布式锁的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三者的比较"><span class="nav-number">2.3.</span> <span class="nav-text">三者的比较</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adrian Dai</span>

  
</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300,"vOffset":-100,"hOffset":0},"mobile":{"show":true,"motion":true},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
